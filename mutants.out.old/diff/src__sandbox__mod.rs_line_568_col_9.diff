--- src/sandbox/mod.rs
+++ replace WasmRuntime::validate_module_binary -> Result<()> with Ok(())
@@ -560,59 +560,17 @@
             .to_string()
     }
 
     fn resolve_fuel_limit(config: &ToolSandboxConfig) -> Option<u64> {
         config.wasm.fuel.filter(|limit| *limit > 0)
     }
 
     pub fn validate_module_binary(tool_name: &str, config: &ToolSandboxConfig) -> Result<()> {
-        let module_path = Self::resolve_module_path(tool_name, config);
-        let path = Path::new(&module_path);
-
-        if !path.exists() {
-            return Err(ButterflyBotError::Runtime(format!(
-                "WASM module path does not exist for tool '{tool_name}': {module_path}"
-            )));
-        }
-
-        let mut file = File::open(path)
-            .map_err(|e| ButterflyBotError::Runtime(format!("Failed to open wasm module: {e}")))?;
-        let mut header = [0u8; 4];
-        file.read_exact(&mut header).map_err(|e| {
-            ButterflyBotError::Runtime(format!(
-                "Failed to read wasm module header for tool '{tool_name}' ({module_path}): {e}"
-            ))
-        })?;
-
-        if header != Self::WASM_MAGIC {
-            return Err(ButterflyBotError::Runtime(format!(
-                "Invalid wasm module for tool '{tool_name}' at {module_path}: missing wasm magic header"
-            )));
-        }
-
-        let mut tail = Vec::new();
-        file.read_to_end(&mut tail).map_err(|e| {
-            ButterflyBotError::Runtime(format!(
-                "Failed to inspect wasm module body for tool '{tool_name}' ({module_path}): {e}"
-            ))
-        })?;
-        if tail
-            .windows("stub responses".len())
-            .any(|w| w == b"stub responses")
-            || tail
-                .windows("\"stub\":true".len())
-                .any(|w| w == b"\"stub\":true")
-        {
-            return Err(ButterflyBotError::Runtime(format!(
-                "WASM module for tool '{tool_name}' at {module_path} is a placeholder stub. Build/install a real WASM implementation before starting the daemon."
-            )));
-        }
-
-        Ok(())
+        Ok(()) /* ~ changed by cargo-mutants ~ */
     }
 
     pub fn validate_capability_abi(tool_name: &str, config: &ToolSandboxConfig) -> Result<()> {
         if let Some(version) = config.capabilities.abi_version {
             if version != Self::SUPPORTED_CAPABILITY_ABI_VERSION {
                 return Err(ButterflyBotError::Runtime(format!(
                     "Tool '{tool_name}' uses unsupported capability ABI version {version}; supported version is {}",
                     Self::SUPPORTED_CAPABILITY_ABI_VERSION
