--- src/reminders/mod.rs
+++ replace ReminderStore::due_reminders -> Result<Vec<ReminderItem>> with Ok(vec![])
@@ -223,49 +223,17 @@
     }
 
     pub async fn due_reminders(
         &self,
         user_id: &str,
         now: i64,
         limit: usize,
     ) -> Result<Vec<ReminderItem>> {
-        let mut conn = self.conn().await?;
-        let mut query = reminders::table
-            .filter(reminders::user_id.eq(user_id))
-            .filter(reminders::completed_at.is_null())
-            .filter(reminders::due_at.le(now))
-            .filter(reminders::fired_at.is_null())
-            .into_boxed();
-        if limit > 0 {
-            query = query.limit(limit as i64);
-        }
-        let rows: Vec<ReminderRow> = query
-            .order(reminders::due_at.asc())
-            .load(&mut conn)
-            .await
-            .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;
-
-        if !rows.is_empty() {
-            let ids: Vec<i32> = rows.iter().map(|row| row.id).collect();
-            diesel::update(
-                reminders::table
-                    .filter(reminders::user_id.eq(user_id))
-                    .filter(reminders::id.eq_any(&ids)),
-            )
-            .set((
-                reminders::fired_at.eq(Some(now)),
-                reminders::completed_at.eq(Some(now)),
-            ))
-            .execute(&mut conn)
-            .await
-            .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;
-        }
-
-        Ok(rows.into_iter().map(map_row).collect())
+        Ok(vec![]) /* ~ changed by cargo-mutants ~ */
     }
 
     pub async fn peek_due_reminders(
         &self,
         user_id: &str,
         now: i64,
         limit: usize,
     ) -> Result<Vec<ReminderItem>> {
