--- src/sandbox/mod.rs
+++ replace WasmRuntime::execute_sync -> Result<Value> with Ok(Default::default())
@@ -651,164 +651,17 @@
             return Err(ButterflyBotError::Runtime(
                 "WASM memory range out of bounds".to_string(),
             ));
         }
         Ok(())
     }
 
     fn execute_sync(tool_name: &str, config: &ToolSandboxConfig, params: Value) -> Result<Value> {
-        let mut module_path = Self::resolve_module_path(tool_name, config);
-
-        if !Path::new(&module_path).exists()
-            && (module_path.starts_with("./wasm/") || module_path.starts_with("wasm/"))
-        {
-            if let Ok(wasm_dir) = crate::wasm_bundle::ensure_bundled_wasm_tools() {
-                let candidate = wasm_dir.join(Self::module_filename(tool_name));
-                if candidate.exists() {
-                    module_path = candidate.to_string_lossy().to_string();
-                }
-            }
-        }
-
-        tracing::info!(tool = %tool_name, module_path = %module_path, "Executing tool in WASM runtime");
-
-        if !Path::new(&module_path).exists() {
-            return Err(ButterflyBotError::Runtime(format!(
-                "WASM module path does not exist for tool '{tool_name}': {module_path}"
-            )));
-        }
-
-        let entrypoint = Self::resolve_entrypoint(config);
-        let timeout_ms = config.wasm.timeout_ms.unwrap_or(0);
-        let fuel_limit = Self::resolve_fuel_limit(config);
-
-        let mut wasm_config = wasmtime::Config::new();
-        if timeout_ms > 0 {
-            wasm_config.epoch_interruption(true);
-        }
-        if fuel_limit.is_some() {
-            wasm_config.consume_fuel(true);
-        }
-
-        let engine = Engine::new(&wasm_config).map_err(|e| {
-            ButterflyBotError::Runtime(format!("Failed to initialize wasm engine: {e}"))
-        })?;
-        let module = Module::from_file(&engine, &module_path)
-            .map_err(|e| ButterflyBotError::Runtime(format!("Failed to load wasm module: {e}")))?;
-        let linker = Linker::new(&engine);
-        let mut store = Store::new(&engine, ());
-
-        if let Some(limit) = fuel_limit {
-            store.set_fuel(limit).map_err(|e| {
-                ButterflyBotError::Runtime(format!("Failed to apply wasm fuel limit: {e}"))
-            })?;
-        }
-
-        let _timeout_guard = if timeout_ms > 0 {
-            store.set_epoch_deadline(1);
-            let done = Arc::new(AtomicBool::new(false));
-            let done_for_thread = done.clone();
-            let engine_for_thread = engine.clone();
-            std::thread::spawn(move || {
-                std::thread::sleep(Duration::from_millis(timeout_ms));
-                if !done_for_thread.load(Ordering::Relaxed) {
-                    engine_for_thread.increment_epoch();
-                }
-            });
-            Some(TimeoutCompletion { done })
-        } else {
-            None
-        };
-
-        let instance = linker.instantiate(&mut store, &module).map_err(|e| {
-            ButterflyBotError::Runtime(format!("Failed to instantiate wasm module: {e}"))
-        })?;
-
-        let memory = instance.get_memory(&mut store, "memory").ok_or_else(|| {
-            ButterflyBotError::Runtime("WASM module missing exported memory".to_string())
-        })?;
-
-        let alloc = instance
-            .get_typed_func::<i32, i32>(&mut store, "alloc")
-            .map_err(|_| {
-                ButterflyBotError::Runtime(
-                    "WASM module missing `alloc(i32)->i32` export".to_string(),
-                )
-            })?;
-
-        let dealloc = instance
-            .get_typed_func::<(i32, i32), ()>(&mut store, "dealloc")
-            .map_err(|_| {
-                ButterflyBotError::Runtime(
-                    "WASM module missing `dealloc(i32,i32)->()` export".to_string(),
-                )
-            })?;
-
-        let exec = instance
-            .get_typed_func::<(i32, i32), i64>(&mut store, &entrypoint)
-            .map_err(|_| {
-                ButterflyBotError::Runtime(format!(
-                    "WASM module missing `{entrypoint}(i32,i32)->i64` export"
-                ))
-            })?;
-
-        let input = serde_json::to_vec(&params)
-            .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;
-        if input.len() > Self::MAX_INPUT_BYTES {
-            return Err(ButterflyBotError::Runtime(format!(
-                "WASM tool input too large: {} bytes (max {})",
-                input.len(),
-                Self::MAX_INPUT_BYTES
-            )));
-        }
-
-        let input_len = i32::try_from(input.len()).map_err(|_| {
-            ButterflyBotError::Runtime("WASM input too large to pass as i32 length".to_string())
-        })?;
-
-        let input_ptr = alloc
-            .call(&mut store, input_len)
-            .map_err(|e| ButterflyBotError::Runtime(format!("WASM alloc failed: {e}")))?;
-
-        Self::ensure_range(&memory, &store, input_ptr, input_len)?;
-        memory
-            .write(&mut store, input_ptr as usize, &input)
-            .map_err(|e| ButterflyBotError::Runtime(format!("WASM memory write failed: {e}")))?;
-
-        let packed = exec.call(&mut store, (input_ptr, input_len)).map_err(|e| {
-            let msg = e.to_string();
-            if timeout_ms > 0 && msg.to_ascii_lowercase().contains("interrupt") {
-                ButterflyBotError::Runtime(format!(
-                    "WASM tool '{tool_name}' timed out after {timeout_ms}ms"
-                ))
-            } else {
-                ButterflyBotError::Runtime(format!("WASM tool execute failed: {msg}"))
-            }
-        })?;
-
-        let (output_ptr, output_len) = Self::split_ptr_len(packed)?;
-        Self::ensure_range(&memory, &store, output_ptr, output_len)?;
-
-        let mut output = vec![0u8; output_len as usize];
-        memory
-            .read(&store, output_ptr as usize, &mut output)
-            .map_err(|e| ButterflyBotError::Runtime(format!("WASM memory read failed: {e}")))?;
-
-        let _ = dealloc.call(&mut store, (input_ptr, input_len));
-        let _ = dealloc.call(&mut store, (output_ptr, output_len));
-
-        if output.is_empty() {
-            return Ok(serde_json::json!({}));
-        }
-
-        let value: Value = serde_json::from_slice(&output).map_err(|e| {
-            ButterflyBotError::Runtime(format!("WASM output must be valid JSON: {e}"))
-        })?;
-        Ok(value)
+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */
     }
 
     pub async fn execute(
         &self,
         tool_name: &str,
         config: &ToolSandboxConfig,
         params: Value,
     ) -> Result<Value> {
