--- src/daemon.rs
+++ replace run_security_audit_checks -> Vec<SecurityAuditFinding> with vec![Default::default()]
@@ -670,177 +670,17 @@
         .iter()
         .filter(|finding| finding.status != "pass")
         .max_by_key(|finding| severity_rank(&finding.severity))
         .map(|finding| finding.severity.clone())
         .unwrap_or_else(|| "low".to_string())
 }
 
 async fn run_security_audit_checks(state: &AppState) -> Vec<SecurityAuditFinding> {
-    let mut findings = Vec::new();
-
-    if state.token.trim().is_empty() {
-        findings.push(security_finding(
-            "daemon_auth_token",
-            "medium",
-            "warn",
-            "Daemon auth token is empty; this is unexpected because token bootstrap is automatic and protected endpoints fail closed."
-                .to_string(),
-            Some("Restart the app/daemon to re-run token bootstrap and verify keyring/secret-store availability."),
-            false,
-        ));
-    } else {
-        findings.push(security_finding(
-            "daemon_auth_token",
-            "low",
-            "pass",
-            "Daemon auth token is configured.".to_string(),
-            None,
-            false,
-        ));
-    }
-
-    match Config::from_store(&state.db_path) {
-        Ok(config) => {
-            findings.push(security_finding(
-                "config_load",
-                "low",
-                "pass",
-                "Config loaded from store/keyring.".to_string(),
-                None,
-                false,
-            ));
-
-            let has_inline_api_key = config
-                .openai
-                .as_ref()
-                .and_then(|openai| openai.api_key.as_ref())
-                .map(|key| !key.trim().is_empty())
-                .unwrap_or(false)
-                || config
-                    .memory
-                    .as_ref()
-                    .and_then(|memory| memory.openai.as_ref())
-                    .and_then(|openai| openai.api_key.as_ref())
-                    .map(|key| !key.trim().is_empty())
-                    .unwrap_or(false);
-
-            if has_inline_api_key {
-                findings.push(security_finding(
-                    "inline_api_keys",
-                    "high",
-                    "warn",
-                    "API keys appear inline in config JSON; prefer keyring-backed secrets."
-                        .to_string(),
-                    Some("Remove inline keys and set secrets via `butterfly-bot secrets-set`."),
-                    false,
-                ));
-            } else {
-                findings.push(security_finding(
-                    "inline_api_keys",
-                    "low",
-                    "pass",
-                    "No inline API keys detected in loaded config.".to_string(),
-                    None,
-                    false,
-                ));
-            }
-
-            let root = json!({ "tools": config.tools.clone().unwrap_or(Value::Null) });
-            let sandbox = SandboxSettings::from_root_config(&root);
-
-            let built_in_tools = [
-                "coding",
-                "mcp",
-                "http_call",
-                "github",
-                "zapier",
-                "planning",
-                "reminders",
-                "search_internet",
-                "tasks",
-                "todo",
-                "wakeup",
-            ];
-            let mut non_wasm_tools = Vec::new();
-            for tool_name in built_in_tools {
-                let plan = sandbox.execution_plan(tool_name);
-                if plan.runtime != ToolRuntime::Wasm {
-                    non_wasm_tools.push(tool_name);
-                }
-            }
-
-            if non_wasm_tools.is_empty() {
-                findings.push(security_finding(
-                    "tool_runtime_invariant",
-                    "low",
-                    "pass",
-                    "All built-in tools resolve to WASM runtime.".to_string(),
-                    None,
-                    false,
-                ));
-            } else {
-                findings.push(security_finding(
-                    "tool_runtime_invariant",
-                    "high",
-                    "fail",
-                    format!(
-                        "Non-WASM tool runtime detected for: {}.",
-                        non_wasm_tools.join(", ")
-                    ),
-                    Some(
-                        "Enforce WASM-only execution in sandbox settings and tool runtime planner.",
-                    ),
-                    false,
-                ));
-            }
-
-            let default_deny = config
-                .tools
-                .as_ref()
-                .and_then(|tools| tools.get("settings"))
-                .and_then(|settings| settings.get("permissions"))
-                .and_then(|permissions| permissions.get("default_deny"))
-                .and_then(|value| value.as_bool())
-                .unwrap_or(false);
-
-            if default_deny {
-                findings.push(security_finding(
-                    "network_default_deny",
-                    "low",
-                    "pass",
-                    "Global tools network policy uses default_deny=true.".to_string(),
-                    None,
-                    false,
-                ));
-            } else {
-                findings.push(security_finding(
-                    "network_default_deny",
-                    "medium",
-                    "warn",
-                    "Global tools network policy default_deny is disabled or missing."
-                        .to_string(),
-                    Some("Set tools.settings.permissions.default_deny to true and allowlist required domains."),
-                    false,
-                ));
-            }
-        }
-        Err(err) => {
-            findings.push(security_finding(
-                "config_load",
-                "critical",
-                "fail",
-                format!("Config load failed: {err}"),
-                Some("Save a valid config in Config tab and rerun security audit."),
-                false,
-            ));
-        }
-    }
-
-    findings
+    vec![Default::default()] /* ~ changed by cargo-mutants ~ */
 }
 
 async fn run_doctor_checks(state: &AppState) -> Vec<DoctorCheck> {
     let mut checks = Vec::new();
 
     if state.token.trim().is_empty() {
         checks.push(doctor_check(
             "daemon_auth_token",
