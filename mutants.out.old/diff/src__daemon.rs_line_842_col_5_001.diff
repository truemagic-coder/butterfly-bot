--- src/daemon.rs
+++ replace run_doctor_checks -> Vec<DoctorCheck> with vec![Default::default()]
@@ -834,160 +834,17 @@
             ));
         }
     }
 
     findings
 }
 
 async fn run_doctor_checks(state: &AppState) -> Vec<DoctorCheck> {
-    let mut checks = Vec::new();
-
-    if state.token.trim().is_empty() {
-        checks.push(doctor_check(
-            "daemon_auth_token",
-            "warn",
-            "Daemon auth token is empty; this is unexpected because token bootstrap is automatic and protected endpoints fail closed."
-                .to_string(),
-            Some("Restart the app/daemon to re-run token bootstrap and verify keyring/secret-store availability."),
-        ));
-    } else {
-        checks.push(doctor_check(
-            "daemon_auth_token",
-            "pass",
-            "Daemon auth token is configured.".to_string(),
-            None,
-        ));
-    }
-
-    match Config::from_store(&state.db_path) {
-        Ok(config) => {
-            checks.push(doctor_check(
-                "config_store",
-                "pass",
-                "Config loaded from store/keyring.".to_string(),
-                None,
-            ));
-
-            match config.clone().resolve_vault() {
-                Ok(_) => {
-                    checks.push(doctor_check(
-                        "vault_resolution",
-                        "pass",
-                        "Vault-backed secrets resolved successfully.".to_string(),
-                        None,
-                    ));
-                }
-                Err(err) => {
-                    checks.push(doctor_check(
-                        "vault_resolution",
-                        "fail",
-                        format!("Vault resolution failed: {err}"),
-                        Some("Verify OS keychain access and required secret keys."),
-                    ));
-                }
-            }
-
-            match check_provider_health(&config).await {
-                Ok(check) => checks.push(check),
-                Err(err) => checks.push(doctor_check(
-                    "provider_health",
-                    "fail",
-                    format!("Provider health check failed: {err}"),
-                    Some("Verify provider base_url/model and network access."),
-                )),
-            }
-        }
-        Err(err) => {
-            checks.push(doctor_check(
-                "config_store",
-                "fail",
-                format!("Config load failed: {err}"),
-                Some("Save a valid config in the Config tab and retry."),
-            ));
-            checks.push(doctor_check(
-                "vault_resolution",
-                "warn",
-                "Skipped because config could not be loaded.".to_string(),
-                Some("Fix config_store check first."),
-            ));
-            checks.push(doctor_check(
-                "provider_health",
-                "warn",
-                "Skipped because config could not be loaded.".to_string(),
-                Some("Fix config_store check first."),
-            ));
-        }
-    }
-
-    let db_path = state.db_path.clone();
-    let db_check = tokio::task::spawn_blocking(move || -> DoctorCheck {
-        if let Err(err) = crate::config_store::ensure_parent_dir(&db_path) {
-            return doctor_check(
-                "database_access",
-                "fail",
-                format!("Database directory check failed: {err}"),
-                Some("Verify filesystem permissions for DB path."),
-            );
-        }
-
-        let mut conn = match SqliteConnection::establish(&db_path) {
-            Ok(conn) => conn,
-            Err(err) => {
-                return doctor_check(
-                    "database_access",
-                    "fail",
-                    format!("Database open failed: {err}"),
-                    Some("Verify DB path and SQLite/SQLCipher availability."),
-                )
-            }
-        };
-
-        if let Err(err) = crate::db::apply_sqlcipher_key_sync(&mut conn) {
-            return doctor_check(
-                "database_access",
-                "fail",
-                format!("Database key apply failed: {err}"),
-                Some("Verify secure secret storage availability for db_encryption_key."),
-            );
-        }
-
-        let probe_result = diesel::sql_query(
-            "CREATE TABLE IF NOT EXISTS doctor_probe (id INTEGER PRIMARY KEY, ts INTEGER NOT NULL)",
-        )
-        .execute(&mut conn);
-
-        match probe_result {
-            Ok(_) => doctor_check(
-                "database_access",
-                "pass",
-                "Database opened and write probe succeeded.".to_string(),
-                None,
-            ),
-            Err(err) => doctor_check(
-                "database_access",
-                "fail",
-                format!("Database write probe failed: {err}"),
-                Some("Verify DB permissions and SQLCipher key configuration."),
-            ),
-        }
-    })
-    .await;
-
-    match db_check {
-        Ok(check) => checks.push(check),
-        Err(err) => checks.push(doctor_check(
-            "database_access",
-            "fail",
-            format!("Database check task failed: {err}"),
-            Some("Retry diagnostics; if persistent, inspect runtime logs."),
-        )),
-    }
-
-    checks
+    vec![Default::default()] /* ~ changed by cargo-mutants ~ */
 }
 
 async fn check_provider_health(config: &Config) -> Result<DoctorCheck> {
     let provider = config.openai.clone().or_else(|| {
         config
             .memory
             .as_ref()
             .and_then(|memory| memory.openai.clone())
