--- src/security/cocoon_store.rs
+++ replace unwrap_envelope -> Result<Vec<u8>> with Ok(vec![])
@@ -14,49 +14,17 @@
     out.extend_from_slice(BLOB_MAGIC);
     out.push(BLOB_VERSION);
     out.push(CIPHER_CHA_CHA20_POLY1305);
     out.extend_from_slice(payload);
     out
 }
 
 fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {
-    if raw.len() < 6 {
-        return Err(ButterflyBotError::SecurityStorage(format!(
-            "encrypted secret {} has invalid envelope length",
-            path.to_string_lossy()
-        )));
-    }
-
-    if &raw[0..4] != BLOB_MAGIC {
-        return Err(ButterflyBotError::SecurityStorage(format!(
-            "encrypted secret {} has invalid envelope magic",
-            path.to_string_lossy()
-        )));
-    }
-
-    let version = raw[4];
-    if version != BLOB_VERSION {
-        return Err(ButterflyBotError::SecurityStorage(format!(
-            "encrypted secret {} has unsupported envelope version {}",
-            path.to_string_lossy(),
-            version
-        )));
-    }
-
-    let cipher = raw[5];
-    if cipher != CIPHER_CHA_CHA20_POLY1305 {
-        return Err(ButterflyBotError::SecurityStorage(format!(
-            "encrypted secret {} has unsupported cipher id {}",
-            path.to_string_lossy(),
-            cipher
-        )));
-    }
-
-    Ok(raw[6..].to_vec())
+    Ok(vec![]) /* ~ changed by cargo-mutants ~ */
 }
 
 pub fn load_secret(path: &Path, passphrase: &str) -> Result<Option<String>> {
     if !path.exists() {
         return Ok(None);
     }
 
     let mut file = File::open(path).map_err(|e| {
