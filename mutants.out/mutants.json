[
  {
    "diff": "--- src/daemon.rs\n+++ replace set_autonomy_cooldown_seconds with ()\n@@ -46,17 +46,17 @@\n     pub ui_event_tx: broadcast::Sender<UiEvent>,\n     pub db_path: String,\n }\n \n static AUTONOMY_LAST_RUN_TS: AtomicI64 = AtomicI64::new(0);\n static AUTONOMY_COOLDOWN_SECS: AtomicI64 = AtomicI64::new(60);\n \n fn set_autonomy_cooldown_seconds(seconds: u64) {\n-    AUTONOMY_COOLDOWN_SECS.store(seconds.max(1) as i64, Ordering::Relaxed);\n+    () /* ~ changed by cargo-mutants ~ */\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n     loop {\n         let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n         let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n         if last > 0 {\n             let elapsed = now_ts.saturating_sub(last);\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "set_autonomy_cooldown_seconds",
      "return_type": "",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 53
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:54:5: replace set_autonomy_cooldown_seconds with ()",
    "package": "butterfly-bot",
    "replacement": "()",
    "span": {
      "end": {
        "column": 76,
        "line": 54
      },
      "start": {
        "column": 5,
        "line": 54
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace try_begin_autonomy_tick -> Option<i64> with None\n@@ -50,33 +50,17 @@\n static AUTONOMY_LAST_RUN_TS: AtomicI64 = AtomicI64::new(0);\n static AUTONOMY_COOLDOWN_SECS: AtomicI64 = AtomicI64::new(60);\n \n fn set_autonomy_cooldown_seconds(seconds: u64) {\n     AUTONOMY_COOLDOWN_SECS.store(seconds.max(1) as i64, Ordering::Relaxed);\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n-    loop {\n-        let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n-        let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n-        if last > 0 {\n-            let elapsed = now_ts.saturating_sub(last);\n-            if elapsed < cooldown {\n-                return Some(cooldown - elapsed);\n-            }\n-        }\n-\n-        if AUTONOMY_LAST_RUN_TS\n-            .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n-            .is_ok()\n-        {\n-            return None;\n-        }\n-    }\n+    None /* ~ changed by cargo-mutants ~ */\n }\n \n struct BrainTickJob {\n     agent: Arc<RwLock<Arc<ButterflyBot>>>,\n     interval: Duration,\n }\n \n #[async_trait::async_trait]\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:58:5: replace try_begin_autonomy_tick -> Option<i64> with None",
    "package": "butterfly-bot",
    "replacement": "None",
    "span": {
      "end": {
        "column": 6,
        "line": 74
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace try_begin_autonomy_tick -> Option<i64> with Some(0)\n@@ -50,33 +50,17 @@\n static AUTONOMY_LAST_RUN_TS: AtomicI64 = AtomicI64::new(0);\n static AUTONOMY_COOLDOWN_SECS: AtomicI64 = AtomicI64::new(60);\n \n fn set_autonomy_cooldown_seconds(seconds: u64) {\n     AUTONOMY_COOLDOWN_SECS.store(seconds.max(1) as i64, Ordering::Relaxed);\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n-    loop {\n-        let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n-        let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n-        if last > 0 {\n-            let elapsed = now_ts.saturating_sub(last);\n-            if elapsed < cooldown {\n-                return Some(cooldown - elapsed);\n-            }\n-        }\n-\n-        if AUTONOMY_LAST_RUN_TS\n-            .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n-            .is_ok()\n-        {\n-            return None;\n-        }\n-    }\n+    Some(0) /* ~ changed by cargo-mutants ~ */\n }\n \n struct BrainTickJob {\n     agent: Arc<RwLock<Arc<ButterflyBot>>>,\n     interval: Duration,\n }\n \n #[async_trait::async_trait]\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:58:5: replace try_begin_autonomy_tick -> Option<i64> with Some(0)",
    "package": "butterfly-bot",
    "replacement": "Some(0)",
    "span": {
      "end": {
        "column": 6,
        "line": 74
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace try_begin_autonomy_tick -> Option<i64> with Some(1)\n@@ -50,33 +50,17 @@\n static AUTONOMY_LAST_RUN_TS: AtomicI64 = AtomicI64::new(0);\n static AUTONOMY_COOLDOWN_SECS: AtomicI64 = AtomicI64::new(60);\n \n fn set_autonomy_cooldown_seconds(seconds: u64) {\n     AUTONOMY_COOLDOWN_SECS.store(seconds.max(1) as i64, Ordering::Relaxed);\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n-    loop {\n-        let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n-        let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n-        if last > 0 {\n-            let elapsed = now_ts.saturating_sub(last);\n-            if elapsed < cooldown {\n-                return Some(cooldown - elapsed);\n-            }\n-        }\n-\n-        if AUTONOMY_LAST_RUN_TS\n-            .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n-            .is_ok()\n-        {\n-            return None;\n-        }\n-    }\n+    Some(1) /* ~ changed by cargo-mutants ~ */\n }\n \n struct BrainTickJob {\n     agent: Arc<RwLock<Arc<ButterflyBot>>>,\n     interval: Duration,\n }\n \n #[async_trait::async_trait]\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:58:5: replace try_begin_autonomy_tick -> Option<i64> with Some(1)",
    "package": "butterfly-bot",
    "replacement": "Some(1)",
    "span": {
      "end": {
        "column": 6,
        "line": 74
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace try_begin_autonomy_tick -> Option<i64> with Some(-1)\n@@ -50,33 +50,17 @@\n static AUTONOMY_LAST_RUN_TS: AtomicI64 = AtomicI64::new(0);\n static AUTONOMY_COOLDOWN_SECS: AtomicI64 = AtomicI64::new(60);\n \n fn set_autonomy_cooldown_seconds(seconds: u64) {\n     AUTONOMY_COOLDOWN_SECS.store(seconds.max(1) as i64, Ordering::Relaxed);\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n-    loop {\n-        let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n-        let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n-        if last > 0 {\n-            let elapsed = now_ts.saturating_sub(last);\n-            if elapsed < cooldown {\n-                return Some(cooldown - elapsed);\n-            }\n-        }\n-\n-        if AUTONOMY_LAST_RUN_TS\n-            .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n-            .is_ok()\n-        {\n-            return None;\n-        }\n-    }\n+    Some(-1) /* ~ changed by cargo-mutants ~ */\n }\n \n struct BrainTickJob {\n     agent: Arc<RwLock<Arc<ButterflyBot>>>,\n     interval: Duration,\n }\n \n #[async_trait::async_trait]\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:58:5: replace try_begin_autonomy_tick -> Option<i64> with Some(-1)",
    "package": "butterfly-bot",
    "replacement": "Some(-1)",
    "span": {
      "end": {
        "column": 6,
        "line": 74
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace > with == in try_begin_autonomy_tick\n@@ -53,17 +53,17 @@\n fn set_autonomy_cooldown_seconds(seconds: u64) {\n     AUTONOMY_COOLDOWN_SECS.store(seconds.max(1) as i64, Ordering::Relaxed);\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n     loop {\n         let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n         let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n-        if last > 0 {\n+        if last == /* ~ changed by cargo-mutants ~ */ 0 {\n             let elapsed = now_ts.saturating_sub(last);\n             if elapsed < cooldown {\n                 return Some(cooldown - elapsed);\n             }\n         }\n \n         if AUTONOMY_LAST_RUN_TS\n             .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:61:17: replace > with == in try_begin_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 18,
        "line": 61
      },
      "start": {
        "column": 17,
        "line": 61
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace > with < in try_begin_autonomy_tick\n@@ -53,17 +53,17 @@\n fn set_autonomy_cooldown_seconds(seconds: u64) {\n     AUTONOMY_COOLDOWN_SECS.store(seconds.max(1) as i64, Ordering::Relaxed);\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n     loop {\n         let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n         let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n-        if last > 0 {\n+        if last < /* ~ changed by cargo-mutants ~ */ 0 {\n             let elapsed = now_ts.saturating_sub(last);\n             if elapsed < cooldown {\n                 return Some(cooldown - elapsed);\n             }\n         }\n \n         if AUTONOMY_LAST_RUN_TS\n             .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:61:17: replace > with < in try_begin_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": "<",
    "span": {
      "end": {
        "column": 18,
        "line": 61
      },
      "start": {
        "column": 17,
        "line": 61
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace > with >= in try_begin_autonomy_tick\n@@ -53,17 +53,17 @@\n fn set_autonomy_cooldown_seconds(seconds: u64) {\n     AUTONOMY_COOLDOWN_SECS.store(seconds.max(1) as i64, Ordering::Relaxed);\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n     loop {\n         let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n         let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n-        if last > 0 {\n+        if last >= /* ~ changed by cargo-mutants ~ */ 0 {\n             let elapsed = now_ts.saturating_sub(last);\n             if elapsed < cooldown {\n                 return Some(cooldown - elapsed);\n             }\n         }\n \n         if AUTONOMY_LAST_RUN_TS\n             .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:61:17: replace > with >= in try_begin_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": ">=",
    "span": {
      "end": {
        "column": 18,
        "line": 61
      },
      "start": {
        "column": 17,
        "line": 61
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace < with == in try_begin_autonomy_tick\n@@ -55,17 +55,17 @@\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n     loop {\n         let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n         let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n         if last > 0 {\n             let elapsed = now_ts.saturating_sub(last);\n-            if elapsed < cooldown {\n+            if elapsed == /* ~ changed by cargo-mutants ~ */ cooldown {\n                 return Some(cooldown - elapsed);\n             }\n         }\n \n         if AUTONOMY_LAST_RUN_TS\n             .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n             .is_ok()\n         {\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:63:24: replace < with == in try_begin_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 25,
        "line": 63
      },
      "start": {
        "column": 24,
        "line": 63
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace < with > in try_begin_autonomy_tick\n@@ -55,17 +55,17 @@\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n     loop {\n         let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n         let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n         if last > 0 {\n             let elapsed = now_ts.saturating_sub(last);\n-            if elapsed < cooldown {\n+            if elapsed > /* ~ changed by cargo-mutants ~ */ cooldown {\n                 return Some(cooldown - elapsed);\n             }\n         }\n \n         if AUTONOMY_LAST_RUN_TS\n             .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n             .is_ok()\n         {\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:63:24: replace < with > in try_begin_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": ">",
    "span": {
      "end": {
        "column": 25,
        "line": 63
      },
      "start": {
        "column": 24,
        "line": 63
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace < with <= in try_begin_autonomy_tick\n@@ -55,17 +55,17 @@\n }\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n     loop {\n         let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n         let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n         if last > 0 {\n             let elapsed = now_ts.saturating_sub(last);\n-            if elapsed < cooldown {\n+            if elapsed <= /* ~ changed by cargo-mutants ~ */ cooldown {\n                 return Some(cooldown - elapsed);\n             }\n         }\n \n         if AUTONOMY_LAST_RUN_TS\n             .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n             .is_ok()\n         {\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:63:24: replace < with <= in try_begin_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": "<=",
    "span": {
      "end": {
        "column": 25,
        "line": 63
      },
      "start": {
        "column": 24,
        "line": 63
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace - with + in try_begin_autonomy_tick\n@@ -56,17 +56,17 @@\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n     loop {\n         let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n         let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n         if last > 0 {\n             let elapsed = now_ts.saturating_sub(last);\n             if elapsed < cooldown {\n-                return Some(cooldown - elapsed);\n+                return Some(cooldown + /* ~ changed by cargo-mutants ~ */ elapsed);\n             }\n         }\n \n         if AUTONOMY_LAST_RUN_TS\n             .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n             .is_ok()\n         {\n             return None;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:64:38: replace - with + in try_begin_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": "+",
    "span": {
      "end": {
        "column": 39,
        "line": 64
      },
      "start": {
        "column": 38,
        "line": 64
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace - with / in try_begin_autonomy_tick\n@@ -56,17 +56,17 @@\n \n fn try_begin_autonomy_tick(now_ts: i64) -> Option<i64> {\n     loop {\n         let cooldown = AUTONOMY_COOLDOWN_SECS.load(Ordering::Relaxed).max(1);\n         let last = AUTONOMY_LAST_RUN_TS.load(Ordering::Relaxed);\n         if last > 0 {\n             let elapsed = now_ts.saturating_sub(last);\n             if elapsed < cooldown {\n-                return Some(cooldown - elapsed);\n+                return Some(cooldown / /* ~ changed by cargo-mutants ~ */ elapsed);\n             }\n         }\n \n         if AUTONOMY_LAST_RUN_TS\n             .compare_exchange(last, now_ts, Ordering::SeqCst, Ordering::SeqCst)\n             .is_ok()\n         {\n             return None;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "try_begin_autonomy_tick",
      "return_type": "-> Option<i64>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:64:38: replace - with / in try_begin_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": "/",
    "span": {
      "end": {
        "column": 39,
        "line": 64
      },
      "start": {
        "column": 38,
        "line": 64
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for BrainTickJob>::name -> &str with \"\"\n@@ -77,17 +77,17 @@\n struct BrainTickJob {\n     agent: Arc<RwLock<Arc<ButterflyBot>>>,\n     interval: Duration,\n }\n \n #[async_trait::async_trait]\n impl ScheduledJob for BrainTickJob {\n     fn name(&self) -> &str {\n-        \"brain_tick\"\n+        \"\" /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn interval(&self) -> Duration {\n         self.interval\n     }\n \n     async fn run(&self) -> Result<()> {\n         let agent = self.agent.read().await.clone();\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for BrainTickJob>::name",
      "return_type": "-> &str",
      "span": {
        "end": {
          "column": 6,
          "line": 86
        },
        "start": {
          "column": 5,
          "line": 84
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:85:9: replace <impl ScheduledJob for BrainTickJob>::name -> &str with \"\"",
    "package": "butterfly-bot",
    "replacement": "\"\"",
    "span": {
      "end": {
        "column": 21,
        "line": 85
      },
      "start": {
        "column": 9,
        "line": 85
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for BrainTickJob>::name -> &str with \"xyzzy\"\n@@ -77,17 +77,17 @@\n struct BrainTickJob {\n     agent: Arc<RwLock<Arc<ButterflyBot>>>,\n     interval: Duration,\n }\n \n #[async_trait::async_trait]\n impl ScheduledJob for BrainTickJob {\n     fn name(&self) -> &str {\n-        \"brain_tick\"\n+        \"xyzzy\" /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn interval(&self) -> Duration {\n         self.interval\n     }\n \n     async fn run(&self) -> Result<()> {\n         let agent = self.agent.read().await.clone();\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for BrainTickJob>::name",
      "return_type": "-> &str",
      "span": {
        "end": {
          "column": 6,
          "line": 86
        },
        "start": {
          "column": 5,
          "line": 84
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:85:9: replace <impl ScheduledJob for BrainTickJob>::name -> &str with \"xyzzy\"",
    "package": "butterfly-bot",
    "replacement": "\"xyzzy\"",
    "span": {
      "end": {
        "column": 21,
        "line": 85
      },
      "start": {
        "column": 9,
        "line": 85
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for BrainTickJob>::interval -> Duration with Default::default()\n@@ -81,17 +81,17 @@\n \n #[async_trait::async_trait]\n impl ScheduledJob for BrainTickJob {\n     fn name(&self) -> &str {\n         \"brain_tick\"\n     }\n \n     fn interval(&self) -> Duration {\n-        self.interval\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     async fn run(&self) -> Result<()> {\n         let agent = self.agent.read().await.clone();\n         agent.brain_tick().await;\n         Ok(())\n     }\n }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for BrainTickJob>::interval",
      "return_type": "-> Duration",
      "span": {
        "end": {
          "column": 6,
          "line": 90
        },
        "start": {
          "column": 5,
          "line": 88
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:89:9: replace <impl ScheduledJob for BrainTickJob>::interval -> Duration with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 22,
        "line": 89
      },
      "start": {
        "column": 9,
        "line": 89
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for BrainTickJob>::run -> Result<()> with Ok(())\n@@ -85,19 +85,17 @@\n         \"brain_tick\"\n     }\n \n     fn interval(&self) -> Duration {\n         self.interval\n     }\n \n     async fn run(&self) -> Result<()> {\n-        let agent = self.agent.read().await.clone();\n-        agent.brain_tick().await;\n-        Ok(())\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n struct WakeupJob {\n     agent: Arc<RwLock<Arc<ButterflyBot>>>,\n     store: Arc<WakeupStore>,\n     interval: Duration,\n     ui_event_tx: broadcast::Sender<UiEvent>,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for BrainTickJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 96
        },
        "start": {
          "column": 5,
          "line": 92
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:93:9: replace <impl ScheduledJob for BrainTickJob>::run -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 15,
        "line": 95
      },
      "start": {
        "column": 9,
        "line": 93
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for ScheduledTasksJob>::name -> &str with \"\"\n@@ -112,17 +112,17 @@\n     interval: Duration,\n     ui_event_tx: broadcast::Sender<UiEvent>,\n     audit_log_path: Option<String>,\n }\n \n #[async_trait::async_trait]\n impl ScheduledJob for ScheduledTasksJob {\n     fn name(&self) -> &str {\n-        \"scheduled_tasks\"\n+        \"\" /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn interval(&self) -> Duration {\n         self.interval\n     }\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for ScheduledTasksJob>::name",
      "return_type": "-> &str",
      "span": {
        "end": {
          "column": 6,
          "line": 121
        },
        "start": {
          "column": 5,
          "line": 119
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:120:9: replace <impl ScheduledJob for ScheduledTasksJob>::name -> &str with \"\"",
    "package": "butterfly-bot",
    "replacement": "\"\"",
    "span": {
      "end": {
        "column": 26,
        "line": 120
      },
      "start": {
        "column": 9,
        "line": 120
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for ScheduledTasksJob>::name -> &str with \"xyzzy\"\n@@ -112,17 +112,17 @@\n     interval: Duration,\n     ui_event_tx: broadcast::Sender<UiEvent>,\n     audit_log_path: Option<String>,\n }\n \n #[async_trait::async_trait]\n impl ScheduledJob for ScheduledTasksJob {\n     fn name(&self) -> &str {\n-        \"scheduled_tasks\"\n+        \"xyzzy\" /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn interval(&self) -> Duration {\n         self.interval\n     }\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for ScheduledTasksJob>::name",
      "return_type": "-> &str",
      "span": {
        "end": {
          "column": 6,
          "line": 121
        },
        "start": {
          "column": 5,
          "line": 119
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:120:9: replace <impl ScheduledJob for ScheduledTasksJob>::name -> &str with \"xyzzy\"",
    "package": "butterfly-bot",
    "replacement": "\"xyzzy\"",
    "span": {
      "end": {
        "column": 26,
        "line": 120
      },
      "start": {
        "column": 9,
        "line": 120
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for ScheduledTasksJob>::interval -> Duration with Default::default()\n@@ -116,17 +116,17 @@\n \n #[async_trait::async_trait]\n impl ScheduledJob for ScheduledTasksJob {\n     fn name(&self) -> &str {\n         \"scheduled_tasks\"\n     }\n \n     fn interval(&self) -> Duration {\n-        self.interval\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n         let tasks = self.store.list_due(now, 32).await?;\n         for task in tasks {\n             let agent = self.agent.read().await.clone();\n             let run_at = now_ts();\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for ScheduledTasksJob>::interval",
      "return_type": "-> Duration",
      "span": {
        "end": {
          "column": 6,
          "line": 125
        },
        "start": {
          "column": 5,
          "line": 123
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:124:9: replace <impl ScheduledJob for ScheduledTasksJob>::interval -> Duration with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 22,
        "line": 124
      },
      "start": {
        "column": 9,
        "line": 124
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for ScheduledTasksJob>::run -> Result<()> with Ok(())\n@@ -120,78 +120,17 @@\n         \"scheduled_tasks\"\n     }\n \n     fn interval(&self) -> Duration {\n         self.interval\n     }\n \n     async fn run(&self) -> Result<()> {\n-        let now = now_ts();\n-        let tasks = self.store.list_due(now, 32).await?;\n-        for task in tasks {\n-            let agent = self.agent.read().await.clone();\n-            let run_at = now_ts();\n-            let next_run_at = if let Some(interval) = task.interval_minutes {\n-                run_at + interval.max(1) * 60\n-            } else {\n-                run_at\n-            };\n-\n-            if task.interval_minutes.is_some() {\n-                let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n-            } else {\n-                let _ = self.store.complete_one_shot(task.id).await;\n-            }\n-\n-            let options = ProcessOptions {\n-                prompt: None,\n-                images: Vec::new(),\n-                output_format: OutputFormat::Text,\n-                image_detail: \"auto\".to_string(),\n-                json_schema: None,\n-            };\n-            let input = format!(\"Scheduled task '{}': {}\", task.name, task.prompt);\n-            let result = agent\n-                .process(&task.user_id, UserInput::Text(input), options)\n-                .await;\n-\n-            let (status, payload): (String, serde_json::Value) = match result {\n-                Ok(ProcessResult::Text(text)) => (\n-                    \"ok\".to_string(),\n-                    json!({\"task_id\": task.id, \"name\": task.name, \"output\": text}),\n-                ),\n-                Ok(other) => (\n-                    \"ok\".to_string(),\n-                    json!({\"task_id\": task.id, \"name\": task.name, \"output\": format!(\"{other:?}\")}),\n-                ),\n-                Err(err) => (\n-                    \"error\".to_string(),\n-                    json!({\"task_id\": task.id, \"name\": task.name, \"error\": err.to_string()}),\n-                ),\n-            };\n-\n-            let event = UiEvent {\n-                event_type: \"tasks\".to_string(),\n-                user_id: task.user_id.clone(),\n-                tool: \"tasks\".to_string(),\n-                status: status.clone(),\n-                payload: payload.clone(),\n-                timestamp: run_at,\n-            };\n-            let _ = self.ui_event_tx.send(event);\n-            let _ = write_tasks_audit_log(\n-                self.audit_log_path.as_deref(),\n-                run_at,\n-                &task,\n-                status.as_str(),\n-                payload,\n-            );\n-        }\n-        Ok(())\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n #[async_trait::async_trait]\n impl ScheduledJob for WakeupJob {\n     fn name(&self) -> &str {\n         \"wakeup\"\n     }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for ScheduledTasksJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 190
        },
        "start": {
          "column": 5,
          "line": 127
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:128:9: replace <impl ScheduledJob for ScheduledTasksJob>::run -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 15,
        "line": 189
      },
      "start": {
        "column": 9,
        "line": 128
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace + with - in <impl ScheduledJob for ScheduledTasksJob>::run\n@@ -126,17 +126,17 @@\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n         let tasks = self.store.list_due(now, 32).await?;\n         for task in tasks {\n             let agent = self.agent.read().await.clone();\n             let run_at = now_ts();\n             let next_run_at = if let Some(interval) = task.interval_minutes {\n-                run_at + interval.max(1) * 60\n+                run_at - /* ~ changed by cargo-mutants ~ */ interval.max(1) * 60\n             } else {\n                 run_at\n             };\n \n             if task.interval_minutes.is_some() {\n                 let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n             } else {\n                 let _ = self.store.complete_one_shot(task.id).await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for ScheduledTasksJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 190
        },
        "start": {
          "column": 5,
          "line": 127
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:134:24: replace + with - in <impl ScheduledJob for ScheduledTasksJob>::run",
    "package": "butterfly-bot",
    "replacement": "-",
    "span": {
      "end": {
        "column": 25,
        "line": 134
      },
      "start": {
        "column": 24,
        "line": 134
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace + with * in <impl ScheduledJob for ScheduledTasksJob>::run\n@@ -126,17 +126,17 @@\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n         let tasks = self.store.list_due(now, 32).await?;\n         for task in tasks {\n             let agent = self.agent.read().await.clone();\n             let run_at = now_ts();\n             let next_run_at = if let Some(interval) = task.interval_minutes {\n-                run_at + interval.max(1) * 60\n+                run_at * /* ~ changed by cargo-mutants ~ */ interval.max(1) * 60\n             } else {\n                 run_at\n             };\n \n             if task.interval_minutes.is_some() {\n                 let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n             } else {\n                 let _ = self.store.complete_one_shot(task.id).await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for ScheduledTasksJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 190
        },
        "start": {
          "column": 5,
          "line": 127
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:134:24: replace + with * in <impl ScheduledJob for ScheduledTasksJob>::run",
    "package": "butterfly-bot",
    "replacement": "*",
    "span": {
      "end": {
        "column": 25,
        "line": 134
      },
      "start": {
        "column": 24,
        "line": 134
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace * with + in <impl ScheduledJob for ScheduledTasksJob>::run\n@@ -126,17 +126,17 @@\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n         let tasks = self.store.list_due(now, 32).await?;\n         for task in tasks {\n             let agent = self.agent.read().await.clone();\n             let run_at = now_ts();\n             let next_run_at = if let Some(interval) = task.interval_minutes {\n-                run_at + interval.max(1) * 60\n+                run_at + interval.max(1) + /* ~ changed by cargo-mutants ~ */ 60\n             } else {\n                 run_at\n             };\n \n             if task.interval_minutes.is_some() {\n                 let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n             } else {\n                 let _ = self.store.complete_one_shot(task.id).await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for ScheduledTasksJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 190
        },
        "start": {
          "column": 5,
          "line": 127
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:134:42: replace * with + in <impl ScheduledJob for ScheduledTasksJob>::run",
    "package": "butterfly-bot",
    "replacement": "+",
    "span": {
      "end": {
        "column": 43,
        "line": 134
      },
      "start": {
        "column": 42,
        "line": 134
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace * with / in <impl ScheduledJob for ScheduledTasksJob>::run\n@@ -126,17 +126,17 @@\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n         let tasks = self.store.list_due(now, 32).await?;\n         for task in tasks {\n             let agent = self.agent.read().await.clone();\n             let run_at = now_ts();\n             let next_run_at = if let Some(interval) = task.interval_minutes {\n-                run_at + interval.max(1) * 60\n+                run_at + interval.max(1) / /* ~ changed by cargo-mutants ~ */ 60\n             } else {\n                 run_at\n             };\n \n             if task.interval_minutes.is_some() {\n                 let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n             } else {\n                 let _ = self.store.complete_one_shot(task.id).await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for ScheduledTasksJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 190
        },
        "start": {
          "column": 5,
          "line": 127
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:134:42: replace * with / in <impl ScheduledJob for ScheduledTasksJob>::run",
    "package": "butterfly-bot",
    "replacement": "/",
    "span": {
      "end": {
        "column": 43,
        "line": 134
      },
      "start": {
        "column": 42,
        "line": 134
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for WakeupJob>::name -> &str with \"\"\n@@ -188,17 +188,17 @@\n         }\n         Ok(())\n     }\n }\n \n #[async_trait::async_trait]\n impl ScheduledJob for WakeupJob {\n     fn name(&self) -> &str {\n-        \"wakeup\"\n+        \"\" /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn interval(&self) -> Duration {\n         self.interval\n     }\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::name",
      "return_type": "-> &str",
      "span": {
        "end": {
          "column": 6,
          "line": 197
        },
        "start": {
          "column": 5,
          "line": 195
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:196:9: replace <impl ScheduledJob for WakeupJob>::name -> &str with \"\"",
    "package": "butterfly-bot",
    "replacement": "\"\"",
    "span": {
      "end": {
        "column": 17,
        "line": 196
      },
      "start": {
        "column": 9,
        "line": 196
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for WakeupJob>::name -> &str with \"xyzzy\"\n@@ -188,17 +188,17 @@\n         }\n         Ok(())\n     }\n }\n \n #[async_trait::async_trait]\n impl ScheduledJob for WakeupJob {\n     fn name(&self) -> &str {\n-        \"wakeup\"\n+        \"xyzzy\" /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn interval(&self) -> Duration {\n         self.interval\n     }\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::name",
      "return_type": "-> &str",
      "span": {
        "end": {
          "column": 6,
          "line": 197
        },
        "start": {
          "column": 5,
          "line": 195
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:196:9: replace <impl ScheduledJob for WakeupJob>::name -> &str with \"xyzzy\"",
    "package": "butterfly-bot",
    "replacement": "\"xyzzy\"",
    "span": {
      "end": {
        "column": 17,
        "line": 196
      },
      "start": {
        "column": 9,
        "line": 196
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for WakeupJob>::interval -> Duration with Default::default()\n@@ -192,17 +192,17 @@\n \n #[async_trait::async_trait]\n impl ScheduledJob for WakeupJob {\n     fn name(&self) -> &str {\n         \"wakeup\"\n     }\n \n     fn interval(&self) -> Duration {\n-        self.interval\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     async fn run(&self) -> Result<()> {\n         let now = now_ts();\n         let dynamic_source = Config::from_store(&self.db_path)\n             .ok()\n             .map(|cfg| cfg.heartbeat_source)\n             .unwrap_or_else(|| self.heartbeat_source.clone());\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::interval",
      "return_type": "-> Duration",
      "span": {
        "end": {
          "column": 6,
          "line": 201
        },
        "start": {
          "column": 5,
          "line": 199
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:200:9: replace <impl ScheduledJob for WakeupJob>::interval -> Duration with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 22,
        "line": 200
      },
      "start": {
        "column": 9,
        "line": 200
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace <impl ScheduledJob for WakeupJob>::run -> Result<()> with Ok(())\n@@ -196,160 +196,17 @@\n         \"wakeup\"\n     }\n \n     fn interval(&self) -> Duration {\n         self.interval\n     }\n \n     async fn run(&self) -> Result<()> {\n-        let now = now_ts();\n-        let dynamic_source = Config::from_store(&self.db_path)\n-            .ok()\n-            .map(|cfg| cfg.heartbeat_source)\n-            .unwrap_or_else(|| self.heartbeat_source.clone());\n-        let prompt_source = Config::from_store(&self.db_path)\n-            .ok()\n-            .map(|cfg| cfg.prompt_source);\n-\n-        match load_markdown_content(&dynamic_source).await {\n-            Ok(markdown) => {\n-                let agent = self.agent.read().await.clone();\n-                agent.set_heartbeat_markdown(markdown.clone()).await;\n-                let status = if markdown\n-                    .as_ref()\n-                    .map(|m| !m.trim().is_empty())\n-                    .unwrap_or(false)\n-                {\n-                    \"ok\"\n-                } else {\n-                    \"empty\"\n-                };\n-                let event = UiEvent {\n-                    event_type: \"wakeup\".to_string(),\n-                    user_id: \"system\".to_string(),\n-                    tool: \"heartbeat\".to_string(),\n-                    status: status.to_string(),\n-                    payload: json!({\"source\": dynamic_source}),\n-                    timestamp: now_ts(),\n-                };\n-                let _ = self.ui_event_tx.send(event);\n-            }\n-            Err(err) => {\n-                let event = UiEvent {\n-                    event_type: \"wakeup\".to_string(),\n-                    user_id: \"system\".to_string(),\n-                    tool: \"heartbeat\".to_string(),\n-                    status: \"error\".to_string(),\n-                    payload: json!({\"source\": dynamic_source, \"error\": err.to_string()}),\n-                    timestamp: now_ts(),\n-                };\n-                let _ = self.ui_event_tx.send(event);\n-            }\n-        }\n-\n-        if let Some(source) = &prompt_source {\n-            match load_markdown_content(source).await {\n-                Ok(markdown) => {\n-                    let agent = self.agent.read().await.clone();\n-                    agent.set_prompt_markdown(markdown.clone()).await;\n-                    let status = if markdown\n-                        .as_ref()\n-                        .map(|m| !m.trim().is_empty())\n-                        .unwrap_or(false)\n-                    {\n-                        \"ok\"\n-                    } else {\n-                        \"empty\"\n-                    };\n-                    let event = UiEvent {\n-                        event_type: \"wakeup\".to_string(),\n-                        user_id: \"system\".to_string(),\n-                        tool: \"prompt\".to_string(),\n-                        status: status.to_string(),\n-                        payload: json!({\"source\": source}),\n-                        timestamp: now_ts(),\n-                    };\n-                    let _ = self.ui_event_tx.send(event);\n-                }\n-                Err(err) => {\n-                    let event = UiEvent {\n-                        event_type: \"wakeup\".to_string(),\n-                        user_id: \"system\".to_string(),\n-                        tool: \"prompt\".to_string(),\n-                        status: \"error\".to_string(),\n-                        payload: json!({\"source\": source, \"error\": err.to_string()}),\n-                        timestamp: now_ts(),\n-                    };\n-                    let _ = self.ui_event_tx.send(event);\n-                }\n-            }\n-        }\n-\n-        // Autonomous heartbeat processing\n-        {\n-            let agent = self.agent.read().await.clone();\n-            let ui_event_tx = self.ui_event_tx.clone();\n-            tokio::spawn(async move {\n-                run_autonomy_tick(agent, ui_event_tx, \"system\".to_string(), \"wakeup\").await;\n-            });\n-        }\n-\n-        let tasks = self.store.list_due(now, 32).await?;\n-        for task in tasks {\n-            let agent = self.agent.read().await.clone();\n-            let run_at = now_ts();\n-            let next_run_at = run_at + task.interval_minutes.max(1) * 60;\n-            let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n-\n-            let options = ProcessOptions {\n-                prompt: None,\n-                images: Vec::new(),\n-                output_format: OutputFormat::Text,\n-                image_detail: \"auto\".to_string(),\n-                json_schema: None,\n-            };\n-            let input = format!(\"Wakeup task '{}': {}\", task.name, task.prompt);\n-            let result = agent\n-                .process(&task.user_id, UserInput::Text(input), options)\n-                .await;\n-\n-            let (status, payload): (String, Value) = match result {\n-                Ok(ProcessResult::Text(text)) => (\n-                    \"ok\".to_string(),\n-                    json!({\"task_id\": task.id, \"name\": task.name, \"output\": text}),\n-                ),\n-                Ok(other) => (\n-                    \"ok\".to_string(),\n-                    json!({\"task_id\": task.id, \"name\": task.name, \"output\": format!(\"{other:?}\")}),\n-                ),\n-                Err(err) => (\n-                    \"error\".to_string(),\n-                    json!({\"task_id\": task.id, \"name\": task.name, \"error\": err.to_string()}),\n-                ),\n-            };\n-\n-            let event = UiEvent {\n-                event_type: \"wakeup\".to_string(),\n-                user_id: task.user_id.clone(),\n-                tool: \"wakeup\".to_string(),\n-                status: status.clone(),\n-                payload: payload.clone(),\n-                timestamp: run_at,\n-            };\n-            let _ = self.ui_event_tx.send(event);\n-            let _ = write_wakeup_audit_log(\n-                self.audit_log_path.as_deref(),\n-                run_at,\n-                &task,\n-                status.as_str(),\n-                payload.clone(),\n-            );\n-        }\n-        Ok(())\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n #[derive(Serialize)]\n struct HealthResponse {\n     status: String,\n }\n \n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 348
        },
        "start": {
          "column": 5,
          "line": 203
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:204:9: replace <impl ScheduledJob for WakeupJob>::run -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 15,
        "line": 347
      },
      "start": {
        "column": 9,
        "line": 204
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in <impl ScheduledJob for WakeupJob>::run\n@@ -211,17 +211,17 @@\n             .map(|cfg| cfg.prompt_source);\n \n         match load_markdown_content(&dynamic_source).await {\n             Ok(markdown) => {\n                 let agent = self.agent.read().await.clone();\n                 agent.set_heartbeat_markdown(markdown.clone()).await;\n                 let status = if markdown\n                     .as_ref()\n-                    .map(|m| !m.trim().is_empty())\n+                    .map(|m|  /* ~ changed by cargo-mutants ~ */m.trim().is_empty())\n                     .unwrap_or(false)\n                 {\n                     \"ok\"\n                 } else {\n                     \"empty\"\n                 };\n                 let event = UiEvent {\n                     event_type: \"wakeup\".to_string(),\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 348
        },
        "start": {
          "column": 5,
          "line": 203
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:219:30: delete ! in <impl ScheduledJob for WakeupJob>::run",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 31,
        "line": 219
      },
      "start": {
        "column": 30,
        "line": 219
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in <impl ScheduledJob for WakeupJob>::run\n@@ -248,17 +248,17 @@\n \n         if let Some(source) = &prompt_source {\n             match load_markdown_content(source).await {\n                 Ok(markdown) => {\n                     let agent = self.agent.read().await.clone();\n                     agent.set_prompt_markdown(markdown.clone()).await;\n                     let status = if markdown\n                         .as_ref()\n-                        .map(|m| !m.trim().is_empty())\n+                        .map(|m|  /* ~ changed by cargo-mutants ~ */m.trim().is_empty())\n                         .unwrap_or(false)\n                     {\n                         \"ok\"\n                     } else {\n                         \"empty\"\n                     };\n                     let event = UiEvent {\n                         event_type: \"wakeup\".to_string(),\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 348
        },
        "start": {
          "column": 5,
          "line": 203
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:256:34: delete ! in <impl ScheduledJob for WakeupJob>::run",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 35,
        "line": 256
      },
      "start": {
        "column": 34,
        "line": 256
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace + with - in <impl ScheduledJob for WakeupJob>::run\n@@ -292,17 +292,17 @@\n                 run_autonomy_tick(agent, ui_event_tx, \"system\".to_string(), \"wakeup\").await;\n             });\n         }\n \n         let tasks = self.store.list_due(now, 32).await?;\n         for task in tasks {\n             let agent = self.agent.read().await.clone();\n             let run_at = now_ts();\n-            let next_run_at = run_at + task.interval_minutes.max(1) * 60;\n+            let next_run_at = run_at - /* ~ changed by cargo-mutants ~ */ task.interval_minutes.max(1) * 60;\n             let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n \n             let options = ProcessOptions {\n                 prompt: None,\n                 images: Vec::new(),\n                 output_format: OutputFormat::Text,\n                 image_detail: \"auto\".to_string(),\n                 json_schema: None,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 348
        },
        "start": {
          "column": 5,
          "line": 203
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:300:38: replace + with - in <impl ScheduledJob for WakeupJob>::run",
    "package": "butterfly-bot",
    "replacement": "-",
    "span": {
      "end": {
        "column": 39,
        "line": 300
      },
      "start": {
        "column": 38,
        "line": 300
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace + with * in <impl ScheduledJob for WakeupJob>::run\n@@ -292,17 +292,17 @@\n                 run_autonomy_tick(agent, ui_event_tx, \"system\".to_string(), \"wakeup\").await;\n             });\n         }\n \n         let tasks = self.store.list_due(now, 32).await?;\n         for task in tasks {\n             let agent = self.agent.read().await.clone();\n             let run_at = now_ts();\n-            let next_run_at = run_at + task.interval_minutes.max(1) * 60;\n+            let next_run_at = run_at * /* ~ changed by cargo-mutants ~ */ task.interval_minutes.max(1) * 60;\n             let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n \n             let options = ProcessOptions {\n                 prompt: None,\n                 images: Vec::new(),\n                 output_format: OutputFormat::Text,\n                 image_detail: \"auto\".to_string(),\n                 json_schema: None,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 348
        },
        "start": {
          "column": 5,
          "line": 203
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:300:38: replace + with * in <impl ScheduledJob for WakeupJob>::run",
    "package": "butterfly-bot",
    "replacement": "*",
    "span": {
      "end": {
        "column": 39,
        "line": 300
      },
      "start": {
        "column": 38,
        "line": 300
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace * with + in <impl ScheduledJob for WakeupJob>::run\n@@ -292,17 +292,17 @@\n                 run_autonomy_tick(agent, ui_event_tx, \"system\".to_string(), \"wakeup\").await;\n             });\n         }\n \n         let tasks = self.store.list_due(now, 32).await?;\n         for task in tasks {\n             let agent = self.agent.read().await.clone();\n             let run_at = now_ts();\n-            let next_run_at = run_at + task.interval_minutes.max(1) * 60;\n+            let next_run_at = run_at + task.interval_minutes.max(1) + /* ~ changed by cargo-mutants ~ */ 60;\n             let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n \n             let options = ProcessOptions {\n                 prompt: None,\n                 images: Vec::new(),\n                 output_format: OutputFormat::Text,\n                 image_detail: \"auto\".to_string(),\n                 json_schema: None,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 348
        },
        "start": {
          "column": 5,
          "line": 203
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:300:69: replace * with + in <impl ScheduledJob for WakeupJob>::run",
    "package": "butterfly-bot",
    "replacement": "+",
    "span": {
      "end": {
        "column": 70,
        "line": 300
      },
      "start": {
        "column": 69,
        "line": 300
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace * with / in <impl ScheduledJob for WakeupJob>::run\n@@ -292,17 +292,17 @@\n                 run_autonomy_tick(agent, ui_event_tx, \"system\".to_string(), \"wakeup\").await;\n             });\n         }\n \n         let tasks = self.store.list_due(now, 32).await?;\n         for task in tasks {\n             let agent = self.agent.read().await.clone();\n             let run_at = now_ts();\n-            let next_run_at = run_at + task.interval_minutes.max(1) * 60;\n+            let next_run_at = run_at + task.interval_minutes.max(1) / /* ~ changed by cargo-mutants ~ */ 60;\n             let _ = self.store.mark_run(task.id, run_at, next_run_at).await;\n \n             let options = ProcessOptions {\n                 prompt: None,\n                 images: Vec::new(),\n                 output_format: OutputFormat::Text,\n                 image_detail: \"auto\".to_string(),\n                 json_schema: None,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "<impl ScheduledJob for WakeupJob>::run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 348
        },
        "start": {
          "column": 5,
          "line": 203
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:300:69: replace * with / in <impl ScheduledJob for WakeupJob>::run",
    "package": "butterfly-bot",
    "replacement": "/",
    "span": {
      "end": {
        "column": 70,
        "line": 300
      },
      "start": {
        "column": 69,
        "line": 300
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace build_router -> Router with Default::default()\n@@ -463,35 +463,17 @@\n #[derive(Serialize)]\n struct FactoryResetConfigResponse {\n     status: String,\n     message: String,\n     config: Value,\n }\n \n pub fn build_router(state: AppState) -> Router {\n-    Router::new()\n-        .route(\"/health\", get(health))\n-        .route(\"/doctor\", post(doctor))\n-        .route(\"/security_audit\", post(security_audit))\n-        .route(\"/process_text\", post(process_text))\n-        .route(\"/process_text_stream\", post(process_text_stream))\n-        .route(\"/chat_history\", get(chat_history))\n-        .route(\"/clear_user_history\", post(clear_user_history))\n-        .route(\"/memory_search\", post(memory_search))\n-        .route(\"/preload_boot\", post(preload_boot))\n-        .route(\"/reminder_stream\", get(reminder_stream))\n-        .route(\"/ui_events\", get(ui_events))\n-        .route(\"/factory_reset_config\", post(factory_reset_config))\n-        .route(\"/reload_config\", post(reload_config))\n-        .route(\"/signer/preview\", post(signer_preview))\n-        .route(\"/signer/approve\", post(signer_approve))\n-        .route(\"/signer/sign\", post(signer_sign))\n-        .route(\"/signer/deny\", post(signer_deny))\n-        .with_state(state)\n+    Default::default() /* ~ changed by cargo-mutants ~ */\n }\n \n async fn signer_preview(\n     State(state): State<AppState>,\n     headers: HeaderMap,\n     Json(intent): Json<SigningIntent>,\n ) -> impl IntoResponse {\n     if let Err(err) = authorize(&headers, &state.token) {\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "build_router",
      "return_type": "-> Router",
      "span": {
        "end": {
          "column": 2,
          "line": 490
        },
        "start": {
          "column": 1,
          "line": 470
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:471:5: replace build_router -> Router with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 27,
        "line": 489
      },
      "start": {
        "column": 5,
        "line": 471
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace health -> Json<HealthResponse> with Json::new()\n@@ -578,19 +578,17 @@\n                 error: err.to_string(),\n             }),\n         )\n             .into_response(),\n     }\n }\n \n async fn health() -> Json<HealthResponse> {\n-    Json(HealthResponse {\n-        status: \"ok\".to_string(),\n-    })\n+    Json::new() /* ~ changed by cargo-mutants ~ */\n }\n \n async fn doctor(State(state): State<AppState>, headers: HeaderMap) -> impl IntoResponse {\n     if let Err(err) = authorize(&headers, &state.token) {\n         return err.into_response();\n     }\n \n     let checks = run_doctor_checks(&state).await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "health",
      "return_type": "-> Json<HealthResponse>",
      "span": {
        "end": {
          "column": 2,
          "line": 589
        },
        "start": {
          "column": 1,
          "line": 585
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:586:5: replace health -> Json<HealthResponse> with Json::new()",
    "package": "butterfly-bot",
    "replacement": "Json::new()",
    "span": {
      "end": {
        "column": 7,
        "line": 588
      },
      "start": {
        "column": 5,
        "line": 586
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace health -> Json<HealthResponse> with Json::from_iter([Default::default()])\n@@ -578,19 +578,17 @@\n                 error: err.to_string(),\n             }),\n         )\n             .into_response(),\n     }\n }\n \n async fn health() -> Json<HealthResponse> {\n-    Json(HealthResponse {\n-        status: \"ok\".to_string(),\n-    })\n+    Json::from_iter([Default::default()]) /* ~ changed by cargo-mutants ~ */\n }\n \n async fn doctor(State(state): State<AppState>, headers: HeaderMap) -> impl IntoResponse {\n     if let Err(err) = authorize(&headers, &state.token) {\n         return err.into_response();\n     }\n \n     let checks = run_doctor_checks(&state).await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "health",
      "return_type": "-> Json<HealthResponse>",
      "span": {
        "end": {
          "column": 2,
          "line": 589
        },
        "start": {
          "column": 1,
          "line": 585
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:586:5: replace health -> Json<HealthResponse> with Json::from_iter([Default::default()])",
    "package": "butterfly-bot",
    "replacement": "Json::from_iter([Default::default()])",
    "span": {
      "end": {
        "column": 7,
        "line": 588
      },
      "start": {
        "column": 5,
        "line": 586
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace health -> Json<HealthResponse> with Json::new(Default::default())\n@@ -578,19 +578,17 @@\n                 error: err.to_string(),\n             }),\n         )\n             .into_response(),\n     }\n }\n \n async fn health() -> Json<HealthResponse> {\n-    Json(HealthResponse {\n-        status: \"ok\".to_string(),\n-    })\n+    Json::new(Default::default()) /* ~ changed by cargo-mutants ~ */\n }\n \n async fn doctor(State(state): State<AppState>, headers: HeaderMap) -> impl IntoResponse {\n     if let Err(err) = authorize(&headers, &state.token) {\n         return err.into_response();\n     }\n \n     let checks = run_doctor_checks(&state).await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "health",
      "return_type": "-> Json<HealthResponse>",
      "span": {
        "end": {
          "column": 2,
          "line": 589
        },
        "start": {
          "column": 1,
          "line": 585
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:586:5: replace health -> Json<HealthResponse> with Json::new(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Json::new(Default::default())",
    "span": {
      "end": {
        "column": 7,
        "line": 588
      },
      "start": {
        "column": 5,
        "line": 586
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace health -> Json<HealthResponse> with Json::from(Default::default())\n@@ -578,19 +578,17 @@\n                 error: err.to_string(),\n             }),\n         )\n             .into_response(),\n     }\n }\n \n async fn health() -> Json<HealthResponse> {\n-    Json(HealthResponse {\n-        status: \"ok\".to_string(),\n-    })\n+    Json::from(Default::default()) /* ~ changed by cargo-mutants ~ */\n }\n \n async fn doctor(State(state): State<AppState>, headers: HeaderMap) -> impl IntoResponse {\n     if let Err(err) = authorize(&headers, &state.token) {\n         return err.into_response();\n     }\n \n     let checks = run_doctor_checks(&state).await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "health",
      "return_type": "-> Json<HealthResponse>",
      "span": {
        "end": {
          "column": 2,
          "line": 589
        },
        "start": {
          "column": 1,
          "line": 585
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:586:5: replace health -> Json<HealthResponse> with Json::from(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Json::from(Default::default())",
    "span": {
      "end": {
        "column": 7,
        "line": 588
      },
      "start": {
        "column": 5,
        "line": 586
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in doctor\n@@ -589,17 +589,17 @@\n }\n \n async fn doctor(State(state): State<AppState>, headers: HeaderMap) -> impl IntoResponse {\n     if let Err(err) = authorize(&headers, &state.token) {\n         return err.into_response();\n     }\n \n     let checks = run_doctor_checks(&state).await;\n-    let has_fail = checks.iter().any(|check| check.status == \"fail\");\n+    let has_fail = checks.iter().any(|check| check.status != /* ~ changed by cargo-mutants ~ */ \"fail\");\n     let has_warn = checks.iter().any(|check| check.status == \"warn\");\n     let overall = if has_fail {\n         \"fail\"\n     } else if has_warn {\n         \"warn\"\n     } else {\n         \"pass\"\n     };\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "doctor",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 615
        },
        "start": {
          "column": 1,
          "line": 591
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:597:59: replace == with != in doctor",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 61,
        "line": 597
      },
      "start": {
        "column": 59,
        "line": 597
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in doctor\n@@ -590,17 +590,17 @@\n \n async fn doctor(State(state): State<AppState>, headers: HeaderMap) -> impl IntoResponse {\n     if let Err(err) = authorize(&headers, &state.token) {\n         return err.into_response();\n     }\n \n     let checks = run_doctor_checks(&state).await;\n     let has_fail = checks.iter().any(|check| check.status == \"fail\");\n-    let has_warn = checks.iter().any(|check| check.status == \"warn\");\n+    let has_warn = checks.iter().any(|check| check.status != /* ~ changed by cargo-mutants ~ */ \"warn\");\n     let overall = if has_fail {\n         \"fail\"\n     } else if has_warn {\n         \"warn\"\n     } else {\n         \"pass\"\n     };\n \n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "doctor",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 615
        },
        "start": {
          "column": 1,
          "line": 591
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:598:59: replace == with != in doctor",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 61,
        "line": 598
      },
      "start": {
        "column": 59,
        "line": 598
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace doctor_check -> DoctorCheck with Default::default()\n@@ -625,22 +625,17 @@\n     (\n         StatusCode::OK,\n         Json(SecurityAuditResponse { overall, findings }),\n     )\n         .into_response()\n }\n \n fn doctor_check(name: &str, status: &str, message: String, fix_hint: Option<&str>) -> DoctorCheck {\n-    DoctorCheck {\n-        name: name.to_string(),\n-        status: status.to_string(),\n-        message,\n-        fix_hint: fix_hint.map(str::to_string),\n-    }\n+    Default::default() /* ~ changed by cargo-mutants ~ */\n }\n \n fn security_finding(\n     id: &str,\n     severity: &str,\n     status: &str,\n     message: String,\n     fix_hint: Option<&str>,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "doctor_check",
      "return_type": "-> DoctorCheck",
      "span": {
        "end": {
          "column": 2,
          "line": 639
        },
        "start": {
          "column": 1,
          "line": 632
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:633:5: replace doctor_check -> DoctorCheck with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 6,
        "line": 638
      },
      "start": {
        "column": 5,
        "line": 633
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace security_finding -> SecurityAuditFinding with Default::default()\n@@ -641,24 +641,17 @@\n fn security_finding(\n     id: &str,\n     severity: &str,\n     status: &str,\n     message: String,\n     fix_hint: Option<&str>,\n     auto_fixable: bool,\n ) -> SecurityAuditFinding {\n-    SecurityAuditFinding {\n-        id: id.to_string(),\n-        severity: severity.to_string(),\n-        status: status.to_string(),\n-        message,\n-        fix_hint: fix_hint.map(str::to_string),\n-        auto_fixable,\n-    }\n+    Default::default() /* ~ changed by cargo-mutants ~ */\n }\n \n fn severity_rank(severity: &str) -> u8 {\n     match severity {\n         \"critical\" => 4,\n         \"high\" => 3,\n         \"medium\" => 2,\n         _ => 1,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "security_finding",
      "return_type": "-> SecurityAuditFinding",
      "span": {
        "end": {
          "column": 2,
          "line": 657
        },
        "start": {
          "column": 1,
          "line": 641
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:649:5: replace security_finding -> SecurityAuditFinding with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 6,
        "line": 656
      },
      "start": {
        "column": 5,
        "line": 649
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace severity_rank -> u8 with 0\n@@ -652,22 +652,17 @@\n         status: status.to_string(),\n         message,\n         fix_hint: fix_hint.map(str::to_string),\n         auto_fixable,\n     }\n }\n \n fn severity_rank(severity: &str) -> u8 {\n-    match severity {\n-        \"critical\" => 4,\n-        \"high\" => 3,\n-        \"medium\" => 2,\n-        _ => 1,\n-    }\n+    0 /* ~ changed by cargo-mutants ~ */\n }\n \n fn highest_severity(findings: &[SecurityAuditFinding]) -> String {\n     findings\n         .iter()\n         .filter(|finding| finding.status != \"pass\")\n         .max_by_key(|finding| severity_rank(&finding.severity))\n         .map(|finding| finding.severity.clone())\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "severity_rank",
      "return_type": "-> u8",
      "span": {
        "end": {
          "column": 2,
          "line": 666
        },
        "start": {
          "column": 1,
          "line": 659
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:660:5: replace severity_rank -> u8 with 0",
    "package": "butterfly-bot",
    "replacement": "0",
    "span": {
      "end": {
        "column": 6,
        "line": 665
      },
      "start": {
        "column": 5,
        "line": 660
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace severity_rank -> u8 with 1\n@@ -652,22 +652,17 @@\n         status: status.to_string(),\n         message,\n         fix_hint: fix_hint.map(str::to_string),\n         auto_fixable,\n     }\n }\n \n fn severity_rank(severity: &str) -> u8 {\n-    match severity {\n-        \"critical\" => 4,\n-        \"high\" => 3,\n-        \"medium\" => 2,\n-        _ => 1,\n-    }\n+    1 /* ~ changed by cargo-mutants ~ */\n }\n \n fn highest_severity(findings: &[SecurityAuditFinding]) -> String {\n     findings\n         .iter()\n         .filter(|finding| finding.status != \"pass\")\n         .max_by_key(|finding| severity_rank(&finding.severity))\n         .map(|finding| finding.severity.clone())\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "severity_rank",
      "return_type": "-> u8",
      "span": {
        "end": {
          "column": 2,
          "line": 666
        },
        "start": {
          "column": 1,
          "line": 659
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:660:5: replace severity_rank -> u8 with 1",
    "package": "butterfly-bot",
    "replacement": "1",
    "span": {
      "end": {
        "column": 6,
        "line": 665
      },
      "start": {
        "column": 5,
        "line": 660
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete match arm \"critical\" in severity_rank\n@@ -653,17 +653,17 @@\n         message,\n         fix_hint: fix_hint.map(str::to_string),\n         auto_fixable,\n     }\n }\n \n fn severity_rank(severity: &str) -> u8 {\n     match severity {\n-        \"critical\" => 4,\n+         /* ~ changed by cargo-mutants ~ */\n         \"high\" => 3,\n         \"medium\" => 2,\n         _ => 1,\n     }\n }\n \n fn highest_severity(findings: &[SecurityAuditFinding]) -> String {\n     findings\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "severity_rank",
      "return_type": "-> u8",
      "span": {
        "end": {
          "column": 2,
          "line": 666
        },
        "start": {
          "column": 1,
          "line": 659
        }
      }
    },
    "genre": "MatchArm",
    "name": "src/daemon.rs:661:9: delete match arm \"critical\" in severity_rank",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 25,
        "line": 661
      },
      "start": {
        "column": 9,
        "line": 661
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete match arm \"high\" in severity_rank\n@@ -654,17 +654,17 @@\n         fix_hint: fix_hint.map(str::to_string),\n         auto_fixable,\n     }\n }\n \n fn severity_rank(severity: &str) -> u8 {\n     match severity {\n         \"critical\" => 4,\n-        \"high\" => 3,\n+         /* ~ changed by cargo-mutants ~ */\n         \"medium\" => 2,\n         _ => 1,\n     }\n }\n \n fn highest_severity(findings: &[SecurityAuditFinding]) -> String {\n     findings\n         .iter()\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "severity_rank",
      "return_type": "-> u8",
      "span": {
        "end": {
          "column": 2,
          "line": 666
        },
        "start": {
          "column": 1,
          "line": 659
        }
      }
    },
    "genre": "MatchArm",
    "name": "src/daemon.rs:662:9: delete match arm \"high\" in severity_rank",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 21,
        "line": 662
      },
      "start": {
        "column": 9,
        "line": 662
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete match arm \"medium\" in severity_rank\n@@ -655,17 +655,17 @@\n         auto_fixable,\n     }\n }\n \n fn severity_rank(severity: &str) -> u8 {\n     match severity {\n         \"critical\" => 4,\n         \"high\" => 3,\n-        \"medium\" => 2,\n+         /* ~ changed by cargo-mutants ~ */\n         _ => 1,\n     }\n }\n \n fn highest_severity(findings: &[SecurityAuditFinding]) -> String {\n     findings\n         .iter()\n         .filter(|finding| finding.status != \"pass\")\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "severity_rank",
      "return_type": "-> u8",
      "span": {
        "end": {
          "column": 2,
          "line": 666
        },
        "start": {
          "column": 1,
          "line": 659
        }
      }
    },
    "genre": "MatchArm",
    "name": "src/daemon.rs:663:9: delete match arm \"medium\" in severity_rank",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 23,
        "line": 663
      },
      "start": {
        "column": 9,
        "line": 663
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace highest_severity -> String with String::new()\n@@ -661,22 +661,17 @@\n         \"critical\" => 4,\n         \"high\" => 3,\n         \"medium\" => 2,\n         _ => 1,\n     }\n }\n \n fn highest_severity(findings: &[SecurityAuditFinding]) -> String {\n-    findings\n-        .iter()\n-        .filter(|finding| finding.status != \"pass\")\n-        .max_by_key(|finding| severity_rank(&finding.severity))\n-        .map(|finding| finding.severity.clone())\n-        .unwrap_or_else(|| \"low\".to_string())\n+    String::new() /* ~ changed by cargo-mutants ~ */\n }\n \n async fn run_security_audit_checks(state: &AppState) -> Vec<SecurityAuditFinding> {\n     let mut findings = Vec::new();\n \n     if state.token.trim().is_empty() {\n         findings.push(security_finding(\n             \"daemon_auth_token\",\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "highest_severity",
      "return_type": "-> String",
      "span": {
        "end": {
          "column": 2,
          "line": 675
        },
        "start": {
          "column": 1,
          "line": 668
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:669:5: replace highest_severity -> String with String::new()",
    "package": "butterfly-bot",
    "replacement": "String::new()",
    "span": {
      "end": {
        "column": 46,
        "line": 674
      },
      "start": {
        "column": 5,
        "line": 669
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace highest_severity -> String with \"xyzzy\".into()\n@@ -661,22 +661,17 @@\n         \"critical\" => 4,\n         \"high\" => 3,\n         \"medium\" => 2,\n         _ => 1,\n     }\n }\n \n fn highest_severity(findings: &[SecurityAuditFinding]) -> String {\n-    findings\n-        .iter()\n-        .filter(|finding| finding.status != \"pass\")\n-        .max_by_key(|finding| severity_rank(&finding.severity))\n-        .map(|finding| finding.severity.clone())\n-        .unwrap_or_else(|| \"low\".to_string())\n+    \"xyzzy\".into() /* ~ changed by cargo-mutants ~ */\n }\n \n async fn run_security_audit_checks(state: &AppState) -> Vec<SecurityAuditFinding> {\n     let mut findings = Vec::new();\n \n     if state.token.trim().is_empty() {\n         findings.push(security_finding(\n             \"daemon_auth_token\",\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "highest_severity",
      "return_type": "-> String",
      "span": {
        "end": {
          "column": 2,
          "line": 675
        },
        "start": {
          "column": 1,
          "line": 668
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:669:5: replace highest_severity -> String with \"xyzzy\".into()",
    "package": "butterfly-bot",
    "replacement": "\"xyzzy\".into()",
    "span": {
      "end": {
        "column": 46,
        "line": 674
      },
      "start": {
        "column": 5,
        "line": 669
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace != with == in highest_severity\n@@ -663,17 +663,17 @@\n         \"medium\" => 2,\n         _ => 1,\n     }\n }\n \n fn highest_severity(findings: &[SecurityAuditFinding]) -> String {\n     findings\n         .iter()\n-        .filter(|finding| finding.status != \"pass\")\n+        .filter(|finding| finding.status == /* ~ changed by cargo-mutants ~ */ \"pass\")\n         .max_by_key(|finding| severity_rank(&finding.severity))\n         .map(|finding| finding.severity.clone())\n         .unwrap_or_else(|| \"low\".to_string())\n }\n \n async fn run_security_audit_checks(state: &AppState) -> Vec<SecurityAuditFinding> {\n     let mut findings = Vec::new();\n \n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "highest_severity",
      "return_type": "-> String",
      "span": {
        "end": {
          "column": 2,
          "line": 675
        },
        "start": {
          "column": 1,
          "line": 668
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:671:42: replace != with == in highest_severity",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 44,
        "line": 671
      },
      "start": {
        "column": 42,
        "line": 671
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace run_security_audit_checks -> Vec<SecurityAuditFinding> with vec![]\n@@ -670,177 +670,17 @@\n         .iter()\n         .filter(|finding| finding.status != \"pass\")\n         .max_by_key(|finding| severity_rank(&finding.severity))\n         .map(|finding| finding.severity.clone())\n         .unwrap_or_else(|| \"low\".to_string())\n }\n \n async fn run_security_audit_checks(state: &AppState) -> Vec<SecurityAuditFinding> {\n-    let mut findings = Vec::new();\n-\n-    if state.token.trim().is_empty() {\n-        findings.push(security_finding(\n-            \"daemon_auth_token\",\n-            \"medium\",\n-            \"warn\",\n-            \"Daemon auth token is empty; this is unexpected because token bootstrap is automatic and protected endpoints fail closed.\"\n-                .to_string(),\n-            Some(\"Restart the app/daemon to re-run token bootstrap and verify keyring/secret-store availability.\"),\n-            false,\n-        ));\n-    } else {\n-        findings.push(security_finding(\n-            \"daemon_auth_token\",\n-            \"low\",\n-            \"pass\",\n-            \"Daemon auth token is configured.\".to_string(),\n-            None,\n-            false,\n-        ));\n-    }\n-\n-    match Config::from_store(&state.db_path) {\n-        Ok(config) => {\n-            findings.push(security_finding(\n-                \"config_load\",\n-                \"low\",\n-                \"pass\",\n-                \"Config loaded from store/keyring.\".to_string(),\n-                None,\n-                false,\n-            ));\n-\n-            let has_inline_api_key = config\n-                .openai\n-                .as_ref()\n-                .and_then(|openai| openai.api_key.as_ref())\n-                .map(|key| !key.trim().is_empty())\n-                .unwrap_or(false)\n-                || config\n-                    .memory\n-                    .as_ref()\n-                    .and_then(|memory| memory.openai.as_ref())\n-                    .and_then(|openai| openai.api_key.as_ref())\n-                    .map(|key| !key.trim().is_empty())\n-                    .unwrap_or(false);\n-\n-            if has_inline_api_key {\n-                findings.push(security_finding(\n-                    \"inline_api_keys\",\n-                    \"high\",\n-                    \"warn\",\n-                    \"API keys appear inline in config JSON; prefer keyring-backed secrets.\"\n-                        .to_string(),\n-                    Some(\"Remove inline keys and set secrets via `butterfly-bot secrets-set`.\"),\n-                    false,\n-                ));\n-            } else {\n-                findings.push(security_finding(\n-                    \"inline_api_keys\",\n-                    \"low\",\n-                    \"pass\",\n-                    \"No inline API keys detected in loaded config.\".to_string(),\n-                    None,\n-                    false,\n-                ));\n-            }\n-\n-            let root = json!({ \"tools\": config.tools.clone().unwrap_or(Value::Null) });\n-            let sandbox = SandboxSettings::from_root_config(&root);\n-\n-            let built_in_tools = [\n-                \"coding\",\n-                \"mcp\",\n-                \"http_call\",\n-                \"github\",\n-                \"zapier\",\n-                \"planning\",\n-                \"reminders\",\n-                \"search_internet\",\n-                \"tasks\",\n-                \"todo\",\n-                \"wakeup\",\n-            ];\n-            let mut non_wasm_tools = Vec::new();\n-            for tool_name in built_in_tools {\n-                let plan = sandbox.execution_plan(tool_name);\n-                if plan.runtime != ToolRuntime::Wasm {\n-                    non_wasm_tools.push(tool_name);\n-                }\n-            }\n-\n-            if non_wasm_tools.is_empty() {\n-                findings.push(security_finding(\n-                    \"tool_runtime_invariant\",\n-                    \"low\",\n-                    \"pass\",\n-                    \"All built-in tools resolve to WASM runtime.\".to_string(),\n-                    None,\n-                    false,\n-                ));\n-            } else {\n-                findings.push(security_finding(\n-                    \"tool_runtime_invariant\",\n-                    \"high\",\n-                    \"fail\",\n-                    format!(\n-                        \"Non-WASM tool runtime detected for: {}.\",\n-                        non_wasm_tools.join(\", \")\n-                    ),\n-                    Some(\n-                        \"Enforce WASM-only execution in sandbox settings and tool runtime planner.\",\n-                    ),\n-                    false,\n-                ));\n-            }\n-\n-            let default_deny = config\n-                .tools\n-                .as_ref()\n-                .and_then(|tools| tools.get(\"settings\"))\n-                .and_then(|settings| settings.get(\"permissions\"))\n-                .and_then(|permissions| permissions.get(\"default_deny\"))\n-                .and_then(|value| value.as_bool())\n-                .unwrap_or(false);\n-\n-            if default_deny {\n-                findings.push(security_finding(\n-                    \"network_default_deny\",\n-                    \"low\",\n-                    \"pass\",\n-                    \"Global tools network policy uses default_deny=true.\".to_string(),\n-                    None,\n-                    false,\n-                ));\n-            } else {\n-                findings.push(security_finding(\n-                    \"network_default_deny\",\n-                    \"medium\",\n-                    \"warn\",\n-                    \"Global tools network policy default_deny is disabled or missing.\"\n-                        .to_string(),\n-                    Some(\"Set tools.settings.permissions.default_deny to true and allowlist required domains.\"),\n-                    false,\n-                ));\n-            }\n-        }\n-        Err(err) => {\n-            findings.push(security_finding(\n-                \"config_load\",\n-                \"critical\",\n-                \"fail\",\n-                format!(\"Config load failed: {err}\"),\n-                Some(\"Save a valid config in Config tab and rerun security audit.\"),\n-                false,\n-            ));\n-        }\n-    }\n-\n-    findings\n+    vec![] /* ~ changed by cargo-mutants ~ */\n }\n \n async fn run_doctor_checks(state: &AppState) -> Vec<DoctorCheck> {\n     let mut checks = Vec::new();\n \n     if state.token.trim().is_empty() {\n         checks.push(doctor_check(\n             \"daemon_auth_token\",\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_security_audit_checks",
      "return_type": "-> Vec<SecurityAuditFinding>",
      "span": {
        "end": {
          "column": 2,
          "line": 839
        },
        "start": {
          "column": 1,
          "line": 677
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:678:5: replace run_security_audit_checks -> Vec<SecurityAuditFinding> with vec![]",
    "package": "butterfly-bot",
    "replacement": "vec![]",
    "span": {
      "end": {
        "column": 13,
        "line": 838
      },
      "start": {
        "column": 5,
        "line": 678
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace run_security_audit_checks -> Vec<SecurityAuditFinding> with vec![Default::default()]\n@@ -670,177 +670,17 @@\n         .iter()\n         .filter(|finding| finding.status != \"pass\")\n         .max_by_key(|finding| severity_rank(&finding.severity))\n         .map(|finding| finding.severity.clone())\n         .unwrap_or_else(|| \"low\".to_string())\n }\n \n async fn run_security_audit_checks(state: &AppState) -> Vec<SecurityAuditFinding> {\n-    let mut findings = Vec::new();\n-\n-    if state.token.trim().is_empty() {\n-        findings.push(security_finding(\n-            \"daemon_auth_token\",\n-            \"medium\",\n-            \"warn\",\n-            \"Daemon auth token is empty; this is unexpected because token bootstrap is automatic and protected endpoints fail closed.\"\n-                .to_string(),\n-            Some(\"Restart the app/daemon to re-run token bootstrap and verify keyring/secret-store availability.\"),\n-            false,\n-        ));\n-    } else {\n-        findings.push(security_finding(\n-            \"daemon_auth_token\",\n-            \"low\",\n-            \"pass\",\n-            \"Daemon auth token is configured.\".to_string(),\n-            None,\n-            false,\n-        ));\n-    }\n-\n-    match Config::from_store(&state.db_path) {\n-        Ok(config) => {\n-            findings.push(security_finding(\n-                \"config_load\",\n-                \"low\",\n-                \"pass\",\n-                \"Config loaded from store/keyring.\".to_string(),\n-                None,\n-                false,\n-            ));\n-\n-            let has_inline_api_key = config\n-                .openai\n-                .as_ref()\n-                .and_then(|openai| openai.api_key.as_ref())\n-                .map(|key| !key.trim().is_empty())\n-                .unwrap_or(false)\n-                || config\n-                    .memory\n-                    .as_ref()\n-                    .and_then(|memory| memory.openai.as_ref())\n-                    .and_then(|openai| openai.api_key.as_ref())\n-                    .map(|key| !key.trim().is_empty())\n-                    .unwrap_or(false);\n-\n-            if has_inline_api_key {\n-                findings.push(security_finding(\n-                    \"inline_api_keys\",\n-                    \"high\",\n-                    \"warn\",\n-                    \"API keys appear inline in config JSON; prefer keyring-backed secrets.\"\n-                        .to_string(),\n-                    Some(\"Remove inline keys and set secrets via `butterfly-bot secrets-set`.\"),\n-                    false,\n-                ));\n-            } else {\n-                findings.push(security_finding(\n-                    \"inline_api_keys\",\n-                    \"low\",\n-                    \"pass\",\n-                    \"No inline API keys detected in loaded config.\".to_string(),\n-                    None,\n-                    false,\n-                ));\n-            }\n-\n-            let root = json!({ \"tools\": config.tools.clone().unwrap_or(Value::Null) });\n-            let sandbox = SandboxSettings::from_root_config(&root);\n-\n-            let built_in_tools = [\n-                \"coding\",\n-                \"mcp\",\n-                \"http_call\",\n-                \"github\",\n-                \"zapier\",\n-                \"planning\",\n-                \"reminders\",\n-                \"search_internet\",\n-                \"tasks\",\n-                \"todo\",\n-                \"wakeup\",\n-            ];\n-            let mut non_wasm_tools = Vec::new();\n-            for tool_name in built_in_tools {\n-                let plan = sandbox.execution_plan(tool_name);\n-                if plan.runtime != ToolRuntime::Wasm {\n-                    non_wasm_tools.push(tool_name);\n-                }\n-            }\n-\n-            if non_wasm_tools.is_empty() {\n-                findings.push(security_finding(\n-                    \"tool_runtime_invariant\",\n-                    \"low\",\n-                    \"pass\",\n-                    \"All built-in tools resolve to WASM runtime.\".to_string(),\n-                    None,\n-                    false,\n-                ));\n-            } else {\n-                findings.push(security_finding(\n-                    \"tool_runtime_invariant\",\n-                    \"high\",\n-                    \"fail\",\n-                    format!(\n-                        \"Non-WASM tool runtime detected for: {}.\",\n-                        non_wasm_tools.join(\", \")\n-                    ),\n-                    Some(\n-                        \"Enforce WASM-only execution in sandbox settings and tool runtime planner.\",\n-                    ),\n-                    false,\n-                ));\n-            }\n-\n-            let default_deny = config\n-                .tools\n-                .as_ref()\n-                .and_then(|tools| tools.get(\"settings\"))\n-                .and_then(|settings| settings.get(\"permissions\"))\n-                .and_then(|permissions| permissions.get(\"default_deny\"))\n-                .and_then(|value| value.as_bool())\n-                .unwrap_or(false);\n-\n-            if default_deny {\n-                findings.push(security_finding(\n-                    \"network_default_deny\",\n-                    \"low\",\n-                    \"pass\",\n-                    \"Global tools network policy uses default_deny=true.\".to_string(),\n-                    None,\n-                    false,\n-                ));\n-            } else {\n-                findings.push(security_finding(\n-                    \"network_default_deny\",\n-                    \"medium\",\n-                    \"warn\",\n-                    \"Global tools network policy default_deny is disabled or missing.\"\n-                        .to_string(),\n-                    Some(\"Set tools.settings.permissions.default_deny to true and allowlist required domains.\"),\n-                    false,\n-                ));\n-            }\n-        }\n-        Err(err) => {\n-            findings.push(security_finding(\n-                \"config_load\",\n-                \"critical\",\n-                \"fail\",\n-                format!(\"Config load failed: {err}\"),\n-                Some(\"Save a valid config in Config tab and rerun security audit.\"),\n-                false,\n-            ));\n-        }\n-    }\n-\n-    findings\n+    vec![Default::default()] /* ~ changed by cargo-mutants ~ */\n }\n \n async fn run_doctor_checks(state: &AppState) -> Vec<DoctorCheck> {\n     let mut checks = Vec::new();\n \n     if state.token.trim().is_empty() {\n         checks.push(doctor_check(\n             \"daemon_auth_token\",\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_security_audit_checks",
      "return_type": "-> Vec<SecurityAuditFinding>",
      "span": {
        "end": {
          "column": 2,
          "line": 839
        },
        "start": {
          "column": 1,
          "line": 677
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:678:5: replace run_security_audit_checks -> Vec<SecurityAuditFinding> with vec![Default::default()]",
    "package": "butterfly-bot",
    "replacement": "vec![Default::default()]",
    "span": {
      "end": {
        "column": 13,
        "line": 838
      },
      "start": {
        "column": 5,
        "line": 678
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace || with && in run_security_audit_checks\n@@ -710,17 +710,17 @@\n             ));\n \n             let has_inline_api_key = config\n                 .openai\n                 .as_ref()\n                 .and_then(|openai| openai.api_key.as_ref())\n                 .map(|key| !key.trim().is_empty())\n                 .unwrap_or(false)\n-                || config\n+                && /* ~ changed by cargo-mutants ~ */ config\n                     .memory\n                     .as_ref()\n                     .and_then(|memory| memory.openai.as_ref())\n                     .and_then(|openai| openai.api_key.as_ref())\n                     .map(|key| !key.trim().is_empty())\n                     .unwrap_or(false);\n \n             if has_inline_api_key {\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_security_audit_checks",
      "return_type": "-> Vec<SecurityAuditFinding>",
      "span": {
        "end": {
          "column": 2,
          "line": 839
        },
        "start": {
          "column": 1,
          "line": 677
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:718:17: replace || with && in run_security_audit_checks",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 19,
        "line": 718
      },
      "start": {
        "column": 17,
        "line": 718
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in run_security_audit_checks\n@@ -708,17 +708,17 @@\n                 None,\n                 false,\n             ));\n \n             let has_inline_api_key = config\n                 .openai\n                 .as_ref()\n                 .and_then(|openai| openai.api_key.as_ref())\n-                .map(|key| !key.trim().is_empty())\n+                .map(|key|  /* ~ changed by cargo-mutants ~ */key.trim().is_empty())\n                 .unwrap_or(false)\n                 || config\n                     .memory\n                     .as_ref()\n                     .and_then(|memory| memory.openai.as_ref())\n                     .and_then(|openai| openai.api_key.as_ref())\n                     .map(|key| !key.trim().is_empty())\n                     .unwrap_or(false);\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_security_audit_checks",
      "return_type": "-> Vec<SecurityAuditFinding>",
      "span": {
        "end": {
          "column": 2,
          "line": 839
        },
        "start": {
          "column": 1,
          "line": 677
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:716:28: delete ! in run_security_audit_checks",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 29,
        "line": 716
      },
      "start": {
        "column": 28,
        "line": 716
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in run_security_audit_checks\n@@ -715,17 +715,17 @@\n                 .and_then(|openai| openai.api_key.as_ref())\n                 .map(|key| !key.trim().is_empty())\n                 .unwrap_or(false)\n                 || config\n                     .memory\n                     .as_ref()\n                     .and_then(|memory| memory.openai.as_ref())\n                     .and_then(|openai| openai.api_key.as_ref())\n-                    .map(|key| !key.trim().is_empty())\n+                    .map(|key|  /* ~ changed by cargo-mutants ~ */key.trim().is_empty())\n                     .unwrap_or(false);\n \n             if has_inline_api_key {\n                 findings.push(security_finding(\n                     \"inline_api_keys\",\n                     \"high\",\n                     \"warn\",\n                     \"API keys appear inline in config JSON; prefer keyring-backed secrets.\"\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_security_audit_checks",
      "return_type": "-> Vec<SecurityAuditFinding>",
      "span": {
        "end": {
          "column": 2,
          "line": 839
        },
        "start": {
          "column": 1,
          "line": 677
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:723:32: delete ! in run_security_audit_checks",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 33,
        "line": 723
      },
      "start": {
        "column": 32,
        "line": 723
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace != with == in run_security_audit_checks\n@@ -758,17 +758,17 @@\n                 \"search_internet\",\n                 \"tasks\",\n                 \"todo\",\n                 \"wakeup\",\n             ];\n             let mut non_wasm_tools = Vec::new();\n             for tool_name in built_in_tools {\n                 let plan = sandbox.execution_plan(tool_name);\n-                if plan.runtime != ToolRuntime::Wasm {\n+                if plan.runtime == /* ~ changed by cargo-mutants ~ */ ToolRuntime::Wasm {\n                     non_wasm_tools.push(tool_name);\n                 }\n             }\n \n             if non_wasm_tools.is_empty() {\n                 findings.push(security_finding(\n                     \"tool_runtime_invariant\",\n                     \"low\",\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_security_audit_checks",
      "return_type": "-> Vec<SecurityAuditFinding>",
      "span": {
        "end": {
          "column": 2,
          "line": 839
        },
        "start": {
          "column": 1,
          "line": 677
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:766:33: replace != with == in run_security_audit_checks",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 35,
        "line": 766
      },
      "start": {
        "column": 33,
        "line": 766
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace run_doctor_checks -> Vec<DoctorCheck> with vec![]\n@@ -834,160 +834,17 @@\n             ));\n         }\n     }\n \n     findings\n }\n \n async fn run_doctor_checks(state: &AppState) -> Vec<DoctorCheck> {\n-    let mut checks = Vec::new();\n-\n-    if state.token.trim().is_empty() {\n-        checks.push(doctor_check(\n-            \"daemon_auth_token\",\n-            \"warn\",\n-            \"Daemon auth token is empty; this is unexpected because token bootstrap is automatic and protected endpoints fail closed.\"\n-                .to_string(),\n-            Some(\"Restart the app/daemon to re-run token bootstrap and verify keyring/secret-store availability.\"),\n-        ));\n-    } else {\n-        checks.push(doctor_check(\n-            \"daemon_auth_token\",\n-            \"pass\",\n-            \"Daemon auth token is configured.\".to_string(),\n-            None,\n-        ));\n-    }\n-\n-    match Config::from_store(&state.db_path) {\n-        Ok(config) => {\n-            checks.push(doctor_check(\n-                \"config_store\",\n-                \"pass\",\n-                \"Config loaded from store/keyring.\".to_string(),\n-                None,\n-            ));\n-\n-            match config.clone().resolve_vault() {\n-                Ok(_) => {\n-                    checks.push(doctor_check(\n-                        \"vault_resolution\",\n-                        \"pass\",\n-                        \"Vault-backed secrets resolved successfully.\".to_string(),\n-                        None,\n-                    ));\n-                }\n-                Err(err) => {\n-                    checks.push(doctor_check(\n-                        \"vault_resolution\",\n-                        \"fail\",\n-                        format!(\"Vault resolution failed: {err}\"),\n-                        Some(\"Verify OS keychain access and required secret keys.\"),\n-                    ));\n-                }\n-            }\n-\n-            match check_provider_health(&config).await {\n-                Ok(check) => checks.push(check),\n-                Err(err) => checks.push(doctor_check(\n-                    \"provider_health\",\n-                    \"fail\",\n-                    format!(\"Provider health check failed: {err}\"),\n-                    Some(\"Verify provider base_url/model and network access.\"),\n-                )),\n-            }\n-        }\n-        Err(err) => {\n-            checks.push(doctor_check(\n-                \"config_store\",\n-                \"fail\",\n-                format!(\"Config load failed: {err}\"),\n-                Some(\"Save a valid config in the Config tab and retry.\"),\n-            ));\n-            checks.push(doctor_check(\n-                \"vault_resolution\",\n-                \"warn\",\n-                \"Skipped because config could not be loaded.\".to_string(),\n-                Some(\"Fix config_store check first.\"),\n-            ));\n-            checks.push(doctor_check(\n-                \"provider_health\",\n-                \"warn\",\n-                \"Skipped because config could not be loaded.\".to_string(),\n-                Some(\"Fix config_store check first.\"),\n-            ));\n-        }\n-    }\n-\n-    let db_path = state.db_path.clone();\n-    let db_check = tokio::task::spawn_blocking(move || -> DoctorCheck {\n-        if let Err(err) = crate::config_store::ensure_parent_dir(&db_path) {\n-            return doctor_check(\n-                \"database_access\",\n-                \"fail\",\n-                format!(\"Database directory check failed: {err}\"),\n-                Some(\"Verify filesystem permissions for DB path.\"),\n-            );\n-        }\n-\n-        let mut conn = match SqliteConnection::establish(&db_path) {\n-            Ok(conn) => conn,\n-            Err(err) => {\n-                return doctor_check(\n-                    \"database_access\",\n-                    \"fail\",\n-                    format!(\"Database open failed: {err}\"),\n-                    Some(\"Verify DB path and SQLite/SQLCipher availability.\"),\n-                )\n-            }\n-        };\n-\n-        if let Err(err) = crate::db::apply_sqlcipher_key_sync(&mut conn) {\n-            return doctor_check(\n-                \"database_access\",\n-                \"fail\",\n-                format!(\"Database key apply failed: {err}\"),\n-                Some(\"Verify secure secret storage availability for db_encryption_key.\"),\n-            );\n-        }\n-\n-        let probe_result = diesel::sql_query(\n-            \"CREATE TABLE IF NOT EXISTS doctor_probe (id INTEGER PRIMARY KEY, ts INTEGER NOT NULL)\",\n-        )\n-        .execute(&mut conn);\n-\n-        match probe_result {\n-            Ok(_) => doctor_check(\n-                \"database_access\",\n-                \"pass\",\n-                \"Database opened and write probe succeeded.\".to_string(),\n-                None,\n-            ),\n-            Err(err) => doctor_check(\n-                \"database_access\",\n-                \"fail\",\n-                format!(\"Database write probe failed: {err}\"),\n-                Some(\"Verify DB permissions and SQLCipher key configuration.\"),\n-            ),\n-        }\n-    })\n-    .await;\n-\n-    match db_check {\n-        Ok(check) => checks.push(check),\n-        Err(err) => checks.push(doctor_check(\n-            \"database_access\",\n-            \"fail\",\n-            format!(\"Database check task failed: {err}\"),\n-            Some(\"Retry diagnostics; if persistent, inspect runtime logs.\"),\n-        )),\n-    }\n-\n-    checks\n+    vec![] /* ~ changed by cargo-mutants ~ */\n }\n \n async fn check_provider_health(config: &Config) -> Result<DoctorCheck> {\n     let provider = config.openai.clone().or_else(|| {\n         config\n             .memory\n             .as_ref()\n             .and_then(|memory| memory.openai.clone())\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_doctor_checks",
      "return_type": "-> Vec<DoctorCheck>",
      "span": {
        "end": {
          "column": 2,
          "line": 986
        },
        "start": {
          "column": 1,
          "line": 841
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:842:5: replace run_doctor_checks -> Vec<DoctorCheck> with vec![]",
    "package": "butterfly-bot",
    "replacement": "vec![]",
    "span": {
      "end": {
        "column": 11,
        "line": 985
      },
      "start": {
        "column": 5,
        "line": 842
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace run_doctor_checks -> Vec<DoctorCheck> with vec![Default::default()]\n@@ -834,160 +834,17 @@\n             ));\n         }\n     }\n \n     findings\n }\n \n async fn run_doctor_checks(state: &AppState) -> Vec<DoctorCheck> {\n-    let mut checks = Vec::new();\n-\n-    if state.token.trim().is_empty() {\n-        checks.push(doctor_check(\n-            \"daemon_auth_token\",\n-            \"warn\",\n-            \"Daemon auth token is empty; this is unexpected because token bootstrap is automatic and protected endpoints fail closed.\"\n-                .to_string(),\n-            Some(\"Restart the app/daemon to re-run token bootstrap and verify keyring/secret-store availability.\"),\n-        ));\n-    } else {\n-        checks.push(doctor_check(\n-            \"daemon_auth_token\",\n-            \"pass\",\n-            \"Daemon auth token is configured.\".to_string(),\n-            None,\n-        ));\n-    }\n-\n-    match Config::from_store(&state.db_path) {\n-        Ok(config) => {\n-            checks.push(doctor_check(\n-                \"config_store\",\n-                \"pass\",\n-                \"Config loaded from store/keyring.\".to_string(),\n-                None,\n-            ));\n-\n-            match config.clone().resolve_vault() {\n-                Ok(_) => {\n-                    checks.push(doctor_check(\n-                        \"vault_resolution\",\n-                        \"pass\",\n-                        \"Vault-backed secrets resolved successfully.\".to_string(),\n-                        None,\n-                    ));\n-                }\n-                Err(err) => {\n-                    checks.push(doctor_check(\n-                        \"vault_resolution\",\n-                        \"fail\",\n-                        format!(\"Vault resolution failed: {err}\"),\n-                        Some(\"Verify OS keychain access and required secret keys.\"),\n-                    ));\n-                }\n-            }\n-\n-            match check_provider_health(&config).await {\n-                Ok(check) => checks.push(check),\n-                Err(err) => checks.push(doctor_check(\n-                    \"provider_health\",\n-                    \"fail\",\n-                    format!(\"Provider health check failed: {err}\"),\n-                    Some(\"Verify provider base_url/model and network access.\"),\n-                )),\n-            }\n-        }\n-        Err(err) => {\n-            checks.push(doctor_check(\n-                \"config_store\",\n-                \"fail\",\n-                format!(\"Config load failed: {err}\"),\n-                Some(\"Save a valid config in the Config tab and retry.\"),\n-            ));\n-            checks.push(doctor_check(\n-                \"vault_resolution\",\n-                \"warn\",\n-                \"Skipped because config could not be loaded.\".to_string(),\n-                Some(\"Fix config_store check first.\"),\n-            ));\n-            checks.push(doctor_check(\n-                \"provider_health\",\n-                \"warn\",\n-                \"Skipped because config could not be loaded.\".to_string(),\n-                Some(\"Fix config_store check first.\"),\n-            ));\n-        }\n-    }\n-\n-    let db_path = state.db_path.clone();\n-    let db_check = tokio::task::spawn_blocking(move || -> DoctorCheck {\n-        if let Err(err) = crate::config_store::ensure_parent_dir(&db_path) {\n-            return doctor_check(\n-                \"database_access\",\n-                \"fail\",\n-                format!(\"Database directory check failed: {err}\"),\n-                Some(\"Verify filesystem permissions for DB path.\"),\n-            );\n-        }\n-\n-        let mut conn = match SqliteConnection::establish(&db_path) {\n-            Ok(conn) => conn,\n-            Err(err) => {\n-                return doctor_check(\n-                    \"database_access\",\n-                    \"fail\",\n-                    format!(\"Database open failed: {err}\"),\n-                    Some(\"Verify DB path and SQLite/SQLCipher availability.\"),\n-                )\n-            }\n-        };\n-\n-        if let Err(err) = crate::db::apply_sqlcipher_key_sync(&mut conn) {\n-            return doctor_check(\n-                \"database_access\",\n-                \"fail\",\n-                format!(\"Database key apply failed: {err}\"),\n-                Some(\"Verify secure secret storage availability for db_encryption_key.\"),\n-            );\n-        }\n-\n-        let probe_result = diesel::sql_query(\n-            \"CREATE TABLE IF NOT EXISTS doctor_probe (id INTEGER PRIMARY KEY, ts INTEGER NOT NULL)\",\n-        )\n-        .execute(&mut conn);\n-\n-        match probe_result {\n-            Ok(_) => doctor_check(\n-                \"database_access\",\n-                \"pass\",\n-                \"Database opened and write probe succeeded.\".to_string(),\n-                None,\n-            ),\n-            Err(err) => doctor_check(\n-                \"database_access\",\n-                \"fail\",\n-                format!(\"Database write probe failed: {err}\"),\n-                Some(\"Verify DB permissions and SQLCipher key configuration.\"),\n-            ),\n-        }\n-    })\n-    .await;\n-\n-    match db_check {\n-        Ok(check) => checks.push(check),\n-        Err(err) => checks.push(doctor_check(\n-            \"database_access\",\n-            \"fail\",\n-            format!(\"Database check task failed: {err}\"),\n-            Some(\"Retry diagnostics; if persistent, inspect runtime logs.\"),\n-        )),\n-    }\n-\n-    checks\n+    vec![Default::default()] /* ~ changed by cargo-mutants ~ */\n }\n \n async fn check_provider_health(config: &Config) -> Result<DoctorCheck> {\n     let provider = config.openai.clone().or_else(|| {\n         config\n             .memory\n             .as_ref()\n             .and_then(|memory| memory.openai.clone())\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_doctor_checks",
      "return_type": "-> Vec<DoctorCheck>",
      "span": {
        "end": {
          "column": 2,
          "line": 986
        },
        "start": {
          "column": 1,
          "line": 841
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:842:5: replace run_doctor_checks -> Vec<DoctorCheck> with vec![Default::default()]",
    "package": "butterfly-bot",
    "replacement": "vec![Default::default()]",
    "span": {
      "end": {
        "column": 11,
        "line": 985
      },
      "start": {
        "column": 5,
        "line": 842
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace check_provider_health -> Result<DoctorCheck> with Ok(Default::default())\n@@ -981,72 +981,17 @@\n             Some(\"Retry diagnostics; if persistent, inspect runtime logs.\"),\n         )),\n     }\n \n     checks\n }\n \n async fn check_provider_health(config: &Config) -> Result<DoctorCheck> {\n-    let provider = config.openai.clone().or_else(|| {\n-        config\n-            .memory\n-            .as_ref()\n-            .and_then(|memory| memory.openai.clone())\n-    });\n-\n-    let Some(provider) = provider else {\n-        return Ok(doctor_check(\n-            \"provider_health\",\n-            \"warn\",\n-            \"No provider config found in openai or memory.openai.\".to_string(),\n-            Some(\"Set provider base_url/model in Config tab.\"),\n-        ));\n-    };\n-\n-    let base_url = provider.base_url.unwrap_or_default();\n-    if base_url.trim().is_empty() {\n-        return Ok(doctor_check(\n-            \"provider_health\",\n-            \"fail\",\n-            \"Provider base_url is empty.\".to_string(),\n-            Some(\"Set openai.base_url (or memory.openai.base_url).\"),\n-        ));\n-    }\n-\n-    let models_url = format!(\"{}/models\", base_url.trim_end_matches('/'));\n-    let client = reqwest::Client::new();\n-    let result = tokio::time::timeout(Duration::from_secs(3), client.get(&models_url).send()).await;\n-\n-    match result {\n-        Ok(Ok(response)) if response.status().is_success() => Ok(doctor_check(\n-            \"provider_health\",\n-            \"pass\",\n-            format!(\"Provider responded successfully at {models_url}\"),\n-            None,\n-        )),\n-        Ok(Ok(response)) => Ok(doctor_check(\n-            \"provider_health\",\n-            \"warn\",\n-            format!(\"Provider reachable but returned HTTP {}\", response.status()),\n-            Some(\"Check provider auth/token and model availability.\"),\n-        )),\n-        Ok(Err(err)) => Ok(doctor_check(\n-            \"provider_health\",\n-            \"fail\",\n-            format!(\"Provider request failed: {err}\"),\n-            Some(\"Check base_url/network and that provider service is running.\"),\n-        )),\n-        Err(_) => Ok(doctor_check(\n-            \"provider_health\",\n-            \"fail\",\n-            \"Provider request timed out after 3s.\".to_string(),\n-            Some(\"Check provider responsiveness and network routing.\"),\n-        )),\n-    }\n+    Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n }\n \n async fn process_text(\n     State(state): State<AppState>,\n     headers: HeaderMap,\n     Json(payload): Json<ProcessTextRequest>,\n ) -> impl IntoResponse {\n     if let Err(err) = authorize(&headers, &state.token) {\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "check_provider_health",
      "return_type": "-> Result<DoctorCheck>",
      "span": {
        "end": {
          "column": 2,
          "line": 1045
        },
        "start": {
          "column": 1,
          "line": 988
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:989:5: replace check_provider_health -> Result<DoctorCheck> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 6,
        "line": 1044
      },
      "start": {
        "column": 5,
        "line": 989
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace match guard response.status().is_success() with true in check_provider_health\n@@ -1012,17 +1012,17 @@\n         ));\n     }\n \n     let models_url = format!(\"{}/models\", base_url.trim_end_matches('/'));\n     let client = reqwest::Client::new();\n     let result = tokio::time::timeout(Duration::from_secs(3), client.get(&models_url).send()).await;\n \n     match result {\n-        Ok(Ok(response)) if response.status().is_success() => Ok(doctor_check(\n+        Ok(Ok(response)) if true /* ~ changed by cargo-mutants ~ */ => Ok(doctor_check(\n             \"provider_health\",\n             \"pass\",\n             format!(\"Provider responded successfully at {models_url}\"),\n             None,\n         )),\n         Ok(Ok(response)) => Ok(doctor_check(\n             \"provider_health\",\n             \"warn\",\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "check_provider_health",
      "return_type": "-> Result<DoctorCheck>",
      "span": {
        "end": {
          "column": 2,
          "line": 1045
        },
        "start": {
          "column": 1,
          "line": 988
        }
      }
    },
    "genre": "MatchArmGuard",
    "name": "src/daemon.rs:1020:29: replace match guard response.status().is_success() with true in check_provider_health",
    "package": "butterfly-bot",
    "replacement": "true",
    "span": {
      "end": {
        "column": 59,
        "line": 1020
      },
      "start": {
        "column": 29,
        "line": 1020
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace match guard response.status().is_success() with false in check_provider_health\n@@ -1012,17 +1012,17 @@\n         ));\n     }\n \n     let models_url = format!(\"{}/models\", base_url.trim_end_matches('/'));\n     let client = reqwest::Client::new();\n     let result = tokio::time::timeout(Duration::from_secs(3), client.get(&models_url).send()).await;\n \n     match result {\n-        Ok(Ok(response)) if response.status().is_success() => Ok(doctor_check(\n+        Ok(Ok(response)) if false /* ~ changed by cargo-mutants ~ */ => Ok(doctor_check(\n             \"provider_health\",\n             \"pass\",\n             format!(\"Provider responded successfully at {models_url}\"),\n             None,\n         )),\n         Ok(Ok(response)) => Ok(doctor_check(\n             \"provider_health\",\n             \"warn\",\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "check_provider_health",
      "return_type": "-> Result<DoctorCheck>",
      "span": {
        "end": {
          "column": 2,
          "line": 1045
        },
        "start": {
          "column": 1,
          "line": 988
        }
      }
    },
    "genre": "MatchArmGuard",
    "name": "src/daemon.rs:1020:29: replace match guard response.status().is_success() with false in check_provider_health",
    "package": "butterfly-bot",
    "replacement": "false",
    "span": {
      "end": {
        "column": 59,
        "line": 1020
      },
      "start": {
        "column": 29,
        "line": 1020
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in preload_boot\n@@ -1181,17 +1181,17 @@\n \n         let heartbeat_status = if let Ok(config) = Config::from_store(&db_path) {\n             let source = config.heartbeat_source;\n             match tokio::time::timeout(quick_timeout, load_markdown_content(&source)).await {\n                 Ok(Ok(markdown)) => {\n                     agent.set_heartbeat_markdown(markdown.clone()).await;\n                     if markdown\n                         .as_ref()\n-                        .map(|m| !m.trim().is_empty())\n+                        .map(|m|  /* ~ changed by cargo-mutants ~ */m.trim().is_empty())\n                         .unwrap_or(false)\n                     {\n                         \"ok\".to_string()\n                     } else {\n                         \"empty\".to_string()\n                     }\n                 }\n                 Ok(Err(err)) => format!(\"error: {err}\"),\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:1189:34: delete ! in preload_boot",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 35,
        "line": 1189
      },
      "start": {
        "column": 34,
        "line": 1189
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in preload_boot\n@@ -1200,17 +1200,17 @@\n                     let ui_event_tx = ui_event_tx.clone();\n                     let source = source.clone();\n                     tokio::spawn(async move {\n                         let status = match load_markdown_content(&source).await {\n                             Ok(markdown) => {\n                                 agent.set_heartbeat_markdown(markdown.clone()).await;\n                                 if markdown\n                                     .as_ref()\n-                                    .map(|m| !m.trim().is_empty())\n+                                    .map(|m|  /* ~ changed by cargo-mutants ~ */m.trim().is_empty())\n                                     .unwrap_or(false)\n                                 {\n                                     \"ok\".to_string()\n                                 } else {\n                                     \"empty\".to_string()\n                                 }\n                             }\n                             Err(err) => format!(\"error: {err}\"),\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:1208:46: delete ! in preload_boot",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 47,
        "line": 1208
      },
      "start": {
        "column": 46,
        "line": 1208
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in preload_boot\n@@ -1242,17 +1242,17 @@\n \n         let prompt_status = if let Ok(config) = Config::from_store(&db_path) {\n             let source = config.prompt_source;\n             match tokio::time::timeout(quick_timeout, load_markdown_content(&source)).await {\n                 Ok(Ok(markdown)) => {\n                     agent.set_prompt_markdown(markdown.clone()).await;\n                     if markdown\n                         .as_ref()\n-                        .map(|m| !m.trim().is_empty())\n+                        .map(|m|  /* ~ changed by cargo-mutants ~ */m.trim().is_empty())\n                         .unwrap_or(false)\n                     {\n                         \"ok\".to_string()\n                     } else {\n                         \"empty\".to_string()\n                     }\n                 }\n                 Ok(Err(err)) => format!(\"error: {err}\"),\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:1250:34: delete ! in preload_boot",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 35,
        "line": 1250
      },
      "start": {
        "column": 34,
        "line": 1250
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in preload_boot\n@@ -1261,17 +1261,17 @@\n                     let ui_event_tx = ui_event_tx.clone();\n                     let source = source.clone();\n                     tokio::spawn(async move {\n                         let status = match load_markdown_content(&source).await {\n                             Ok(markdown) => {\n                                 agent.set_prompt_markdown(markdown.clone()).await;\n                                 if markdown\n                                     .as_ref()\n-                                    .map(|m| !m.trim().is_empty())\n+                                    .map(|m|  /* ~ changed by cargo-mutants ~ */m.trim().is_empty())\n                                     .unwrap_or(false)\n                                 {\n                                     \"ok\".to_string()\n                                 } else {\n                                     \"empty\".to_string()\n                                 }\n                             }\n                             Err(err) => format!(\"error: {err}\"),\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:1269:46: delete ! in preload_boot",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 47,
        "line": 1269
      },
      "start": {
        "column": 46,
        "line": 1269
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace && with || in preload_boot\n@@ -1299,17 +1299,17 @@\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n             || heartbeat_status == \"empty\"\n             || heartbeat_status == \"deferred\")\n-            && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n+            || /* ~ changed by cargo-mutants ~ */ (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n             });\n         }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1307:13: replace && with || in preload_boot",
    "package": "butterfly-bot",
    "replacement": "||",
    "span": {
      "end": {
        "column": 15,
        "line": 1307
      },
      "start": {
        "column": 13,
        "line": 1307
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace || with && in preload_boot\n@@ -1298,17 +1298,17 @@\n             tool: \"prompt\".to_string(),\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n             || heartbeat_status == \"empty\"\n-            || heartbeat_status == \"deferred\")\n+            && /* ~ changed by cargo-mutants ~ */ heartbeat_status == \"deferred\")\n             && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n             });\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1306:13: replace || with && in preload_boot",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 15,
        "line": 1306
      },
      "start": {
        "column": 13,
        "line": 1306
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace || with && in preload_boot\n@@ -1297,17 +1297,17 @@\n             user_id: user_id.clone(),\n             tool: \"prompt\".to_string(),\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n-            || heartbeat_status == \"empty\"\n+            && /* ~ changed by cargo-mutants ~ */ heartbeat_status == \"empty\"\n             || heartbeat_status == \"deferred\")\n             && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1305:13: replace || with && in preload_boot",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 15,
        "line": 1305
      },
      "start": {
        "column": 13,
        "line": 1305
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in preload_boot\n@@ -1296,17 +1296,17 @@\n             event_type: \"boot\".to_string(),\n             user_id: user_id.clone(),\n             tool: \"prompt\".to_string(),\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n-        if (heartbeat_status == \"ok\"\n+        if (heartbeat_status != /* ~ changed by cargo-mutants ~ */ \"ok\"\n             || heartbeat_status == \"empty\"\n             || heartbeat_status == \"deferred\")\n             && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1304:30: replace == with != in preload_boot",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 32,
        "line": 1304
      },
      "start": {
        "column": 30,
        "line": 1304
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in preload_boot\n@@ -1297,17 +1297,17 @@\n             user_id: user_id.clone(),\n             tool: \"prompt\".to_string(),\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n-            || heartbeat_status == \"empty\"\n+            || heartbeat_status != /* ~ changed by cargo-mutants ~ */ \"empty\"\n             || heartbeat_status == \"deferred\")\n             && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1305:33: replace == with != in preload_boot",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 35,
        "line": 1305
      },
      "start": {
        "column": 33,
        "line": 1305
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in preload_boot\n@@ -1298,17 +1298,17 @@\n             tool: \"prompt\".to_string(),\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n             || heartbeat_status == \"empty\"\n-            || heartbeat_status == \"deferred\")\n+            || heartbeat_status != /* ~ changed by cargo-mutants ~ */ \"deferred\")\n             && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n             });\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1306:33: replace == with != in preload_boot",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 35,
        "line": 1306
      },
      "start": {
        "column": 33,
        "line": 1306
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace || with && in preload_boot\n@@ -1299,17 +1299,17 @@\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n             || heartbeat_status == \"empty\"\n             || heartbeat_status == \"deferred\")\n-            && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n+            && (prompt_status == \"ok\" || prompt_status == \"empty\" && /* ~ changed by cargo-mutants ~ */ prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n             });\n         }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1307:67: replace || with && in preload_boot",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 69,
        "line": 1307
      },
      "start": {
        "column": 67,
        "line": 1307
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace || with && in preload_boot\n@@ -1299,17 +1299,17 @@\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n             || heartbeat_status == \"empty\"\n             || heartbeat_status == \"deferred\")\n-            && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n+            && (prompt_status == \"ok\" && /* ~ changed by cargo-mutants ~ */ prompt_status == \"empty\" || prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n             });\n         }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1307:39: replace || with && in preload_boot",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 41,
        "line": 1307
      },
      "start": {
        "column": 39,
        "line": 1307
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in preload_boot\n@@ -1299,17 +1299,17 @@\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n             || heartbeat_status == \"empty\"\n             || heartbeat_status == \"deferred\")\n-            && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n+            && (prompt_status != /* ~ changed by cargo-mutants ~ */ \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n             });\n         }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1307:31: replace == with != in preload_boot",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 33,
        "line": 1307
      },
      "start": {
        "column": 31,
        "line": 1307
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in preload_boot\n@@ -1299,17 +1299,17 @@\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n             || heartbeat_status == \"empty\"\n             || heartbeat_status == \"deferred\")\n-            && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n+            && (prompt_status == \"ok\" || prompt_status != /* ~ changed by cargo-mutants ~ */ \"empty\" || prompt_status == \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n             });\n         }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1307:56: replace == with != in preload_boot",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 58,
        "line": 1307
      },
      "start": {
        "column": 56,
        "line": 1307
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in preload_boot\n@@ -1299,17 +1299,17 @@\n             status: prompt_status.clone(),\n             payload: json!({\"status\": prompt_status}),\n             timestamp: now_ts(),\n         });\n \n         if (heartbeat_status == \"ok\"\n             || heartbeat_status == \"empty\"\n             || heartbeat_status == \"deferred\")\n-            && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status == \"deferred\")\n+            && (prompt_status == \"ok\" || prompt_status == \"empty\" || prompt_status != /* ~ changed by cargo-mutants ~ */ \"deferred\")\n         {\n             let agent = agent.clone();\n             let ui_event_tx = ui_event_tx.clone();\n             let user_id = user_id.clone();\n             tokio::spawn(async move {\n                 run_autonomy_tick(agent, ui_event_tx, user_id, \"boot\").await;\n             });\n         }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "preload_boot",
      "return_type": "-> impl IntoResponse",
      "span": {
        "end": {
          "column": 2,
          "line": 1326
        },
        "start": {
          "column": 1,
          "line": 1131
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1307:84: replace == with != in preload_boot",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 86,
        "line": 1307
      },
      "start": {
        "column": 84,
        "line": 1307
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace authorize -> std::result::Result<(), (StatusCode, Json<ErrorResponse>)> with Ok(())\n@@ -1607,47 +1607,17 @@\n         .body(body)\n         .unwrap()\n }\n \n fn authorize(\n     headers: &HeaderMap,\n     token: &str,\n ) -> std::result::Result<(), (StatusCode, Json<ErrorResponse>)> {\n-    let expected_token = token.trim();\n-    if expected_token.is_empty() {\n-        return Err((\n-            StatusCode::UNAUTHORIZED,\n-            Json(ErrorResponse {\n-                error: \"Unauthorized\".to_string(),\n-            }),\n-        ));\n-    }\n-\n-    let header = headers\n-        .get(\"authorization\")\n-        .and_then(|value| value.to_str().ok())\n-        .unwrap_or_default();\n-    let api_key = headers\n-        .get(\"x-api-key\")\n-        .and_then(|value| value.to_str().ok())\n-        .unwrap_or_default();\n-    let bearer = header.strip_prefix(\"Bearer \").unwrap_or(\"\").trim();\n-    let api_key = api_key.trim();\n-\n-    if bearer == expected_token || api_key == expected_token {\n-        Ok(())\n-    } else {\n-        Err((\n-            StatusCode::UNAUTHORIZED,\n-            Json(ErrorResponse {\n-                error: \"Unauthorized\".to_string(),\n-            }),\n-        ))\n-    }\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub async fn run(host: &str, port: u16, db_path: &str, token: &str) -> Result<()> {\n     run_with_shutdown(host, port, db_path, token, futures::future::pending::<()>()).await\n }\n \n pub async fn run_with_shutdown<F>(\n     host: &str,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "authorize",
      "return_type": "-> std::result::Result<(), (StatusCode, Json<ErrorResponse>)>",
      "span": {
        "end": {
          "column": 2,
          "line": 1646
        },
        "start": {
          "column": 1,
          "line": 1611
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1615:5: replace authorize -> std::result::Result<(), (StatusCode, Json<ErrorResponse>)> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 6,
        "line": 1645
      },
      "start": {
        "column": 5,
        "line": 1615
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace || with && in authorize\n@@ -1628,17 +1628,17 @@\n         .unwrap_or_default();\n     let api_key = headers\n         .get(\"x-api-key\")\n         .and_then(|value| value.to_str().ok())\n         .unwrap_or_default();\n     let bearer = header.strip_prefix(\"Bearer \").unwrap_or(\"\").trim();\n     let api_key = api_key.trim();\n \n-    if bearer == expected_token || api_key == expected_token {\n+    if bearer == expected_token && /* ~ changed by cargo-mutants ~ */ api_key == expected_token {\n         Ok(())\n     } else {\n         Err((\n             StatusCode::UNAUTHORIZED,\n             Json(ErrorResponse {\n                 error: \"Unauthorized\".to_string(),\n             }),\n         ))\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "authorize",
      "return_type": "-> std::result::Result<(), (StatusCode, Json<ErrorResponse>)>",
      "span": {
        "end": {
          "column": 2,
          "line": 1646
        },
        "start": {
          "column": 1,
          "line": 1611
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1636:33: replace || with && in authorize",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 35,
        "line": 1636
      },
      "start": {
        "column": 33,
        "line": 1636
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in authorize\n@@ -1628,17 +1628,17 @@\n         .unwrap_or_default();\n     let api_key = headers\n         .get(\"x-api-key\")\n         .and_then(|value| value.to_str().ok())\n         .unwrap_or_default();\n     let bearer = header.strip_prefix(\"Bearer \").unwrap_or(\"\").trim();\n     let api_key = api_key.trim();\n \n-    if bearer == expected_token || api_key == expected_token {\n+    if bearer != /* ~ changed by cargo-mutants ~ */ expected_token || api_key == expected_token {\n         Ok(())\n     } else {\n         Err((\n             StatusCode::UNAUTHORIZED,\n             Json(ErrorResponse {\n                 error: \"Unauthorized\".to_string(),\n             }),\n         ))\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "authorize",
      "return_type": "-> std::result::Result<(), (StatusCode, Json<ErrorResponse>)>",
      "span": {
        "end": {
          "column": 2,
          "line": 1646
        },
        "start": {
          "column": 1,
          "line": 1611
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1636:15: replace == with != in authorize",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 17,
        "line": 1636
      },
      "start": {
        "column": 15,
        "line": 1636
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace == with != in authorize\n@@ -1628,17 +1628,17 @@\n         .unwrap_or_default();\n     let api_key = headers\n         .get(\"x-api-key\")\n         .and_then(|value| value.to_str().ok())\n         .unwrap_or_default();\n     let bearer = header.strip_prefix(\"Bearer \").unwrap_or(\"\").trim();\n     let api_key = api_key.trim();\n \n-    if bearer == expected_token || api_key == expected_token {\n+    if bearer == expected_token || api_key != /* ~ changed by cargo-mutants ~ */ expected_token {\n         Ok(())\n     } else {\n         Err((\n             StatusCode::UNAUTHORIZED,\n             Json(ErrorResponse {\n                 error: \"Unauthorized\".to_string(),\n             }),\n         ))\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "authorize",
      "return_type": "-> std::result::Result<(), (StatusCode, Json<ErrorResponse>)>",
      "span": {
        "end": {
          "column": 2,
          "line": 1646
        },
        "start": {
          "column": 1,
          "line": 1611
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1636:44: replace == with != in authorize",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 46,
        "line": 1636
      },
      "start": {
        "column": 44,
        "line": 1636
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace run -> Result<()> with Ok(())\n@@ -1641,17 +1641,17 @@\n             Json(ErrorResponse {\n                 error: \"Unauthorized\".to_string(),\n             }),\n         ))\n     }\n }\n \n pub async fn run(host: &str, port: u16, db_path: &str, token: &str) -> Result<()> {\n-    run_with_shutdown(host, port, db_path, token, futures::future::pending::<()>()).await\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub async fn run_with_shutdown<F>(\n     host: &str,\n     port: u16,\n     db_path: &str,\n     token: &str,\n     shutdown: F,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 1650
        },
        "start": {
          "column": 1,
          "line": 1648
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1649:5: replace run -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 90,
        "line": 1649
      },
      "start": {
        "column": 5,
        "line": 1649
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace run_with_shutdown -> Result<()> with Ok(())\n@@ -1654,162 +1654,17 @@\n     port: u16,\n     db_path: &str,\n     token: &str,\n     shutdown: F,\n ) -> Result<()>\n where\n     F: Future<Output = ()> + Send + 'static,\n {\n-    crate::security::hardening::run_startup_self_check()?;\n-\n-    let wasm_dir = crate::wasm_bundle::ensure_bundled_wasm_tools()?;\n-    tracing::info!(\n-        wasm_dir = %wasm_dir.to_string_lossy(),\n-        \"Ensured bundled WASM tool modules\"\n-    );\n-\n-    if Config::from_store(db_path).is_err() {\n-        tracing::warn!(\"No config in store; writing default config for {}\", db_path);\n-        let default_config = Config::convention_defaults(db_path);\n-        config_store::save_config(db_path, &default_config)?;\n-    }\n-\n-    let config = Config::from_store(db_path).ok();\n-\n-    //  Log which context/heartbeat source the daemon sees \n-    if let Some(cfg) = &config {\n-        tracing::info!(\n-            \"Daemon config: prompt_source={:?}, heartbeat_source={:?}\",\n-            cfg.prompt_source,\n-            cfg.heartbeat_source\n-        );\n-    } else {\n-        tracing::error!(\"Daemon could not load any config from store!\");\n-    }\n-\n-    let tick_seconds = config\n-        .as_ref()\n-        .and_then(|cfg| cfg.brains.as_ref())\n-        .and_then(|brains| brains.get(\"settings\"))\n-        .and_then(|settings| settings.get(\"tick_seconds\"))\n-        .and_then(|value| value.as_u64())\n-        .unwrap_or(60);\n-\n-    let (ui_event_tx, _) = broadcast::channel(256);\n-    if let Some(path) = ui_event_log_path(config.as_ref()) {\n-        let mut rx = ui_event_tx.subscribe();\n-        let path = path.clone();\n-        tokio::spawn(async move {\n-            loop {\n-                match rx.recv().await {\n-                    Ok(event) => {\n-                        let _ = write_ui_event_log(&path, &event);\n-                    }\n-                    Err(broadcast::error::RecvError::Lagged(_)) => {\n-                        continue;\n-                    }\n-                    Err(broadcast::error::RecvError::Closed) => break,\n-                }\n-            }\n-        });\n-    }\n-    let agent = Arc::new(RwLock::new(Arc::new(\n-        ButterflyBot::from_store_with_events(db_path, Some(ui_event_tx.clone())).await?,\n-    )));\n-    let reminder_db_path = config\n-        .as_ref()\n-        .and_then(|cfg| serde_json::to_value(cfg).ok())\n-        .and_then(|value| resolve_reminder_db_path(&value))\n-        .unwrap_or_else(|| db_path.to_string());\n-    let reminder_store = Arc::new(ReminderStore::new(reminder_db_path).await?);\n-    let task_store = Arc::new(TaskStore::new(db_path).await?);\n-    let wakeup_store = Arc::new(WakeupStore::new(db_path).await?);\n-    let mut scheduler = Scheduler::new();\n-    scheduler.register_job(Arc::new(BrainTickJob {\n-        agent: agent.clone(),\n-        interval: Duration::from_secs(tick_seconds.max(1)),\n-    }));\n-    let wakeup_poll_seconds = config\n-        .as_ref()\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"wakeup\"))\n-        .and_then(|wakeup| wakeup.get(\"poll_seconds\"))\n-        .and_then(|value| value.as_u64())\n-        .unwrap_or(60);\n-    let autonomy_cooldown_seconds = config\n-        .as_ref()\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| {\n-            tools\n-                .get(\"settings\")\n-                .and_then(|settings| settings.get(\"autonomy_cooldown_seconds\"))\n-                .and_then(|value| value.as_u64())\n-                .or_else(|| {\n-                    tools\n-                        .get(\"wakeup\")\n-                        .and_then(|wakeup| wakeup.get(\"autonomy_cooldown_seconds\"))\n-                        .and_then(|value| value.as_u64())\n-                })\n-        })\n-        .unwrap_or(60);\n-    set_autonomy_cooldown_seconds(autonomy_cooldown_seconds);\n-    scheduler.register_job(Arc::new(WakeupJob {\n-        agent: agent.clone(),\n-        store: wakeup_store.clone(),\n-        interval: Duration::from_secs(wakeup_poll_seconds.max(1)),\n-        ui_event_tx: ui_event_tx.clone(),\n-        audit_log_path: wakeup_audit_log_path(config.as_ref()),\n-        heartbeat_source: config\n-            .as_ref()\n-            .map(|cfg| cfg.heartbeat_source.clone())\n-            .unwrap_or_else(crate::config::MarkdownSource::default_heartbeat),\n-        db_path: db_path.to_string(),\n-    }));\n-    let tasks_poll_seconds = config\n-        .as_ref()\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"tasks\"))\n-        .and_then(|tasks| tasks.get(\"poll_seconds\"))\n-        .and_then(|value| value.as_u64())\n-        .unwrap_or(60);\n-    scheduler.register_job(Arc::new(ScheduledTasksJob {\n-        agent: agent.clone(),\n-        store: task_store.clone(),\n-        interval: Duration::from_secs(tasks_poll_seconds.max(1)),\n-        ui_event_tx: ui_event_tx.clone(),\n-        audit_log_path: tasks_audit_log_path(config.as_ref()),\n-    }));\n-    scheduler.start();\n-\n-    let state = AppState {\n-        agent,\n-        reminder_store,\n-        signer_service: SignerService::default(),\n-        token: token.to_string(),\n-        ui_event_tx,\n-        db_path: db_path.to_string(),\n-    };\n-    let app = build_router(state);\n-\n-    let addr = format!(\"{host}:{port}\");\n-    let listener = tokio::net::TcpListener::bind(&addr)\n-        .await\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    let shutdown = async move {\n-        shutdown.await;\n-        scheduler.stop().await;\n-    };\n-\n-    axum::serve(listener, app)\n-        .with_graceful_shutdown(shutdown)\n-        .await\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n async fn run_autonomy_tick(\n     agent: Arc<crate::client::ButterflyBot>,\n     ui_event_tx: broadcast::Sender<UiEvent>,\n     user_id: String,\n     source: &str,\n ) {\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_with_shutdown",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 1808
        },
        "start": {
          "column": 1,
          "line": 1652
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1662:5: replace run_with_shutdown -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 1807
      },
      "start": {
        "column": 5,
        "line": 1662
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace run_autonomy_tick with ()\n@@ -1808,107 +1808,17 @@\n }\n \n async fn run_autonomy_tick(\n     agent: Arc<crate::client::ButterflyBot>,\n     ui_event_tx: broadcast::Sender<UiEvent>,\n     user_id: String,\n     source: &str,\n ) {\n-    let run_at = now_ts();\n-    if let Some(remaining) = try_begin_autonomy_tick(run_at) {\n-        let _ = ui_event_tx.send(UiEvent {\n-            event_type: \"autonomy\".to_string(),\n-            user_id,\n-            tool: \"heartbeat\".to_string(),\n-            status: \"skipped\".to_string(),\n-            payload: json!({\n-                \"source\": source,\n-                \"reason\": \"cooldown\",\n-                \"cooldown_remaining_seconds\": remaining,\n-            }),\n-            timestamp: run_at,\n-        });\n-        return;\n-    }\n-\n-    let _ = ui_event_tx.send(UiEvent {\n-        event_type: \"autonomy\".to_string(),\n-        user_id: user_id.clone(),\n-        tool: \"heartbeat\".to_string(),\n-        status: \"started\".to_string(),\n-        payload: json!({\"source\": source}),\n-        timestamp: run_at,\n-    });\n-\n-    let options = ProcessOptions {\n-        prompt: Some(\n-            \"AUTONOMY MODE: Heartbeat tick.\\n\\\n-    Run autonomous checks/actions as needed using tools.\\n\\\n-    Output requirements:\\n\\\n-    - Return ONLY one short final status line (max 120 chars).\\n\\\n-    - Do NOT include Thought, Plan, Action, Observation, Summary, or Reasoning sections.\\n\\\n-    - Do NOT dump tool call details.\\n\\\n-    - Good outputs: 'No-op', 'Processed 2 due tasks', 'Updated plans/todos; no urgent actions'.\"\n-                .to_string(),\n-        ),\n-        images: Vec::new(),\n-        output_format: OutputFormat::Text,\n-        image_detail: \"auto\".to_string(),\n-        json_schema: None,\n-    };\n-    let result = tokio::time::timeout(Duration::from_secs(120), async {\n-        agent\n-            .process(\n-                &user_id,\n-                UserInput::Text(\"Autonomous heartbeat tick\".to_string()),\n-                options,\n-            )\n-            .await\n-    })\n-    .await;\n-\n-    let (status, payload): (String, serde_json::Value) = match result {\n-        Ok(Ok(ProcessResult::Text(text))) => {\n-            let trimmed = text.trim();\n-            let status = if trimmed.is_empty()\n-                || trimmed.eq_ignore_ascii_case(\"no-op\")\n-                || trimmed.eq_ignore_ascii_case(\"noop\")\n-            {\n-                \"no-op\"\n-            } else {\n-                \"ok\"\n-            };\n-            (\n-                status.to_string(),\n-                json!({\"output\": text, \"source\": source}),\n-            )\n-        }\n-        Ok(Ok(_)) => (\n-            \"error\".to_string(),\n-            json!({\"error\": \"Unexpected non-text response\", \"source\": source}),\n-        ),\n-        Ok(Err(err)) => (\n-            \"error\".to_string(),\n-            json!({\"error\": err.to_string(), \"source\": source}),\n-        ),\n-        Err(_) => (\n-            \"error\".to_string(),\n-            json!({\"error\": \"autonomy timeout\", \"source\": source}),\n-        ),\n-    };\n-\n-    let _ = ui_event_tx.send(UiEvent {\n-        event_type: \"autonomy\".to_string(),\n-        user_id,\n-        tool: \"heartbeat\".to_string(),\n-        status,\n-        payload,\n-        timestamp: now_ts(),\n-    });\n+    () /* ~ changed by cargo-mutants ~ */\n }\n \n fn now_ts() -> i64 {\n     SystemTime::now()\n         .duration_since(UNIX_EPOCH)\n         .unwrap_or_default()\n         .as_secs() as i64\n }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_autonomy_tick",
      "return_type": "",
      "span": {
        "end": {
          "column": 2,
          "line": 1907
        },
        "start": {
          "column": 1,
          "line": 1810
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1816:5: replace run_autonomy_tick with ()",
    "package": "butterfly-bot",
    "replacement": "()",
    "span": {
      "end": {
        "column": 8,
        "line": 1906
      },
      "start": {
        "column": 5,
        "line": 1816
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace || with && in run_autonomy_tick\n@@ -1866,17 +1866,17 @@\n     })\n     .await;\n \n     let (status, payload): (String, serde_json::Value) = match result {\n         Ok(Ok(ProcessResult::Text(text))) => {\n             let trimmed = text.trim();\n             let status = if trimmed.is_empty()\n                 || trimmed.eq_ignore_ascii_case(\"no-op\")\n-                || trimmed.eq_ignore_ascii_case(\"noop\")\n+                && /* ~ changed by cargo-mutants ~ */ trimmed.eq_ignore_ascii_case(\"noop\")\n             {\n                 \"no-op\"\n             } else {\n                 \"ok\"\n             };\n             (\n                 status.to_string(),\n                 json!({\"output\": text, \"source\": source}),\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_autonomy_tick",
      "return_type": "",
      "span": {
        "end": {
          "column": 2,
          "line": 1907
        },
        "start": {
          "column": 1,
          "line": 1810
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1874:17: replace || with && in run_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 19,
        "line": 1874
      },
      "start": {
        "column": 17,
        "line": 1874
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace || with && in run_autonomy_tick\n@@ -1865,17 +1865,17 @@\n             .await\n     })\n     .await;\n \n     let (status, payload): (String, serde_json::Value) = match result {\n         Ok(Ok(ProcessResult::Text(text))) => {\n             let trimmed = text.trim();\n             let status = if trimmed.is_empty()\n-                || trimmed.eq_ignore_ascii_case(\"no-op\")\n+                && /* ~ changed by cargo-mutants ~ */ trimmed.eq_ignore_ascii_case(\"no-op\")\n                 || trimmed.eq_ignore_ascii_case(\"noop\")\n             {\n                 \"no-op\"\n             } else {\n                 \"ok\"\n             };\n             (\n                 status.to_string(),\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "run_autonomy_tick",
      "return_type": "",
      "span": {
        "end": {
          "column": 2,
          "line": 1907
        },
        "start": {
          "column": 1,
          "line": 1810
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/daemon.rs:1873:17: replace || with && in run_autonomy_tick",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 19,
        "line": 1873
      },
      "start": {
        "column": 17,
        "line": 1873
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace now_ts -> i64 with 0\n@@ -1902,20 +1902,17 @@\n         tool: \"heartbeat\".to_string(),\n         status,\n         payload,\n         timestamp: now_ts(),\n     });\n }\n \n fn now_ts() -> i64 {\n-    SystemTime::now()\n-        .duration_since(UNIX_EPOCH)\n-        .unwrap_or_default()\n-        .as_secs() as i64\n+    0 /* ~ changed by cargo-mutants ~ */\n }\n \n fn wakeup_audit_log_path(config: Option<&Config>) -> Option<String> {\n     let path = config\n         .and_then(|cfg| cfg.tools.as_ref())\n         .and_then(|tools| tools.get(\"wakeup\"))\n         .and_then(|wakeup| wakeup.get(\"audit_log_path\"))\n         .and_then(|value| value.as_str())\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "now_ts",
      "return_type": "-> i64",
      "span": {
        "end": {
          "column": 2,
          "line": 1914
        },
        "start": {
          "column": 1,
          "line": 1909
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1910:5: replace now_ts -> i64 with 0",
    "package": "butterfly-bot",
    "replacement": "0",
    "span": {
      "end": {
        "column": 26,
        "line": 1913
      },
      "start": {
        "column": 5,
        "line": 1910
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace now_ts -> i64 with 1\n@@ -1902,20 +1902,17 @@\n         tool: \"heartbeat\".to_string(),\n         status,\n         payload,\n         timestamp: now_ts(),\n     });\n }\n \n fn now_ts() -> i64 {\n-    SystemTime::now()\n-        .duration_since(UNIX_EPOCH)\n-        .unwrap_or_default()\n-        .as_secs() as i64\n+    1 /* ~ changed by cargo-mutants ~ */\n }\n \n fn wakeup_audit_log_path(config: Option<&Config>) -> Option<String> {\n     let path = config\n         .and_then(|cfg| cfg.tools.as_ref())\n         .and_then(|tools| tools.get(\"wakeup\"))\n         .and_then(|wakeup| wakeup.get(\"audit_log_path\"))\n         .and_then(|value| value.as_str())\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "now_ts",
      "return_type": "-> i64",
      "span": {
        "end": {
          "column": 2,
          "line": 1914
        },
        "start": {
          "column": 1,
          "line": 1909
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1910:5: replace now_ts -> i64 with 1",
    "package": "butterfly-bot",
    "replacement": "1",
    "span": {
      "end": {
        "column": 26,
        "line": 1913
      },
      "start": {
        "column": 5,
        "line": 1910
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace now_ts -> i64 with -1\n@@ -1902,20 +1902,17 @@\n         tool: \"heartbeat\".to_string(),\n         status,\n         payload,\n         timestamp: now_ts(),\n     });\n }\n \n fn now_ts() -> i64 {\n-    SystemTime::now()\n-        .duration_since(UNIX_EPOCH)\n-        .unwrap_or_default()\n-        .as_secs() as i64\n+    -1 /* ~ changed by cargo-mutants ~ */\n }\n \n fn wakeup_audit_log_path(config: Option<&Config>) -> Option<String> {\n     let path = config\n         .and_then(|cfg| cfg.tools.as_ref())\n         .and_then(|tools| tools.get(\"wakeup\"))\n         .and_then(|wakeup| wakeup.get(\"audit_log_path\"))\n         .and_then(|value| value.as_str())\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "now_ts",
      "return_type": "-> i64",
      "span": {
        "end": {
          "column": 2,
          "line": 1914
        },
        "start": {
          "column": 1,
          "line": 1909
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1910:5: replace now_ts -> i64 with -1",
    "package": "butterfly-bot",
    "replacement": "-1",
    "span": {
      "end": {
        "column": 26,
        "line": 1913
      },
      "start": {
        "column": 5,
        "line": 1910
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace wakeup_audit_log_path -> Option<String> with None\n@@ -1909,25 +1909,17 @@\n fn now_ts() -> i64 {\n     SystemTime::now()\n         .duration_since(UNIX_EPOCH)\n         .unwrap_or_default()\n         .as_secs() as i64\n }\n \n fn wakeup_audit_log_path(config: Option<&Config>) -> Option<String> {\n-    let path = config\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"wakeup\"))\n-        .and_then(|wakeup| wakeup.get(\"audit_log_path\"))\n-        .and_then(|value| value.as_str())\n-        .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n-        .or_else(|| Some(\"./data/wakeup_audit.log\".to_string()));\n-    path\n+    None /* ~ changed by cargo-mutants ~ */\n }\n \n fn write_wakeup_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::wakeup::WakeupTask,\n     status: &str,\n     payload: serde_json::Value,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "wakeup_audit_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1926
        },
        "start": {
          "column": 1,
          "line": 1916
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1917:5: replace wakeup_audit_log_path -> Option<String> with None",
    "package": "butterfly-bot",
    "replacement": "None",
    "span": {
      "end": {
        "column": 9,
        "line": 1925
      },
      "start": {
        "column": 5,
        "line": 1917
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace wakeup_audit_log_path -> Option<String> with Some(String::new())\n@@ -1909,25 +1909,17 @@\n fn now_ts() -> i64 {\n     SystemTime::now()\n         .duration_since(UNIX_EPOCH)\n         .unwrap_or_default()\n         .as_secs() as i64\n }\n \n fn wakeup_audit_log_path(config: Option<&Config>) -> Option<String> {\n-    let path = config\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"wakeup\"))\n-        .and_then(|wakeup| wakeup.get(\"audit_log_path\"))\n-        .and_then(|value| value.as_str())\n-        .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n-        .or_else(|| Some(\"./data/wakeup_audit.log\".to_string()));\n-    path\n+    Some(String::new()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn write_wakeup_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::wakeup::WakeupTask,\n     status: &str,\n     payload: serde_json::Value,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "wakeup_audit_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1926
        },
        "start": {
          "column": 1,
          "line": 1916
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1917:5: replace wakeup_audit_log_path -> Option<String> with Some(String::new())",
    "package": "butterfly-bot",
    "replacement": "Some(String::new())",
    "span": {
      "end": {
        "column": 9,
        "line": 1925
      },
      "start": {
        "column": 5,
        "line": 1917
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace wakeup_audit_log_path -> Option<String> with Some(\"xyzzy\".into())\n@@ -1909,25 +1909,17 @@\n fn now_ts() -> i64 {\n     SystemTime::now()\n         .duration_since(UNIX_EPOCH)\n         .unwrap_or_default()\n         .as_secs() as i64\n }\n \n fn wakeup_audit_log_path(config: Option<&Config>) -> Option<String> {\n-    let path = config\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"wakeup\"))\n-        .and_then(|wakeup| wakeup.get(\"audit_log_path\"))\n-        .and_then(|value| value.as_str())\n-        .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n-        .or_else(|| Some(\"./data/wakeup_audit.log\".to_string()));\n-    path\n+    Some(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn write_wakeup_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::wakeup::WakeupTask,\n     status: &str,\n     payload: serde_json::Value,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "wakeup_audit_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1926
        },
        "start": {
          "column": 1,
          "line": 1916
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1917:5: replace wakeup_audit_log_path -> Option<String> with Some(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Some(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 9,
        "line": 1925
      },
      "start": {
        "column": 5,
        "line": 1917
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in wakeup_audit_log_path\n@@ -1915,17 +1915,17 @@\n \n fn wakeup_audit_log_path(config: Option<&Config>) -> Option<String> {\n     let path = config\n         .and_then(|cfg| cfg.tools.as_ref())\n         .and_then(|tools| tools.get(\"wakeup\"))\n         .and_then(|wakeup| wakeup.get(\"audit_log_path\"))\n         .and_then(|value| value.as_str())\n         .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n+        .filter(|value|  /* ~ changed by cargo-mutants ~ */value.is_empty())\n         .or_else(|| Some(\"./data/wakeup_audit.log\".to_string()));\n     path\n }\n \n fn write_wakeup_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::wakeup::WakeupTask,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "wakeup_audit_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1926
        },
        "start": {
          "column": 1,
          "line": 1916
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:1923:25: delete ! in wakeup_audit_log_path",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 26,
        "line": 1923
      },
      "start": {
        "column": 25,
        "line": 1923
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace write_wakeup_audit_log -> Result<()> with Ok(())\n@@ -1927,39 +1927,17 @@\n \n fn write_wakeup_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::wakeup::WakeupTask,\n     status: &str,\n     payload: serde_json::Value,\n ) -> Result<()> {\n-    let Some(path) = path else {\n-        return Ok(());\n-    };\n-    config_store::ensure_parent_dir(path)?;\n-    let mut file = std::fs::OpenOptions::new()\n-        .create(true)\n-        .append(true)\n-        .open(path)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    let entry = serde_json::json!({\n-        \"timestamp\": ts,\n-        \"task_id\": task.id,\n-        \"user_id\": task.user_id,\n-        \"name\": task.name,\n-        \"prompt\": task.prompt,\n-        \"status\": status,\n-        \"payload\": payload,\n-    });\n-    let line = serde_json::to_string(&entry)\n-        .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n-    use std::io::Write;\n-    writeln!(file, \"{line}\").map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn ui_event_log_path(config: Option<&Config>) -> Option<String> {\n     config\n         .and_then(|cfg| cfg.tools.as_ref())\n         .and_then(|tools| tools.get(\"settings\"))\n         .and_then(|settings| settings.get(\"ui_event_log_path\"))\n         .and_then(|value| value.as_str())\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "write_wakeup_audit_log",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 1958
        },
        "start": {
          "column": 1,
          "line": 1928
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1935:5: replace write_wakeup_audit_log -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 1957
      },
      "start": {
        "column": 5,
        "line": 1935
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace ui_event_log_path -> Option<String> with None\n@@ -1953,24 +1953,17 @@\n     let line = serde_json::to_string(&entry)\n         .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n     use std::io::Write;\n     writeln!(file, \"{line}\").map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(())\n }\n \n fn ui_event_log_path(config: Option<&Config>) -> Option<String> {\n-    config\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"settings\"))\n-        .and_then(|settings| settings.get(\"ui_event_log_path\"))\n-        .and_then(|value| value.as_str())\n-        .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n-        .or_else(|| Some(\"./data/ui_events.log\".to_string()))\n+    None /* ~ changed by cargo-mutants ~ */\n }\n \n fn write_ui_event_log(path: &str, event: &UiEvent) -> Result<()> {\n     config_store::ensure_parent_dir(path)?;\n     let payload = serde_json::to_string(event)\n         .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n     let mut file = std::fs::OpenOptions::new()\n         .create(true)\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "ui_event_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1969
        },
        "start": {
          "column": 1,
          "line": 1960
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1961:5: replace ui_event_log_path -> Option<String> with None",
    "package": "butterfly-bot",
    "replacement": "None",
    "span": {
      "end": {
        "column": 62,
        "line": 1968
      },
      "start": {
        "column": 5,
        "line": 1961
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace ui_event_log_path -> Option<String> with Some(String::new())\n@@ -1953,24 +1953,17 @@\n     let line = serde_json::to_string(&entry)\n         .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n     use std::io::Write;\n     writeln!(file, \"{line}\").map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(())\n }\n \n fn ui_event_log_path(config: Option<&Config>) -> Option<String> {\n-    config\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"settings\"))\n-        .and_then(|settings| settings.get(\"ui_event_log_path\"))\n-        .and_then(|value| value.as_str())\n-        .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n-        .or_else(|| Some(\"./data/ui_events.log\".to_string()))\n+    Some(String::new()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn write_ui_event_log(path: &str, event: &UiEvent) -> Result<()> {\n     config_store::ensure_parent_dir(path)?;\n     let payload = serde_json::to_string(event)\n         .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n     let mut file = std::fs::OpenOptions::new()\n         .create(true)\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "ui_event_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1969
        },
        "start": {
          "column": 1,
          "line": 1960
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1961:5: replace ui_event_log_path -> Option<String> with Some(String::new())",
    "package": "butterfly-bot",
    "replacement": "Some(String::new())",
    "span": {
      "end": {
        "column": 62,
        "line": 1968
      },
      "start": {
        "column": 5,
        "line": 1961
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace ui_event_log_path -> Option<String> with Some(\"xyzzy\".into())\n@@ -1953,24 +1953,17 @@\n     let line = serde_json::to_string(&entry)\n         .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n     use std::io::Write;\n     writeln!(file, \"{line}\").map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(())\n }\n \n fn ui_event_log_path(config: Option<&Config>) -> Option<String> {\n-    config\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"settings\"))\n-        .and_then(|settings| settings.get(\"ui_event_log_path\"))\n-        .and_then(|value| value.as_str())\n-        .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n-        .or_else(|| Some(\"./data/ui_events.log\".to_string()))\n+    Some(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn write_ui_event_log(path: &str, event: &UiEvent) -> Result<()> {\n     config_store::ensure_parent_dir(path)?;\n     let payload = serde_json::to_string(event)\n         .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n     let mut file = std::fs::OpenOptions::new()\n         .create(true)\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "ui_event_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1969
        },
        "start": {
          "column": 1,
          "line": 1960
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1961:5: replace ui_event_log_path -> Option<String> with Some(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Some(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 62,
        "line": 1968
      },
      "start": {
        "column": 5,
        "line": 1961
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in ui_event_log_path\n@@ -1959,17 +1959,17 @@\n \n fn ui_event_log_path(config: Option<&Config>) -> Option<String> {\n     config\n         .and_then(|cfg| cfg.tools.as_ref())\n         .and_then(|tools| tools.get(\"settings\"))\n         .and_then(|settings| settings.get(\"ui_event_log_path\"))\n         .and_then(|value| value.as_str())\n         .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n+        .filter(|value|  /* ~ changed by cargo-mutants ~ */value.is_empty())\n         .or_else(|| Some(\"./data/ui_events.log\".to_string()))\n }\n \n fn write_ui_event_log(path: &str, event: &UiEvent) -> Result<()> {\n     config_store::ensure_parent_dir(path)?;\n     let payload = serde_json::to_string(event)\n         .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n     let mut file = std::fs::OpenOptions::new()\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "ui_event_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1969
        },
        "start": {
          "column": 1,
          "line": 1960
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:1967:25: delete ! in ui_event_log_path",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 26,
        "line": 1967
      },
      "start": {
        "column": 25,
        "line": 1967
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace write_ui_event_log -> Result<()> with Ok(())\n@@ -1964,26 +1964,17 @@\n         .and_then(|settings| settings.get(\"ui_event_log_path\"))\n         .and_then(|value| value.as_str())\n         .map(|value| value.trim().to_string())\n         .filter(|value| !value.is_empty())\n         .or_else(|| Some(\"./data/ui_events.log\".to_string()))\n }\n \n fn write_ui_event_log(path: &str, event: &UiEvent) -> Result<()> {\n-    config_store::ensure_parent_dir(path)?;\n-    let payload = serde_json::to_string(event)\n-        .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n-    let mut file = std::fs::OpenOptions::new()\n-        .create(true)\n-        .append(true)\n-        .open(path)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    writeln!(file, \"{}\", payload).map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn tasks_audit_log_path(config: Option<&Config>) -> Option<String> {\n     let path = config\n         .and_then(|cfg| cfg.tools.as_ref())\n         .and_then(|tools| tools.get(\"tasks\"))\n         .and_then(|tasks| tasks.get(\"audit_log_path\"))\n         .and_then(|value| value.as_str())\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "write_ui_event_log",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 1982
        },
        "start": {
          "column": 1,
          "line": 1971
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1972:5: replace write_ui_event_log -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 1981
      },
      "start": {
        "column": 5,
        "line": 1972
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace tasks_audit_log_path -> Option<String> with None\n@@ -1977,25 +1977,17 @@\n         .append(true)\n         .open(path)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     writeln!(file, \"{}\", payload).map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(())\n }\n \n fn tasks_audit_log_path(config: Option<&Config>) -> Option<String> {\n-    let path = config\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"tasks\"))\n-        .and_then(|tasks| tasks.get(\"audit_log_path\"))\n-        .and_then(|value| value.as_str())\n-        .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n-        .or_else(|| Some(\"./data/tasks_audit.log\".to_string()));\n-    path\n+    None /* ~ changed by cargo-mutants ~ */\n }\n \n fn write_tasks_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::tasks::ScheduledTask,\n     status: &str,\n     payload: serde_json::Value,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "tasks_audit_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1994
        },
        "start": {
          "column": 1,
          "line": 1984
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1985:5: replace tasks_audit_log_path -> Option<String> with None",
    "package": "butterfly-bot",
    "replacement": "None",
    "span": {
      "end": {
        "column": 9,
        "line": 1993
      },
      "start": {
        "column": 5,
        "line": 1985
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace tasks_audit_log_path -> Option<String> with Some(String::new())\n@@ -1977,25 +1977,17 @@\n         .append(true)\n         .open(path)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     writeln!(file, \"{}\", payload).map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(())\n }\n \n fn tasks_audit_log_path(config: Option<&Config>) -> Option<String> {\n-    let path = config\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"tasks\"))\n-        .and_then(|tasks| tasks.get(\"audit_log_path\"))\n-        .and_then(|value| value.as_str())\n-        .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n-        .or_else(|| Some(\"./data/tasks_audit.log\".to_string()));\n-    path\n+    Some(String::new()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn write_tasks_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::tasks::ScheduledTask,\n     status: &str,\n     payload: serde_json::Value,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "tasks_audit_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1994
        },
        "start": {
          "column": 1,
          "line": 1984
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1985:5: replace tasks_audit_log_path -> Option<String> with Some(String::new())",
    "package": "butterfly-bot",
    "replacement": "Some(String::new())",
    "span": {
      "end": {
        "column": 9,
        "line": 1993
      },
      "start": {
        "column": 5,
        "line": 1985
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace tasks_audit_log_path -> Option<String> with Some(\"xyzzy\".into())\n@@ -1977,25 +1977,17 @@\n         .append(true)\n         .open(path)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     writeln!(file, \"{}\", payload).map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(())\n }\n \n fn tasks_audit_log_path(config: Option<&Config>) -> Option<String> {\n-    let path = config\n-        .and_then(|cfg| cfg.tools.as_ref())\n-        .and_then(|tools| tools.get(\"tasks\"))\n-        .and_then(|tasks| tasks.get(\"audit_log_path\"))\n-        .and_then(|value| value.as_str())\n-        .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n-        .or_else(|| Some(\"./data/tasks_audit.log\".to_string()));\n-    path\n+    Some(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn write_tasks_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::tasks::ScheduledTask,\n     status: &str,\n     payload: serde_json::Value,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "tasks_audit_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1994
        },
        "start": {
          "column": 1,
          "line": 1984
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:1985:5: replace tasks_audit_log_path -> Option<String> with Some(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Some(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 9,
        "line": 1993
      },
      "start": {
        "column": 5,
        "line": 1985
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ delete ! in tasks_audit_log_path\n@@ -1983,17 +1983,17 @@\n \n fn tasks_audit_log_path(config: Option<&Config>) -> Option<String> {\n     let path = config\n         .and_then(|cfg| cfg.tools.as_ref())\n         .and_then(|tools| tools.get(\"tasks\"))\n         .and_then(|tasks| tasks.get(\"audit_log_path\"))\n         .and_then(|value| value.as_str())\n         .map(|value| value.trim().to_string())\n-        .filter(|value| !value.is_empty())\n+        .filter(|value|  /* ~ changed by cargo-mutants ~ */value.is_empty())\n         .or_else(|| Some(\"./data/tasks_audit.log\".to_string()));\n     path\n }\n \n fn write_tasks_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::tasks::ScheduledTask,\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "tasks_audit_log_path",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 1994
        },
        "start": {
          "column": 1,
          "line": 1984
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/daemon.rs:1991:25: delete ! in tasks_audit_log_path",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 26,
        "line": 1991
      },
      "start": {
        "column": 25,
        "line": 1991
      }
    }
  },
  {
    "diff": "--- src/daemon.rs\n+++ replace write_tasks_audit_log -> Result<()> with Ok(())\n@@ -1995,34 +1995,10 @@\n \n fn write_tasks_audit_log(\n     path: Option<&str>,\n     ts: i64,\n     task: &crate::tasks::ScheduledTask,\n     status: &str,\n     payload: serde_json::Value,\n ) -> Result<()> {\n-    let Some(path) = path else {\n-        return Ok(());\n-    };\n-    config_store::ensure_parent_dir(path)?;\n-    let mut file = std::fs::OpenOptions::new()\n-        .create(true)\n-        .append(true)\n-        .open(path)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    let entry = serde_json::json!({\n-        \"timestamp\": ts,\n-        \"task_id\": task.id,\n-        \"user_id\": task.user_id,\n-        \"name\": task.name,\n-        \"prompt\": task.prompt,\n-        \"run_at\": task.run_at,\n-        \"interval_minutes\": task.interval_minutes,\n-        \"status\": status,\n-        \"payload\": payload,\n-    });\n-    let line = serde_json::to_string(&entry)\n-        .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n-    use std::io::Write;\n-    writeln!(file, \"{line}\").map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n",
    "file": "src/daemon.rs",
    "function": {
      "function_name": "write_tasks_audit_log",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 2028
        },
        "start": {
          "column": 1,
          "line": 1996
        }
      }
    },
    "genre": "FnValue",
    "name": "src/daemon.rs:2003:5: replace write_tasks_audit_log -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 2027
      },
      "start": {
        "column": 5,
        "line": 2003
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ replace tune_sqlcipher_log_level_sync with ()\n@@ -6,21 +6,17 @@\n use rand::rngs::SysRng;\n use rand::TryRng;\n \n use crate::error::{ButterflyBotError, Result};\n \n const DB_KEY_NAME: &str = \"db_encryption_key\";\n \n fn tune_sqlcipher_log_level_sync(conn: &mut SqliteConnection) {\n-    if let Err(err) =\n-        diesel::RunQueryDsl::execute(diesel::sql_query(\"PRAGMA cipher_log_level = ERROR\"), conn)\n-    {\n-        tracing::debug!(\"Unable to set SQLCipher log level (sync): {}\", err);\n-    }\n+    () /* ~ changed by cargo-mutants ~ */\n }\n \n async fn tune_sqlcipher_log_level_async(conn: &mut SyncConnectionWrapper<SqliteConnection>) {\n     if let Err(err) = diesel_async::RunQueryDsl::execute(\n         diesel::sql_query(\"PRAGMA cipher_log_level = ERROR\"),\n         conn,\n     )\n     .await\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "tune_sqlcipher_log_level_sync",
      "return_type": "",
      "span": {
        "end": {
          "column": 2,
          "line": 19
        },
        "start": {
          "column": 1,
          "line": 13
        }
      }
    },
    "genre": "FnValue",
    "name": "src/db.rs:14:5: replace tune_sqlcipher_log_level_sync with ()",
    "package": "butterfly-bot",
    "replacement": "()",
    "span": {
      "end": {
        "column": 6,
        "line": 18
      },
      "start": {
        "column": 5,
        "line": 14
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ replace tune_sqlcipher_log_level_async with ()\n@@ -14,24 +14,17 @@\n     if let Err(err) =\n         diesel::RunQueryDsl::execute(diesel::sql_query(\"PRAGMA cipher_log_level = ERROR\"), conn)\n     {\n         tracing::debug!(\"Unable to set SQLCipher log level (sync): {}\", err);\n     }\n }\n \n async fn tune_sqlcipher_log_level_async(conn: &mut SyncConnectionWrapper<SqliteConnection>) {\n-    if let Err(err) = diesel_async::RunQueryDsl::execute(\n-        diesel::sql_query(\"PRAGMA cipher_log_level = ERROR\"),\n-        conn,\n-    )\n-    .await\n-    {\n-        tracing::debug!(\"Unable to set SQLCipher log level (async): {}\", err);\n-    }\n+    () /* ~ changed by cargo-mutants ~ */\n }\n \n fn log_sqlcipher_key_source_once(source: &str) {\n     static LOGGED: OnceLock<()> = OnceLock::new();\n     if LOGGED.set(()).is_ok() {\n         tracing::info!(db_key_source = source, \"Resolved SQLCipher key source\");\n     }\n }\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "tune_sqlcipher_log_level_async",
      "return_type": "",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "FnValue",
    "name": "src/db.rs:22:5: replace tune_sqlcipher_log_level_async with ()",
    "package": "butterfly-bot",
    "replacement": "()",
    "span": {
      "end": {
        "column": 6,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ replace log_sqlcipher_key_source_once with ()\n@@ -25,20 +25,17 @@\n     )\n     .await\n     {\n         tracing::debug!(\"Unable to set SQLCipher log level (async): {}\", err);\n     }\n }\n \n fn log_sqlcipher_key_source_once(source: &str) {\n-    static LOGGED: OnceLock<()> = OnceLock::new();\n-    if LOGGED.set(()).is_ok() {\n-        tracing::info!(db_key_source = source, \"Resolved SQLCipher key source\");\n-    }\n+    () /* ~ changed by cargo-mutants ~ */\n }\n \n fn generated_db_key() -> Result<String> {\n     let mut bytes = [0u8; 32];\n     let mut rng = SysRng;\n     rng.try_fill_bytes(&mut bytes)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(URL_SAFE_NO_PAD.encode(bytes))\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "log_sqlcipher_key_source_once",
      "return_type": "",
      "span": {
        "end": {
          "column": 2,
          "line": 37
        },
        "start": {
          "column": 1,
          "line": 32
        }
      }
    },
    "genre": "FnValue",
    "name": "src/db.rs:33:5: replace log_sqlcipher_key_source_once with ()",
    "package": "butterfly-bot",
    "replacement": "()",
    "span": {
      "end": {
        "column": 6,
        "line": 36
      },
      "start": {
        "column": 5,
        "line": 33
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ replace generated_db_key -> Result<String> with Ok(String::new())\n@@ -32,21 +32,17 @@\n fn log_sqlcipher_key_source_once(source: &str) {\n     static LOGGED: OnceLock<()> = OnceLock::new();\n     if LOGGED.set(()).is_ok() {\n         tracing::info!(db_key_source = source, \"Resolved SQLCipher key source\");\n     }\n }\n \n fn generated_db_key() -> Result<String> {\n-    let mut bytes = [0u8; 32];\n-    let mut rng = SysRng;\n-    rng.try_fill_bytes(&mut bytes)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    Ok(URL_SAFE_NO_PAD.encode(bytes))\n+    Ok(String::new()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn get_sqlcipher_key() -> Result<String> {\n     if let Some(value) = crate::vault::get_secret(DB_KEY_NAME)? {\n         let trimmed = value.trim();\n         if !trimmed.is_empty() {\n             log_sqlcipher_key_source_once(\"keychain\");\n             return Ok(trimmed.to_string());\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "generated_db_key",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 45
        },
        "start": {
          "column": 1,
          "line": 39
        }
      }
    },
    "genre": "FnValue",
    "name": "src/db.rs:40:5: replace generated_db_key -> Result<String> with Ok(String::new())",
    "package": "butterfly-bot",
    "replacement": "Ok(String::new())",
    "span": {
      "end": {
        "column": 38,
        "line": 44
      },
      "start": {
        "column": 5,
        "line": 40
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ replace generated_db_key -> Result<String> with Ok(\"xyzzy\".into())\n@@ -32,21 +32,17 @@\n fn log_sqlcipher_key_source_once(source: &str) {\n     static LOGGED: OnceLock<()> = OnceLock::new();\n     if LOGGED.set(()).is_ok() {\n         tracing::info!(db_key_source = source, \"Resolved SQLCipher key source\");\n     }\n }\n \n fn generated_db_key() -> Result<String> {\n-    let mut bytes = [0u8; 32];\n-    let mut rng = SysRng;\n-    rng.try_fill_bytes(&mut bytes)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    Ok(URL_SAFE_NO_PAD.encode(bytes))\n+    Ok(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn get_sqlcipher_key() -> Result<String> {\n     if let Some(value) = crate::vault::get_secret(DB_KEY_NAME)? {\n         let trimmed = value.trim();\n         if !trimmed.is_empty() {\n             log_sqlcipher_key_source_once(\"keychain\");\n             return Ok(trimmed.to_string());\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "generated_db_key",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 45
        },
        "start": {
          "column": 1,
          "line": 39
        }
      }
    },
    "genre": "FnValue",
    "name": "src/db.rs:40:5: replace generated_db_key -> Result<String> with Ok(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Ok(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 38,
        "line": 44
      },
      "start": {
        "column": 5,
        "line": 40
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ replace get_sqlcipher_key -> Result<String> with Ok(String::new())\n@@ -40,28 +40,17 @@\n     let mut bytes = [0u8; 32];\n     let mut rng = SysRng;\n     rng.try_fill_bytes(&mut bytes)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(URL_SAFE_NO_PAD.encode(bytes))\n }\n \n pub fn get_sqlcipher_key() -> Result<String> {\n-    if let Some(value) = crate::vault::get_secret(DB_KEY_NAME)? {\n-        let trimmed = value.trim();\n-        if !trimmed.is_empty() {\n-            log_sqlcipher_key_source_once(\"keychain\");\n-            return Ok(trimmed.to_string());\n-        }\n-    }\n-\n-    let generated = generated_db_key()?;\n-    crate::vault::set_secret_required(DB_KEY_NAME, &generated)?;\n-    log_sqlcipher_key_source_once(\"generated_keychain\");\n-    Ok(generated)\n+    Ok(String::new()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn apply_sqlcipher_key_sync(conn: &mut SqliteConnection) -> Result<()> {\n     diesel::RunQueryDsl::execute(diesel::sql_query(\"PRAGMA busy_timeout = 5000\"), conn)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     let key = get_sqlcipher_key()?;\n     let escaped_key = key.replace('\\'', \"''\");\n     diesel::RunQueryDsl::execute(\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "get_sqlcipher_key",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 60
        },
        "start": {
          "column": 1,
          "line": 47
        }
      }
    },
    "genre": "FnValue",
    "name": "src/db.rs:48:5: replace get_sqlcipher_key -> Result<String> with Ok(String::new())",
    "package": "butterfly-bot",
    "replacement": "Ok(String::new())",
    "span": {
      "end": {
        "column": 18,
        "line": 59
      },
      "start": {
        "column": 5,
        "line": 48
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ replace get_sqlcipher_key -> Result<String> with Ok(\"xyzzy\".into())\n@@ -40,28 +40,17 @@\n     let mut bytes = [0u8; 32];\n     let mut rng = SysRng;\n     rng.try_fill_bytes(&mut bytes)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(URL_SAFE_NO_PAD.encode(bytes))\n }\n \n pub fn get_sqlcipher_key() -> Result<String> {\n-    if let Some(value) = crate::vault::get_secret(DB_KEY_NAME)? {\n-        let trimmed = value.trim();\n-        if !trimmed.is_empty() {\n-            log_sqlcipher_key_source_once(\"keychain\");\n-            return Ok(trimmed.to_string());\n-        }\n-    }\n-\n-    let generated = generated_db_key()?;\n-    crate::vault::set_secret_required(DB_KEY_NAME, &generated)?;\n-    log_sqlcipher_key_source_once(\"generated_keychain\");\n-    Ok(generated)\n+    Ok(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn apply_sqlcipher_key_sync(conn: &mut SqliteConnection) -> Result<()> {\n     diesel::RunQueryDsl::execute(diesel::sql_query(\"PRAGMA busy_timeout = 5000\"), conn)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     let key = get_sqlcipher_key()?;\n     let escaped_key = key.replace('\\'', \"''\");\n     diesel::RunQueryDsl::execute(\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "get_sqlcipher_key",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 60
        },
        "start": {
          "column": 1,
          "line": 47
        }
      }
    },
    "genre": "FnValue",
    "name": "src/db.rs:48:5: replace get_sqlcipher_key -> Result<String> with Ok(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Ok(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 18,
        "line": 59
      },
      "start": {
        "column": 5,
        "line": 48
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ delete ! in get_sqlcipher_key\n@@ -42,17 +42,17 @@\n     rng.try_fill_bytes(&mut bytes)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     Ok(URL_SAFE_NO_PAD.encode(bytes))\n }\n \n pub fn get_sqlcipher_key() -> Result<String> {\n     if let Some(value) = crate::vault::get_secret(DB_KEY_NAME)? {\n         let trimmed = value.trim();\n-        if !trimmed.is_empty() {\n+        if  /* ~ changed by cargo-mutants ~ */trimmed.is_empty() {\n             log_sqlcipher_key_source_once(\"keychain\");\n             return Ok(trimmed.to_string());\n         }\n     }\n \n     let generated = generated_db_key()?;\n     crate::vault::set_secret_required(DB_KEY_NAME, &generated)?;\n     log_sqlcipher_key_source_once(\"generated_keychain\");\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "get_sqlcipher_key",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 60
        },
        "start": {
          "column": 1,
          "line": 47
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/db.rs:50:12: delete ! in get_sqlcipher_key",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 13,
        "line": 50
      },
      "start": {
        "column": 12,
        "line": 50
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ replace apply_sqlcipher_key_sync -> Result<()> with Ok(())\n@@ -55,27 +55,17 @@\n \n     let generated = generated_db_key()?;\n     crate::vault::set_secret_required(DB_KEY_NAME, &generated)?;\n     log_sqlcipher_key_source_once(\"generated_keychain\");\n     Ok(generated)\n }\n \n pub fn apply_sqlcipher_key_sync(conn: &mut SqliteConnection) -> Result<()> {\n-    diesel::RunQueryDsl::execute(diesel::sql_query(\"PRAGMA busy_timeout = 5000\"), conn)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    let key = get_sqlcipher_key()?;\n-    let escaped_key = key.replace('\\'', \"''\");\n-    diesel::RunQueryDsl::execute(\n-        diesel::sql_query(format!(\"PRAGMA key = '{escaped_key}'\")),\n-        conn,\n-    )\n-    .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    tune_sqlcipher_log_level_sync(conn);\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub async fn apply_sqlcipher_key_async(\n     conn: &mut SyncConnectionWrapper<SqliteConnection>,\n ) -> Result<()> {\n     diesel_async::RunQueryDsl::execute(diesel::sql_query(\"PRAGMA busy_timeout = 5000\"), conn)\n         .await\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "apply_sqlcipher_key_sync",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 74
        },
        "start": {
          "column": 1,
          "line": 62
        }
      }
    },
    "genre": "FnValue",
    "name": "src/db.rs:63:5: replace apply_sqlcipher_key_sync -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 73
      },
      "start": {
        "column": 5,
        "line": 63
      }
    }
  },
  {
    "diff": "--- src/db.rs\n+++ replace apply_sqlcipher_key_async -> Result<()> with Ok(())\n@@ -71,29 +71,17 @@\n     .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n     tune_sqlcipher_log_level_sync(conn);\n     Ok(())\n }\n \n pub async fn apply_sqlcipher_key_async(\n     conn: &mut SyncConnectionWrapper<SqliteConnection>,\n ) -> Result<()> {\n-    diesel_async::RunQueryDsl::execute(diesel::sql_query(\"PRAGMA busy_timeout = 5000\"), conn)\n-        .await\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    let key = get_sqlcipher_key()?;\n-    let escaped_key = key.replace('\\'', \"''\");\n-    diesel_async::RunQueryDsl::execute(\n-        diesel::sql_query(format!(\"PRAGMA key = '{escaped_key}'\")),\n-        conn,\n-    )\n-    .await\n-    .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    tune_sqlcipher_log_level_async(conn).await;\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     use std::sync::{Mutex, OnceLock};\n \n     fn env_test_lock() -> &'static Mutex<()> {\n",
    "file": "src/db.rs",
    "function": {
      "function_name": "apply_sqlcipher_key_async",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 92
        },
        "start": {
          "column": 1,
          "line": 76
        }
      }
    },
    "genre": "FnValue",
    "name": "src/db.rs:79:5: replace apply_sqlcipher_key_async -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 91
      },
      "start": {
        "column": 5,
        "line": 79
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace CocoonFileSecretProvider::passphrase -> Result<String> with Ok(String::new())\n@@ -15,17 +15,17 @@\n     ) -> Result<()>;\n     fn get_secret(&self, name: &str) -> Result<Option<String>>;\n }\n \n struct CocoonFileSecretProvider;\n \n impl CocoonFileSecretProvider {\n     fn passphrase(&self) -> Result<String> {\n-        crate::security::tpm_provider::resolve_dek_passphrase()\n+        Ok(String::new()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn secret_path(&self, name: &str) -> PathBuf {\n         let sanitized = name\n             .chars()\n             .map(|ch| {\n                 if ch.is_ascii_alphanumeric() || matches!(ch, '_' | '-' | '.') {\n                     ch\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "CocoonFileSecretProvider::passphrase",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 24
        },
        "start": {
          "column": 5,
          "line": 22
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:23:9: replace CocoonFileSecretProvider::passphrase -> Result<String> with Ok(String::new())",
    "package": "butterfly-bot",
    "replacement": "Ok(String::new())",
    "span": {
      "end": {
        "column": 64,
        "line": 23
      },
      "start": {
        "column": 9,
        "line": 23
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace CocoonFileSecretProvider::passphrase -> Result<String> with Ok(\"xyzzy\".into())\n@@ -15,17 +15,17 @@\n     ) -> Result<()>;\n     fn get_secret(&self, name: &str) -> Result<Option<String>>;\n }\n \n struct CocoonFileSecretProvider;\n \n impl CocoonFileSecretProvider {\n     fn passphrase(&self) -> Result<String> {\n-        crate::security::tpm_provider::resolve_dek_passphrase()\n+        Ok(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn secret_path(&self, name: &str) -> PathBuf {\n         let sanitized = name\n             .chars()\n             .map(|ch| {\n                 if ch.is_ascii_alphanumeric() || matches!(ch, '_' | '-' | '.') {\n                     ch\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "CocoonFileSecretProvider::passphrase",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 24
        },
        "start": {
          "column": 5,
          "line": 22
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:23:9: replace CocoonFileSecretProvider::passphrase -> Result<String> with Ok(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Ok(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 64,
        "line": 23
      },
      "start": {
        "column": 9,
        "line": 23
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace CocoonFileSecretProvider::secret_path -> PathBuf with Default::default()\n@@ -19,29 +19,17 @@\n struct CocoonFileSecretProvider;\n \n impl CocoonFileSecretProvider {\n     fn passphrase(&self) -> Result<String> {\n         crate::security::tpm_provider::resolve_dek_passphrase()\n     }\n \n     fn secret_path(&self, name: &str) -> PathBuf {\n-        let sanitized = name\n-            .chars()\n-            .map(|ch| {\n-                if ch.is_ascii_alphanumeric() || matches!(ch, '_' | '-' | '.') {\n-                    ch\n-                } else {\n-                    '_'\n-                }\n-            })\n-            .collect::<String>();\n-        crate::runtime_paths::app_root()\n-            .join(\"secrets\")\n-            .join(format!(\"{sanitized}.cocoon\"))\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n impl SecretProvider for CocoonFileSecretProvider {\n     fn set_secret(\n         &self,\n         name: &str,\n         value: &str,\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "CocoonFileSecretProvider::secret_path",
      "return_type": "-> PathBuf",
      "span": {
        "end": {
          "column": 6,
          "line": 40
        },
        "start": {
          "column": 5,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:27:9: replace CocoonFileSecretProvider::secret_path -> PathBuf with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 49,
        "line": 39
      },
      "start": {
        "column": 9,
        "line": 27
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace || with && in CocoonFileSecretProvider::secret_path\n@@ -22,17 +22,17 @@\n     fn passphrase(&self) -> Result<String> {\n         crate::security::tpm_provider::resolve_dek_passphrase()\n     }\n \n     fn secret_path(&self, name: &str) -> PathBuf {\n         let sanitized = name\n             .chars()\n             .map(|ch| {\n-                if ch.is_ascii_alphanumeric() || matches!(ch, '_' | '-' | '.') {\n+                if ch.is_ascii_alphanumeric() && /* ~ changed by cargo-mutants ~ */ matches!(ch, '_' | '-' | '.') {\n                     ch\n                 } else {\n                     '_'\n                 }\n             })\n             .collect::<String>();\n         crate::runtime_paths::app_root()\n             .join(\"secrets\")\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "CocoonFileSecretProvider::secret_path",
      "return_type": "-> PathBuf",
      "span": {
        "end": {
          "column": 6,
          "line": 40
        },
        "start": {
          "column": 5,
          "line": 26
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/vault.rs:30:47: replace || with && in CocoonFileSecretProvider::secret_path",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 49,
        "line": 30
      },
      "start": {
        "column": 47,
        "line": 30
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace <impl SecretProvider for CocoonFileSecretProvider>::set_secret -> Result<()> with Ok(())\n@@ -42,20 +42,17 @@\n \n impl SecretProvider for CocoonFileSecretProvider {\n     fn set_secret(\n         &self,\n         name: &str,\n         value: &str,\n         _allow_backend_unavailable: bool,\n     ) -> Result<()> {\n-        let passphrase = self.passphrase()?;\n-        crate::security::hardening::with_sensitive_string(passphrase, |sensitive_passphrase| {\n-            cocoon_store::persist_secret(&self.secret_path(name), sensitive_passphrase, value)\n-        })\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n         let passphrase = self.passphrase()?;\n         crate::security::hardening::with_sensitive_string(passphrase, |sensitive_passphrase| {\n             cocoon_store::load_secret(&self.secret_path(name), sensitive_passphrase)\n         })\n     }\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "<impl SecretProvider for CocoonFileSecretProvider>::set_secret",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 54
        },
        "start": {
          "column": 5,
          "line": 44
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:50:9: replace <impl SecretProvider for CocoonFileSecretProvider>::set_secret -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 53
      },
      "start": {
        "column": 9,
        "line": 50
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace <impl SecretProvider for CocoonFileSecretProvider>::get_secret -> Result<Option<String>> with Ok(None)\n@@ -49,20 +49,17 @@\n     ) -> Result<()> {\n         let passphrase = self.passphrase()?;\n         crate::security::hardening::with_sensitive_string(passphrase, |sensitive_passphrase| {\n             cocoon_store::persist_secret(&self.secret_path(name), sensitive_passphrase, value)\n         })\n     }\n \n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n-        let passphrase = self.passphrase()?;\n-        crate::security::hardening::with_sensitive_string(passphrase, |sensitive_passphrase| {\n-            cocoon_store::load_secret(&self.secret_path(name), sensitive_passphrase)\n-        })\n+        Ok(None) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n fn build_default_provider() -> Arc<dyn SecretProvider> {\n     Arc::new(CocoonFileSecretProvider)\n }\n \n static SECRET_PROVIDER: OnceLock<RwLock<Arc<dyn SecretProvider>>> = OnceLock::new();\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "<impl SecretProvider for CocoonFileSecretProvider>::get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 61
        },
        "start": {
          "column": 5,
          "line": 56
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:57:9: replace <impl SecretProvider for CocoonFileSecretProvider>::get_secret -> Result<Option<String>> with Ok(None)",
    "package": "butterfly-bot",
    "replacement": "Ok(None)",
    "span": {
      "end": {
        "column": 11,
        "line": 60
      },
      "start": {
        "column": 9,
        "line": 57
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace <impl SecretProvider for CocoonFileSecretProvider>::get_secret -> Result<Option<String>> with Ok(Some(String::new()))\n@@ -49,20 +49,17 @@\n     ) -> Result<()> {\n         let passphrase = self.passphrase()?;\n         crate::security::hardening::with_sensitive_string(passphrase, |sensitive_passphrase| {\n             cocoon_store::persist_secret(&self.secret_path(name), sensitive_passphrase, value)\n         })\n     }\n \n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n-        let passphrase = self.passphrase()?;\n-        crate::security::hardening::with_sensitive_string(passphrase, |sensitive_passphrase| {\n-            cocoon_store::load_secret(&self.secret_path(name), sensitive_passphrase)\n-        })\n+        Ok(Some(String::new())) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n fn build_default_provider() -> Arc<dyn SecretProvider> {\n     Arc::new(CocoonFileSecretProvider)\n }\n \n static SECRET_PROVIDER: OnceLock<RwLock<Arc<dyn SecretProvider>>> = OnceLock::new();\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "<impl SecretProvider for CocoonFileSecretProvider>::get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 61
        },
        "start": {
          "column": 5,
          "line": 56
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:57:9: replace <impl SecretProvider for CocoonFileSecretProvider>::get_secret -> Result<Option<String>> with Ok(Some(String::new()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(String::new()))",
    "span": {
      "end": {
        "column": 11,
        "line": 60
      },
      "start": {
        "column": 9,
        "line": 57
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace <impl SecretProvider for CocoonFileSecretProvider>::get_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))\n@@ -49,20 +49,17 @@\n     ) -> Result<()> {\n         let passphrase = self.passphrase()?;\n         crate::security::hardening::with_sensitive_string(passphrase, |sensitive_passphrase| {\n             cocoon_store::persist_secret(&self.secret_path(name), sensitive_passphrase, value)\n         })\n     }\n \n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n-        let passphrase = self.passphrase()?;\n-        crate::security::hardening::with_sensitive_string(passphrase, |sensitive_passphrase| {\n-            cocoon_store::load_secret(&self.secret_path(name), sensitive_passphrase)\n-        })\n+        Ok(Some(\"xyzzy\".into())) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n fn build_default_provider() -> Arc<dyn SecretProvider> {\n     Arc::new(CocoonFileSecretProvider)\n }\n \n static SECRET_PROVIDER: OnceLock<RwLock<Arc<dyn SecretProvider>>> = OnceLock::new();\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "<impl SecretProvider for CocoonFileSecretProvider>::get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 61
        },
        "start": {
          "column": 5,
          "line": 56
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:57:9: replace <impl SecretProvider for CocoonFileSecretProvider>::get_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(\"xyzzy\".into()))",
    "span": {
      "end": {
        "column": 11,
        "line": 60
      },
      "start": {
        "column": 9,
        "line": 57
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace build_default_provider -> Arc<dyn SecretProvider> with Arc::new(Default::default())\n@@ -57,17 +57,17 @@\n         let passphrase = self.passphrase()?;\n         crate::security::hardening::with_sensitive_string(passphrase, |sensitive_passphrase| {\n             cocoon_store::load_secret(&self.secret_path(name), sensitive_passphrase)\n         })\n     }\n }\n \n fn build_default_provider() -> Arc<dyn SecretProvider> {\n-    Arc::new(CocoonFileSecretProvider)\n+    Arc::new(Default::default()) /* ~ changed by cargo-mutants ~ */\n }\n \n static SECRET_PROVIDER: OnceLock<RwLock<Arc<dyn SecretProvider>>> = OnceLock::new();\n \n fn provider_lock() -> &'static RwLock<Arc<dyn SecretProvider>> {\n     SECRET_PROVIDER.get_or_init(|| RwLock::new(build_default_provider()))\n }\n \n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "build_default_provider",
      "return_type": "-> Arc<dyn SecretProvider>",
      "span": {
        "end": {
          "column": 2,
          "line": 66
        },
        "start": {
          "column": 1,
          "line": 64
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:65:5: replace build_default_provider -> Arc<dyn SecretProvider> with Arc::new(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Arc::new(Default::default())",
    "span": {
      "end": {
        "column": 39,
        "line": 65
      },
      "start": {
        "column": 5,
        "line": 65
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace provider_lock -> &'static RwLock<Arc<dyn SecretProvider>> with Box::leak(Box::new(RwLock::new()))\n@@ -63,17 +63,17 @@\n \n fn build_default_provider() -> Arc<dyn SecretProvider> {\n     Arc::new(CocoonFileSecretProvider)\n }\n \n static SECRET_PROVIDER: OnceLock<RwLock<Arc<dyn SecretProvider>>> = OnceLock::new();\n \n fn provider_lock() -> &'static RwLock<Arc<dyn SecretProvider>> {\n-    SECRET_PROVIDER.get_or_init(|| RwLock::new(build_default_provider()))\n+    Box::leak(Box::new(RwLock::new())) /* ~ changed by cargo-mutants ~ */\n }\n \n fn active_provider() -> Arc<dyn SecretProvider> {\n     match provider_lock().read() {\n         Ok(guard) => Arc::clone(&guard),\n         Err(poisoned) => Arc::clone(poisoned.get_ref()),\n     }\n }\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "provider_lock",
      "return_type": "-> &'static RwLock<Arc<dyn SecretProvider>>",
      "span": {
        "end": {
          "column": 2,
          "line": 72
        },
        "start": {
          "column": 1,
          "line": 70
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:71:5: replace provider_lock -> &'static RwLock<Arc<dyn SecretProvider>> with Box::leak(Box::new(RwLock::new()))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(RwLock::new()))",
    "span": {
      "end": {
        "column": 74,
        "line": 71
      },
      "start": {
        "column": 5,
        "line": 71
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace provider_lock -> &'static RwLock<Arc<dyn SecretProvider>> with Box::leak(Box::new(RwLock::from_iter([Arc::new(Default::default())])))\n@@ -63,17 +63,17 @@\n \n fn build_default_provider() -> Arc<dyn SecretProvider> {\n     Arc::new(CocoonFileSecretProvider)\n }\n \n static SECRET_PROVIDER: OnceLock<RwLock<Arc<dyn SecretProvider>>> = OnceLock::new();\n \n fn provider_lock() -> &'static RwLock<Arc<dyn SecretProvider>> {\n-    SECRET_PROVIDER.get_or_init(|| RwLock::new(build_default_provider()))\n+    Box::leak(Box::new(RwLock::from_iter([Arc::new(Default::default())]))) /* ~ changed by cargo-mutants ~ */\n }\n \n fn active_provider() -> Arc<dyn SecretProvider> {\n     match provider_lock().read() {\n         Ok(guard) => Arc::clone(&guard),\n         Err(poisoned) => Arc::clone(poisoned.get_ref()),\n     }\n }\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "provider_lock",
      "return_type": "-> &'static RwLock<Arc<dyn SecretProvider>>",
      "span": {
        "end": {
          "column": 2,
          "line": 72
        },
        "start": {
          "column": 1,
          "line": 70
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:71:5: replace provider_lock -> &'static RwLock<Arc<dyn SecretProvider>> with Box::leak(Box::new(RwLock::from_iter([Arc::new(Default::default())])))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(RwLock::from_iter([Arc::new(Default::default())])))",
    "span": {
      "end": {
        "column": 74,
        "line": 71
      },
      "start": {
        "column": 5,
        "line": 71
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace provider_lock -> &'static RwLock<Arc<dyn SecretProvider>> with Box::leak(Box::new(RwLock::new(Arc::new(Default::default()))))\n@@ -63,17 +63,17 @@\n \n fn build_default_provider() -> Arc<dyn SecretProvider> {\n     Arc::new(CocoonFileSecretProvider)\n }\n \n static SECRET_PROVIDER: OnceLock<RwLock<Arc<dyn SecretProvider>>> = OnceLock::new();\n \n fn provider_lock() -> &'static RwLock<Arc<dyn SecretProvider>> {\n-    SECRET_PROVIDER.get_or_init(|| RwLock::new(build_default_provider()))\n+    Box::leak(Box::new(RwLock::new(Arc::new(Default::default())))) /* ~ changed by cargo-mutants ~ */\n }\n \n fn active_provider() -> Arc<dyn SecretProvider> {\n     match provider_lock().read() {\n         Ok(guard) => Arc::clone(&guard),\n         Err(poisoned) => Arc::clone(poisoned.get_ref()),\n     }\n }\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "provider_lock",
      "return_type": "-> &'static RwLock<Arc<dyn SecretProvider>>",
      "span": {
        "end": {
          "column": 2,
          "line": 72
        },
        "start": {
          "column": 1,
          "line": 70
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:71:5: replace provider_lock -> &'static RwLock<Arc<dyn SecretProvider>> with Box::leak(Box::new(RwLock::new(Arc::new(Default::default()))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(RwLock::new(Arc::new(Default::default()))))",
    "span": {
      "end": {
        "column": 74,
        "line": 71
      },
      "start": {
        "column": 5,
        "line": 71
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace provider_lock -> &'static RwLock<Arc<dyn SecretProvider>> with Box::leak(Box::new(RwLock::from(Arc::new(Default::default()))))\n@@ -63,17 +63,17 @@\n \n fn build_default_provider() -> Arc<dyn SecretProvider> {\n     Arc::new(CocoonFileSecretProvider)\n }\n \n static SECRET_PROVIDER: OnceLock<RwLock<Arc<dyn SecretProvider>>> = OnceLock::new();\n \n fn provider_lock() -> &'static RwLock<Arc<dyn SecretProvider>> {\n-    SECRET_PROVIDER.get_or_init(|| RwLock::new(build_default_provider()))\n+    Box::leak(Box::new(RwLock::from(Arc::new(Default::default())))) /* ~ changed by cargo-mutants ~ */\n }\n \n fn active_provider() -> Arc<dyn SecretProvider> {\n     match provider_lock().read() {\n         Ok(guard) => Arc::clone(&guard),\n         Err(poisoned) => Arc::clone(poisoned.get_ref()),\n     }\n }\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "provider_lock",
      "return_type": "-> &'static RwLock<Arc<dyn SecretProvider>>",
      "span": {
        "end": {
          "column": 2,
          "line": 72
        },
        "start": {
          "column": 1,
          "line": 70
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:71:5: replace provider_lock -> &'static RwLock<Arc<dyn SecretProvider>> with Box::leak(Box::new(RwLock::from(Arc::new(Default::default()))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(RwLock::from(Arc::new(Default::default()))))",
    "span": {
      "end": {
        "column": 74,
        "line": 71
      },
      "start": {
        "column": 5,
        "line": 71
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace active_provider -> Arc<dyn SecretProvider> with Arc::new(Default::default())\n@@ -67,20 +67,17 @@\n \n static SECRET_PROVIDER: OnceLock<RwLock<Arc<dyn SecretProvider>>> = OnceLock::new();\n \n fn provider_lock() -> &'static RwLock<Arc<dyn SecretProvider>> {\n     SECRET_PROVIDER.get_or_init(|| RwLock::new(build_default_provider()))\n }\n \n fn active_provider() -> Arc<dyn SecretProvider> {\n-    match provider_lock().read() {\n-        Ok(guard) => Arc::clone(&guard),\n-        Err(poisoned) => Arc::clone(poisoned.get_ref()),\n-    }\n+    Arc::new(Default::default()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n fn set_secret_provider_for_tests(provider: Arc<dyn SecretProvider>) {\n     match provider_lock().write() {\n         Ok(mut guard) => *guard = provider,\n         Err(poisoned) => {\n             let mut guard = poisoned.into_inner();\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "active_provider",
      "return_type": "-> Arc<dyn SecretProvider>",
      "span": {
        "end": {
          "column": 2,
          "line": 79
        },
        "start": {
          "column": 1,
          "line": 74
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:75:5: replace active_provider -> Arc<dyn SecretProvider> with Arc::new(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Arc::new(Default::default())",
    "span": {
      "end": {
        "column": 6,
        "line": 78
      },
      "start": {
        "column": 5,
        "line": 75
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace set_secret -> Result<()> with Ok(())\n@@ -90,17 +90,17 @@\n }\n \n #[cfg(test)]\n fn reset_secret_provider_for_tests() {\n     set_secret_provider_for_tests(build_default_provider());\n }\n \n pub fn set_secret(name: &str, value: &str) -> Result<()> {\n-    set_secret_internal(name, value, true)\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn set_secret_required(name: &str, value: &str) -> Result<()> {\n     set_secret_internal(name, value, false)\n }\n \n fn set_secret_internal(name: &str, value: &str, allow_backend_unavailable: bool) -> Result<()> {\n     active_provider().set_secret(name, value, allow_backend_unavailable)\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "set_secret",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 99
        },
        "start": {
          "column": 1,
          "line": 97
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:98:5: replace set_secret -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 43,
        "line": 98
      },
      "start": {
        "column": 5,
        "line": 98
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace set_secret_required -> Result<()> with Ok(())\n@@ -94,17 +94,17 @@\n     set_secret_provider_for_tests(build_default_provider());\n }\n \n pub fn set_secret(name: &str, value: &str) -> Result<()> {\n     set_secret_internal(name, value, true)\n }\n \n pub fn set_secret_required(name: &str, value: &str) -> Result<()> {\n-    set_secret_internal(name, value, false)\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn set_secret_internal(name: &str, value: &str, allow_backend_unavailable: bool) -> Result<()> {\n     active_provider().set_secret(name, value, allow_backend_unavailable)\n }\n \n pub fn get_secret(name: &str) -> Result<Option<String>> {\n     active_provider().get_secret(name)\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "set_secret_required",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 103
        },
        "start": {
          "column": 1,
          "line": 101
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:102:5: replace set_secret_required -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 44,
        "line": 102
      },
      "start": {
        "column": 5,
        "line": 102
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace set_secret_internal -> Result<()> with Ok(())\n@@ -98,17 +98,17 @@\n     set_secret_internal(name, value, true)\n }\n \n pub fn set_secret_required(name: &str, value: &str) -> Result<()> {\n     set_secret_internal(name, value, false)\n }\n \n fn set_secret_internal(name: &str, value: &str, allow_backend_unavailable: bool) -> Result<()> {\n-    active_provider().set_secret(name, value, allow_backend_unavailable)\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn get_secret(name: &str) -> Result<Option<String>> {\n     active_provider().get_secret(name)\n }\n \n pub fn ensure_daemon_auth_token() -> Result<String> {\n     if let Some(token) = get_secret(\"daemon_auth_token\")? {\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "set_secret_internal",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 107
        },
        "start": {
          "column": 1,
          "line": 105
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:106:5: replace set_secret_internal -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 73,
        "line": 106
      },
      "start": {
        "column": 5,
        "line": 106
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace get_secret -> Result<Option<String>> with Ok(None)\n@@ -102,17 +102,17 @@\n     set_secret_internal(name, value, false)\n }\n \n fn set_secret_internal(name: &str, value: &str, allow_backend_unavailable: bool) -> Result<()> {\n     active_provider().set_secret(name, value, allow_backend_unavailable)\n }\n \n pub fn get_secret(name: &str) -> Result<Option<String>> {\n-    active_provider().get_secret(name)\n+    Ok(None) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn ensure_daemon_auth_token() -> Result<String> {\n     if let Some(token) = get_secret(\"daemon_auth_token\")? {\n         let trimmed = token.trim().to_string();\n         if !trimmed.is_empty() {\n             return Ok(trimmed);\n         }\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 111
        },
        "start": {
          "column": 1,
          "line": 109
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:110:5: replace get_secret -> Result<Option<String>> with Ok(None)",
    "package": "butterfly-bot",
    "replacement": "Ok(None)",
    "span": {
      "end": {
        "column": 39,
        "line": 110
      },
      "start": {
        "column": 5,
        "line": 110
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace get_secret -> Result<Option<String>> with Ok(Some(String::new()))\n@@ -102,17 +102,17 @@\n     set_secret_internal(name, value, false)\n }\n \n fn set_secret_internal(name: &str, value: &str, allow_backend_unavailable: bool) -> Result<()> {\n     active_provider().set_secret(name, value, allow_backend_unavailable)\n }\n \n pub fn get_secret(name: &str) -> Result<Option<String>> {\n-    active_provider().get_secret(name)\n+    Ok(Some(String::new())) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn ensure_daemon_auth_token() -> Result<String> {\n     if let Some(token) = get_secret(\"daemon_auth_token\")? {\n         let trimmed = token.trim().to_string();\n         if !trimmed.is_empty() {\n             return Ok(trimmed);\n         }\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 111
        },
        "start": {
          "column": 1,
          "line": 109
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:110:5: replace get_secret -> Result<Option<String>> with Ok(Some(String::new()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(String::new()))",
    "span": {
      "end": {
        "column": 39,
        "line": 110
      },
      "start": {
        "column": 5,
        "line": 110
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace get_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))\n@@ -102,17 +102,17 @@\n     set_secret_internal(name, value, false)\n }\n \n fn set_secret_internal(name: &str, value: &str, allow_backend_unavailable: bool) -> Result<()> {\n     active_provider().set_secret(name, value, allow_backend_unavailable)\n }\n \n pub fn get_secret(name: &str) -> Result<Option<String>> {\n-    active_provider().get_secret(name)\n+    Ok(Some(\"xyzzy\".into())) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn ensure_daemon_auth_token() -> Result<String> {\n     if let Some(token) = get_secret(\"daemon_auth_token\")? {\n         let trimmed = token.trim().to_string();\n         if !trimmed.is_empty() {\n             return Ok(trimmed);\n         }\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 111
        },
        "start": {
          "column": 1,
          "line": 109
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:110:5: replace get_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(\"xyzzy\".into()))",
    "span": {
      "end": {
        "column": 39,
        "line": 110
      },
      "start": {
        "column": 5,
        "line": 110
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace ensure_daemon_auth_token -> Result<String> with Ok(String::new())\n@@ -106,30 +106,17 @@\n     active_provider().set_secret(name, value, allow_backend_unavailable)\n }\n \n pub fn get_secret(name: &str) -> Result<Option<String>> {\n     active_provider().get_secret(name)\n }\n \n pub fn ensure_daemon_auth_token() -> Result<String> {\n-    if let Some(token) = get_secret(\"daemon_auth_token\")? {\n-        let trimmed = token.trim().to_string();\n-        if !trimmed.is_empty() {\n-            return Ok(trimmed);\n-        }\n-    }\n-\n-    let mut bytes = [0u8; 32];\n-    let mut rng = SysRng;\n-    rng.try_fill_bytes(&mut bytes)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    let generated = URL_SAFE_NO_PAD.encode(bytes);\n-    set_secret_required(\"daemon_auth_token\", &generated)?;\n-    Ok(generated)\n+    Ok(String::new()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     use std::collections::HashMap;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n     use std::sync::{Mutex, OnceLock};\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "ensure_daemon_auth_token",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 128
        },
        "start": {
          "column": 1,
          "line": 113
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:114:5: replace ensure_daemon_auth_token -> Result<String> with Ok(String::new())",
    "package": "butterfly-bot",
    "replacement": "Ok(String::new())",
    "span": {
      "end": {
        "column": 18,
        "line": 127
      },
      "start": {
        "column": 5,
        "line": 114
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ replace ensure_daemon_auth_token -> Result<String> with Ok(\"xyzzy\".into())\n@@ -106,30 +106,17 @@\n     active_provider().set_secret(name, value, allow_backend_unavailable)\n }\n \n pub fn get_secret(name: &str) -> Result<Option<String>> {\n     active_provider().get_secret(name)\n }\n \n pub fn ensure_daemon_auth_token() -> Result<String> {\n-    if let Some(token) = get_secret(\"daemon_auth_token\")? {\n-        let trimmed = token.trim().to_string();\n-        if !trimmed.is_empty() {\n-            return Ok(trimmed);\n-        }\n-    }\n-\n-    let mut bytes = [0u8; 32];\n-    let mut rng = SysRng;\n-    rng.try_fill_bytes(&mut bytes)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    let generated = URL_SAFE_NO_PAD.encode(bytes);\n-    set_secret_required(\"daemon_auth_token\", &generated)?;\n-    Ok(generated)\n+    Ok(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     use std::collections::HashMap;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n     use std::sync::{Mutex, OnceLock};\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "ensure_daemon_auth_token",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 128
        },
        "start": {
          "column": 1,
          "line": 113
        }
      }
    },
    "genre": "FnValue",
    "name": "src/vault.rs:114:5: replace ensure_daemon_auth_token -> Result<String> with Ok(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Ok(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 18,
        "line": 127
      },
      "start": {
        "column": 5,
        "line": 114
      }
    }
  },
  {
    "diff": "--- src/vault.rs\n+++ delete ! in ensure_daemon_auth_token\n@@ -108,17 +108,17 @@\n \n pub fn get_secret(name: &str) -> Result<Option<String>> {\n     active_provider().get_secret(name)\n }\n \n pub fn ensure_daemon_auth_token() -> Result<String> {\n     if let Some(token) = get_secret(\"daemon_auth_token\")? {\n         let trimmed = token.trim().to_string();\n-        if !trimmed.is_empty() {\n+        if  /* ~ changed by cargo-mutants ~ */trimmed.is_empty() {\n             return Ok(trimmed);\n         }\n     }\n \n     let mut bytes = [0u8; 32];\n     let mut rng = SysRng;\n     rng.try_fill_bytes(&mut bytes)\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n",
    "file": "src/vault.rs",
    "function": {
      "function_name": "ensure_daemon_auth_token",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 128
        },
        "start": {
          "column": 1,
          "line": 113
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/vault.rs:116:12: delete ! in ensure_daemon_auth_token",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 13,
        "line": 116
      },
      "start": {
        "column": 12,
        "line": 116
      }
    }
  },
  {
    "diff": "--- src/security/secret_policy.rs\n+++ replace SecretResolutionPolicy::mode -> SecretResolutionMode with Default::default()\n@@ -5,17 +5,17 @@\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub struct SecretResolutionPolicy {\n     mode: SecretResolutionMode,\n }\n \n impl SecretResolutionPolicy {\n     pub fn mode(self) -> SecretResolutionMode {\n-        self.mode\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     pub fn is_strict(self) -> bool {\n         matches!(self.mode, SecretResolutionMode::Strict)\n     }\n }\n \n pub fn current_secret_resolution_policy() -> SecretResolutionPolicy {\n",
    "file": "src/security/secret_policy.rs",
    "function": {
      "function_name": "SecretResolutionPolicy::mode",
      "return_type": "-> SecretResolutionMode",
      "span": {
        "end": {
          "column": 6,
          "line": 14
        },
        "start": {
          "column": 5,
          "line": 12
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/secret_policy.rs:13:9: replace SecretResolutionPolicy::mode -> SecretResolutionMode with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 18,
        "line": 13
      },
      "start": {
        "column": 9,
        "line": 13
      }
    }
  },
  {
    "diff": "--- src/security/secret_policy.rs\n+++ replace SecretResolutionPolicy::is_strict -> bool with true\n@@ -9,17 +9,17 @@\n }\n \n impl SecretResolutionPolicy {\n     pub fn mode(self) -> SecretResolutionMode {\n         self.mode\n     }\n \n     pub fn is_strict(self) -> bool {\n-        matches!(self.mode, SecretResolutionMode::Strict)\n+        true /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n pub fn current_secret_resolution_policy() -> SecretResolutionPolicy {\n     SecretResolutionPolicy {\n         mode: SecretResolutionMode::Strict,\n     }\n }\n",
    "file": "src/security/secret_policy.rs",
    "function": {
      "function_name": "SecretResolutionPolicy::is_strict",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 18
        },
        "start": {
          "column": 5,
          "line": 16
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/secret_policy.rs:17:9: replace SecretResolutionPolicy::is_strict -> bool with true",
    "package": "butterfly-bot",
    "replacement": "true",
    "span": {
      "end": {
        "column": 58,
        "line": 17
      },
      "start": {
        "column": 9,
        "line": 17
      }
    }
  },
  {
    "diff": "--- src/security/secret_policy.rs\n+++ replace SecretResolutionPolicy::is_strict -> bool with false\n@@ -9,17 +9,17 @@\n }\n \n impl SecretResolutionPolicy {\n     pub fn mode(self) -> SecretResolutionMode {\n         self.mode\n     }\n \n     pub fn is_strict(self) -> bool {\n-        matches!(self.mode, SecretResolutionMode::Strict)\n+        false /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n pub fn current_secret_resolution_policy() -> SecretResolutionPolicy {\n     SecretResolutionPolicy {\n         mode: SecretResolutionMode::Strict,\n     }\n }\n",
    "file": "src/security/secret_policy.rs",
    "function": {
      "function_name": "SecretResolutionPolicy::is_strict",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 18
        },
        "start": {
          "column": 5,
          "line": 16
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/secret_policy.rs:17:9: replace SecretResolutionPolicy::is_strict -> bool with false",
    "package": "butterfly-bot",
    "replacement": "false",
    "span": {
      "end": {
        "column": 58,
        "line": 17
      },
      "start": {
        "column": 9,
        "line": 17
      }
    }
  },
  {
    "diff": "--- src/security/secret_policy.rs\n+++ replace current_secret_resolution_policy -> SecretResolutionPolicy with Default::default()\n@@ -14,19 +14,17 @@\n     }\n \n     pub fn is_strict(self) -> bool {\n         matches!(self.mode, SecretResolutionMode::Strict)\n     }\n }\n \n pub fn current_secret_resolution_policy() -> SecretResolutionPolicy {\n-    SecretResolutionPolicy {\n-        mode: SecretResolutionMode::Strict,\n-    }\n+    Default::default() /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     #[test]\n     fn always_strict_policy() {\n",
    "file": "src/security/secret_policy.rs",
    "function": {
      "function_name": "current_secret_resolution_policy",
      "return_type": "-> SecretResolutionPolicy",
      "span": {
        "end": {
          "column": 2,
          "line": 25
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/secret_policy.rs:22:5: replace current_secret_resolution_policy -> SecretResolutionPolicy with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 6,
        "line": 24
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace wrap_envelope -> Vec<u8> with vec![]\n@@ -5,22 +5,17 @@\n \n use crate::error::{ButterflyBotError, Result};\n \n const BLOB_MAGIC: &[u8; 4] = b\"BBC1\";\n const BLOB_VERSION: u8 = 1;\n const CIPHER_CHA_CHA20_POLY1305: u8 = 1;\n \n fn wrap_envelope(payload: &[u8]) -> Vec<u8> {\n-    let mut out = Vec::with_capacity(6 + payload.len());\n-    out.extend_from_slice(BLOB_MAGIC);\n-    out.push(BLOB_VERSION);\n-    out.push(CIPHER_CHA_CHA20_POLY1305);\n-    out.extend_from_slice(payload);\n-    out\n+    vec![] /* ~ changed by cargo-mutants ~ */\n }\n \n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n     if raw.len() < 6 {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has invalid envelope length\",\n             path.to_string_lossy()\n         )));\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "wrap_envelope",
      "return_type": "-> Vec<u8>",
      "span": {
        "end": {
          "column": 2,
          "line": 19
        },
        "start": {
          "column": 1,
          "line": 12
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:13:5: replace wrap_envelope -> Vec<u8> with vec![]",
    "package": "butterfly-bot",
    "replacement": "vec![]",
    "span": {
      "end": {
        "column": 8,
        "line": 18
      },
      "start": {
        "column": 5,
        "line": 13
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace wrap_envelope -> Vec<u8> with vec![0]\n@@ -5,22 +5,17 @@\n \n use crate::error::{ButterflyBotError, Result};\n \n const BLOB_MAGIC: &[u8; 4] = b\"BBC1\";\n const BLOB_VERSION: u8 = 1;\n const CIPHER_CHA_CHA20_POLY1305: u8 = 1;\n \n fn wrap_envelope(payload: &[u8]) -> Vec<u8> {\n-    let mut out = Vec::with_capacity(6 + payload.len());\n-    out.extend_from_slice(BLOB_MAGIC);\n-    out.push(BLOB_VERSION);\n-    out.push(CIPHER_CHA_CHA20_POLY1305);\n-    out.extend_from_slice(payload);\n-    out\n+    vec![0] /* ~ changed by cargo-mutants ~ */\n }\n \n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n     if raw.len() < 6 {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has invalid envelope length\",\n             path.to_string_lossy()\n         )));\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "wrap_envelope",
      "return_type": "-> Vec<u8>",
      "span": {
        "end": {
          "column": 2,
          "line": 19
        },
        "start": {
          "column": 1,
          "line": 12
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:13:5: replace wrap_envelope -> Vec<u8> with vec![0]",
    "package": "butterfly-bot",
    "replacement": "vec![0]",
    "span": {
      "end": {
        "column": 8,
        "line": 18
      },
      "start": {
        "column": 5,
        "line": 13
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace wrap_envelope -> Vec<u8> with vec![1]\n@@ -5,22 +5,17 @@\n \n use crate::error::{ButterflyBotError, Result};\n \n const BLOB_MAGIC: &[u8; 4] = b\"BBC1\";\n const BLOB_VERSION: u8 = 1;\n const CIPHER_CHA_CHA20_POLY1305: u8 = 1;\n \n fn wrap_envelope(payload: &[u8]) -> Vec<u8> {\n-    let mut out = Vec::with_capacity(6 + payload.len());\n-    out.extend_from_slice(BLOB_MAGIC);\n-    out.push(BLOB_VERSION);\n-    out.push(CIPHER_CHA_CHA20_POLY1305);\n-    out.extend_from_slice(payload);\n-    out\n+    vec![1] /* ~ changed by cargo-mutants ~ */\n }\n \n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n     if raw.len() < 6 {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has invalid envelope length\",\n             path.to_string_lossy()\n         )));\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "wrap_envelope",
      "return_type": "-> Vec<u8>",
      "span": {
        "end": {
          "column": 2,
          "line": 19
        },
        "start": {
          "column": 1,
          "line": 12
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:13:5: replace wrap_envelope -> Vec<u8> with vec![1]",
    "package": "butterfly-bot",
    "replacement": "vec![1]",
    "span": {
      "end": {
        "column": 8,
        "line": 18
      },
      "start": {
        "column": 5,
        "line": 13
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace unwrap_envelope -> Result<Vec<u8>> with Ok(vec![])\n@@ -14,49 +14,17 @@\n     out.extend_from_slice(BLOB_MAGIC);\n     out.push(BLOB_VERSION);\n     out.push(CIPHER_CHA_CHA20_POLY1305);\n     out.extend_from_slice(payload);\n     out\n }\n \n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n-    if raw.len() < 6 {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has invalid envelope length\",\n-            path.to_string_lossy()\n-        )));\n-    }\n-\n-    if &raw[0..4] != BLOB_MAGIC {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has invalid envelope magic\",\n-            path.to_string_lossy()\n-        )));\n-    }\n-\n-    let version = raw[4];\n-    if version != BLOB_VERSION {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has unsupported envelope version {}\",\n-            path.to_string_lossy(),\n-            version\n-        )));\n-    }\n-\n-    let cipher = raw[5];\n-    if cipher != CIPHER_CHA_CHA20_POLY1305 {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has unsupported cipher id {}\",\n-            path.to_string_lossy(),\n-            cipher\n-        )));\n-    }\n-\n-    Ok(raw[6..].to_vec())\n+    Ok(vec![]) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn load_secret(path: &Path, passphrase: &str) -> Result<Option<String>> {\n     if !path.exists() {\n         return Ok(None);\n     }\n \n     let mut file = File::open(path).map_err(|e| {\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "unwrap_envelope",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:22:5: replace unwrap_envelope -> Result<Vec<u8>> with Ok(vec![])",
    "package": "butterfly-bot",
    "replacement": "Ok(vec![])",
    "span": {
      "end": {
        "column": 26,
        "line": 54
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace unwrap_envelope -> Result<Vec<u8>> with Ok(vec![0])\n@@ -14,49 +14,17 @@\n     out.extend_from_slice(BLOB_MAGIC);\n     out.push(BLOB_VERSION);\n     out.push(CIPHER_CHA_CHA20_POLY1305);\n     out.extend_from_slice(payload);\n     out\n }\n \n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n-    if raw.len() < 6 {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has invalid envelope length\",\n-            path.to_string_lossy()\n-        )));\n-    }\n-\n-    if &raw[0..4] != BLOB_MAGIC {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has invalid envelope magic\",\n-            path.to_string_lossy()\n-        )));\n-    }\n-\n-    let version = raw[4];\n-    if version != BLOB_VERSION {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has unsupported envelope version {}\",\n-            path.to_string_lossy(),\n-            version\n-        )));\n-    }\n-\n-    let cipher = raw[5];\n-    if cipher != CIPHER_CHA_CHA20_POLY1305 {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has unsupported cipher id {}\",\n-            path.to_string_lossy(),\n-            cipher\n-        )));\n-    }\n-\n-    Ok(raw[6..].to_vec())\n+    Ok(vec![0]) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn load_secret(path: &Path, passphrase: &str) -> Result<Option<String>> {\n     if !path.exists() {\n         return Ok(None);\n     }\n \n     let mut file = File::open(path).map_err(|e| {\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "unwrap_envelope",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:22:5: replace unwrap_envelope -> Result<Vec<u8>> with Ok(vec![0])",
    "package": "butterfly-bot",
    "replacement": "Ok(vec![0])",
    "span": {
      "end": {
        "column": 26,
        "line": 54
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace unwrap_envelope -> Result<Vec<u8>> with Ok(vec![1])\n@@ -14,49 +14,17 @@\n     out.extend_from_slice(BLOB_MAGIC);\n     out.push(BLOB_VERSION);\n     out.push(CIPHER_CHA_CHA20_POLY1305);\n     out.extend_from_slice(payload);\n     out\n }\n \n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n-    if raw.len() < 6 {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has invalid envelope length\",\n-            path.to_string_lossy()\n-        )));\n-    }\n-\n-    if &raw[0..4] != BLOB_MAGIC {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has invalid envelope magic\",\n-            path.to_string_lossy()\n-        )));\n-    }\n-\n-    let version = raw[4];\n-    if version != BLOB_VERSION {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has unsupported envelope version {}\",\n-            path.to_string_lossy(),\n-            version\n-        )));\n-    }\n-\n-    let cipher = raw[5];\n-    if cipher != CIPHER_CHA_CHA20_POLY1305 {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} has unsupported cipher id {}\",\n-            path.to_string_lossy(),\n-            cipher\n-        )));\n-    }\n-\n-    Ok(raw[6..].to_vec())\n+    Ok(vec![1]) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn load_secret(path: &Path, passphrase: &str) -> Result<Option<String>> {\n     if !path.exists() {\n         return Ok(None);\n     }\n \n     let mut file = File::open(path).map_err(|e| {\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "unwrap_envelope",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:22:5: replace unwrap_envelope -> Result<Vec<u8>> with Ok(vec![1])",
    "package": "butterfly-bot",
    "replacement": "Ok(vec![1])",
    "span": {
      "end": {
        "column": 26,
        "line": 54
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace < with == in unwrap_envelope\n@@ -14,17 +14,17 @@\n     out.extend_from_slice(BLOB_MAGIC);\n     out.push(BLOB_VERSION);\n     out.push(CIPHER_CHA_CHA20_POLY1305);\n     out.extend_from_slice(payload);\n     out\n }\n \n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n-    if raw.len() < 6 {\n+    if raw.len() == /* ~ changed by cargo-mutants ~ */ 6 {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has invalid envelope length\",\n             path.to_string_lossy()\n         )));\n     }\n \n     if &raw[0..4] != BLOB_MAGIC {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "unwrap_envelope",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/cocoon_store.rs:22:18: replace < with == in unwrap_envelope",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 19,
        "line": 22
      },
      "start": {
        "column": 18,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace < with > in unwrap_envelope\n@@ -14,17 +14,17 @@\n     out.extend_from_slice(BLOB_MAGIC);\n     out.push(BLOB_VERSION);\n     out.push(CIPHER_CHA_CHA20_POLY1305);\n     out.extend_from_slice(payload);\n     out\n }\n \n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n-    if raw.len() < 6 {\n+    if raw.len() > /* ~ changed by cargo-mutants ~ */ 6 {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has invalid envelope length\",\n             path.to_string_lossy()\n         )));\n     }\n \n     if &raw[0..4] != BLOB_MAGIC {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "unwrap_envelope",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/cocoon_store.rs:22:18: replace < with > in unwrap_envelope",
    "package": "butterfly-bot",
    "replacement": ">",
    "span": {
      "end": {
        "column": 19,
        "line": 22
      },
      "start": {
        "column": 18,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace < with <= in unwrap_envelope\n@@ -14,17 +14,17 @@\n     out.extend_from_slice(BLOB_MAGIC);\n     out.push(BLOB_VERSION);\n     out.push(CIPHER_CHA_CHA20_POLY1305);\n     out.extend_from_slice(payload);\n     out\n }\n \n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n-    if raw.len() < 6 {\n+    if raw.len() <= /* ~ changed by cargo-mutants ~ */ 6 {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has invalid envelope length\",\n             path.to_string_lossy()\n         )));\n     }\n \n     if &raw[0..4] != BLOB_MAGIC {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "unwrap_envelope",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/cocoon_store.rs:22:18: replace < with <= in unwrap_envelope",
    "package": "butterfly-bot",
    "replacement": "<=",
    "span": {
      "end": {
        "column": 19,
        "line": 22
      },
      "start": {
        "column": 18,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace != with == in unwrap_envelope\n@@ -21,17 +21,17 @@\n fn unwrap_envelope(raw: Vec<u8>, path: &Path) -> Result<Vec<u8>> {\n     if raw.len() < 6 {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has invalid envelope length\",\n             path.to_string_lossy()\n         )));\n     }\n \n-    if &raw[0..4] != BLOB_MAGIC {\n+    if &raw[0..4] == /* ~ changed by cargo-mutants ~ */ BLOB_MAGIC {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has invalid envelope magic\",\n             path.to_string_lossy()\n         )));\n     }\n \n     let version = raw[4];\n     if version != BLOB_VERSION {\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "unwrap_envelope",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/cocoon_store.rs:29:19: replace != with == in unwrap_envelope",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 21,
        "line": 29
      },
      "start": {
        "column": 19,
        "line": 29
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace != with == in unwrap_envelope\n@@ -29,17 +29,17 @@\n     if &raw[0..4] != BLOB_MAGIC {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has invalid envelope magic\",\n             path.to_string_lossy()\n         )));\n     }\n \n     let version = raw[4];\n-    if version != BLOB_VERSION {\n+    if version == /* ~ changed by cargo-mutants ~ */ BLOB_VERSION {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has unsupported envelope version {}\",\n             path.to_string_lossy(),\n             version\n         )));\n     }\n \n     let cipher = raw[5];\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "unwrap_envelope",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/cocoon_store.rs:37:16: replace != with == in unwrap_envelope",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 18,
        "line": 37
      },
      "start": {
        "column": 16,
        "line": 37
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace != with == in unwrap_envelope\n@@ -38,17 +38,17 @@\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has unsupported envelope version {}\",\n             path.to_string_lossy(),\n             version\n         )));\n     }\n \n     let cipher = raw[5];\n-    if cipher != CIPHER_CHA_CHA20_POLY1305 {\n+    if cipher == /* ~ changed by cargo-mutants ~ */ CIPHER_CHA_CHA20_POLY1305 {\n         return Err(ButterflyBotError::SecurityStorage(format!(\n             \"encrypted secret {} has unsupported cipher id {}\",\n             path.to_string_lossy(),\n             cipher\n         )));\n     }\n \n     Ok(raw[6..].to_vec())\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "unwrap_envelope",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 55
        },
        "start": {
          "column": 1,
          "line": 21
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/cocoon_store.rs:46:15: replace != with == in unwrap_envelope",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 17,
        "line": 46
      },
      "start": {
        "column": 15,
        "line": 46
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace load_secret -> Result<Option<String>> with Ok(None)\n@@ -50,53 +50,17 @@\n             cipher\n         )));\n     }\n \n     Ok(raw[6..].to_vec())\n }\n \n pub fn load_secret(path: &Path, passphrase: &str) -> Result<Option<String>> {\n-    if !path.exists() {\n-        return Ok(None);\n-    }\n-\n-    let mut file = File::open(path).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"failed to open encrypted secret {}: {e}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let cocoon = Cocoon::new(passphrase.as_bytes());\n-    let decoded = cocoon.parse(&mut file).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"failed to decrypt encrypted secret {}: {e:?}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let payload = unwrap_envelope(decoded, path)?;\n-\n-    let value = String::from_utf8(payload).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"invalid utf8 in encrypted secret {}: {e}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let trimmed = value.trim();\n-    if trimmed.is_empty() {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} is empty\",\n-            path.to_string_lossy()\n-        )));\n-    }\n-\n-    Ok(Some(trimmed.to_string()))\n+    Ok(None) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn persist_secret(path: &Path, passphrase: &str, value: &str) -> Result<()> {\n     if let Some(parent) = path.parent() {\n         std::fs::create_dir_all(parent).map_err(|e| {\n             ButterflyBotError::SecurityStorage(format!(\n                 \"failed to create encrypted secret directory {}: {e}\",\n                 parent.to_string_lossy()\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "load_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 95
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:58:5: replace load_secret -> Result<Option<String>> with Ok(None)",
    "package": "butterfly-bot",
    "replacement": "Ok(None)",
    "span": {
      "end": {
        "column": 34,
        "line": 94
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace load_secret -> Result<Option<String>> with Ok(Some(String::new()))\n@@ -50,53 +50,17 @@\n             cipher\n         )));\n     }\n \n     Ok(raw[6..].to_vec())\n }\n \n pub fn load_secret(path: &Path, passphrase: &str) -> Result<Option<String>> {\n-    if !path.exists() {\n-        return Ok(None);\n-    }\n-\n-    let mut file = File::open(path).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"failed to open encrypted secret {}: {e}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let cocoon = Cocoon::new(passphrase.as_bytes());\n-    let decoded = cocoon.parse(&mut file).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"failed to decrypt encrypted secret {}: {e:?}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let payload = unwrap_envelope(decoded, path)?;\n-\n-    let value = String::from_utf8(payload).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"invalid utf8 in encrypted secret {}: {e}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let trimmed = value.trim();\n-    if trimmed.is_empty() {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} is empty\",\n-            path.to_string_lossy()\n-        )));\n-    }\n-\n-    Ok(Some(trimmed.to_string()))\n+    Ok(Some(String::new())) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn persist_secret(path: &Path, passphrase: &str, value: &str) -> Result<()> {\n     if let Some(parent) = path.parent() {\n         std::fs::create_dir_all(parent).map_err(|e| {\n             ButterflyBotError::SecurityStorage(format!(\n                 \"failed to create encrypted secret directory {}: {e}\",\n                 parent.to_string_lossy()\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "load_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 95
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:58:5: replace load_secret -> Result<Option<String>> with Ok(Some(String::new()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(String::new()))",
    "span": {
      "end": {
        "column": 34,
        "line": 94
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace load_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))\n@@ -50,53 +50,17 @@\n             cipher\n         )));\n     }\n \n     Ok(raw[6..].to_vec())\n }\n \n pub fn load_secret(path: &Path, passphrase: &str) -> Result<Option<String>> {\n-    if !path.exists() {\n-        return Ok(None);\n-    }\n-\n-    let mut file = File::open(path).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"failed to open encrypted secret {}: {e}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let cocoon = Cocoon::new(passphrase.as_bytes());\n-    let decoded = cocoon.parse(&mut file).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"failed to decrypt encrypted secret {}: {e:?}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let payload = unwrap_envelope(decoded, path)?;\n-\n-    let value = String::from_utf8(payload).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"invalid utf8 in encrypted secret {}: {e}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let trimmed = value.trim();\n-    if trimmed.is_empty() {\n-        return Err(ButterflyBotError::SecurityStorage(format!(\n-            \"encrypted secret {} is empty\",\n-            path.to_string_lossy()\n-        )));\n-    }\n-\n-    Ok(Some(trimmed.to_string()))\n+    Ok(Some(\"xyzzy\".into())) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn persist_secret(path: &Path, passphrase: &str, value: &str) -> Result<()> {\n     if let Some(parent) = path.parent() {\n         std::fs::create_dir_all(parent).map_err(|e| {\n             ButterflyBotError::SecurityStorage(format!(\n                 \"failed to create encrypted secret directory {}: {e}\",\n                 parent.to_string_lossy()\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "load_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 95
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:58:5: replace load_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(\"xyzzy\".into()))",
    "span": {
      "end": {
        "column": 34,
        "line": 94
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ delete ! in load_secret\n@@ -50,17 +50,17 @@\n             cipher\n         )));\n     }\n \n     Ok(raw[6..].to_vec())\n }\n \n pub fn load_secret(path: &Path, passphrase: &str) -> Result<Option<String>> {\n-    if !path.exists() {\n+    if  /* ~ changed by cargo-mutants ~ */path.exists() {\n         return Ok(None);\n     }\n \n     let mut file = File::open(path).map_err(|e| {\n         ButterflyBotError::SecurityStorage(format!(\n             \"failed to open encrypted secret {}: {e}\",\n             path.to_string_lossy()\n         ))\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "load_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 95
        },
        "start": {
          "column": 1,
          "line": 57
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/security/cocoon_store.rs:58:8: delete ! in load_secret",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 9,
        "line": 58
      },
      "start": {
        "column": 8,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/security/cocoon_store.rs\n+++ replace persist_secret -> Result<()> with Ok(())\n@@ -90,56 +90,17 @@\n             path.to_string_lossy()\n         )));\n     }\n \n     Ok(Some(trimmed.to_string()))\n }\n \n pub fn persist_secret(path: &Path, passphrase: &str, value: &str) -> Result<()> {\n-    if let Some(parent) = path.parent() {\n-        std::fs::create_dir_all(parent).map_err(|e| {\n-            ButterflyBotError::SecurityStorage(format!(\n-                \"failed to create encrypted secret directory {}: {e}\",\n-                parent.to_string_lossy()\n-            ))\n-        })?;\n-\n-        #[cfg(unix)]\n-        {\n-            use std::os::unix::fs::PermissionsExt;\n-            let _ = std::fs::set_permissions(parent, std::fs::Permissions::from_mode(0o700));\n-        }\n-    }\n-\n-    let mut file = File::create(path).map_err(|e| {\n-        ButterflyBotError::SecurityStorage(format!(\n-            \"failed to create encrypted secret {}: {e}\",\n-            path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let mut cocoon = Cocoon::new(passphrase.as_bytes());\n-    let payload = wrap_envelope(value.as_bytes());\n-    cocoon\n-        .dump(payload, &mut file)\n-        .map_err(|e| {\n-            ButterflyBotError::SecurityStorage(format!(\n-                \"failed to write encrypted secret {}: {e:?}\",\n-                path.to_string_lossy()\n-            ))\n-        })?;\n-\n-    #[cfg(unix)]\n-    {\n-        use std::os::unix::fs::PermissionsExt;\n-        let _ = std::fs::set_permissions(path, std::fs::Permissions::from_mode(0o600));\n-    }\n-\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     #[test]\n     fn cocoon_roundtrip_secret() {\n",
    "file": "src/security/cocoon_store.rs",
    "function": {
      "function_name": "persist_secret",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 138
        },
        "start": {
          "column": 1,
          "line": 97
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/cocoon_store.rs:98:5: replace persist_secret -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 137
      },
      "start": {
        "column": 5,
        "line": 98
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::new()))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::new())) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::new()))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::new()))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from_iter([None])))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from_iter([None]))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from_iter([None])))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from_iter([None])))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::new(None)))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::new(None))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::new(None)))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::new(None)))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from(None)))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from(None))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from(None)))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from(None)))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from_iter([Some(true)])))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from_iter([Some(true)]))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from_iter([Some(true)])))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from_iter([Some(true)])))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::new(Some(true))))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::new(Some(true)))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::new(Some(true))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::new(Some(true))))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from(Some(true))))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from(Some(true)))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from(Some(true))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from(Some(true))))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from_iter([Some(false)])))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from_iter([Some(false)]))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from_iter([Some(false)])))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from_iter([Some(false)])))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::new(Some(false))))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::new(Some(false)))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::new(Some(false))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::new(Some(false))))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from(Some(false))))\n@@ -14,18 +14,17 @@\n use std::sync::{OnceLock as DebugOnceLock, RwLock as DebugRwLock};\n \n const SERVICE: &str = \"butterfly-bot\";\n const TPM_KEK_NAME: &str = \"tpm_kek\";\n const POLICY_VERSION: u8 = 1;\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from(Some(false)))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_available_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<bool>>",
      "span": {
        "end": {
          "column": 2,
          "line": 24
        },
        "start": {
          "column": 1,
          "line": 20
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:22:5: replace debug_available_override_lock -> &'static DebugRwLock<Option<bool>> with Box::leak(Box::new(DebugRwLock::from(Some(false))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from(Some(false))))",
    "span": {
      "end": {
        "column": 52,
        "line": 23
      },
      "start": {
        "column": 5,
        "line": 22
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::new()))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::new())) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::new()))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::new()))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from_iter([None])))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from_iter([None]))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from_iter([None])))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from_iter([None])))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::new(None)))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::new(None))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::new(None)))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::new(None)))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from(None)))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from(None))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from(None)))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from(None)))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from_iter([Some(String::new())])))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from_iter([Some(String::new())]))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from_iter([Some(String::new())])))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from_iter([Some(String::new())])))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::new(Some(String::new()))))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::new(Some(String::new())))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::new(Some(String::new()))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::new(Some(String::new()))))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from(Some(String::new()))))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from(Some(String::new())))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from(Some(String::new()))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from(Some(String::new()))))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from_iter([Some(\"xyzzy\".into())])))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from_iter([Some(\"xyzzy\".into())]))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from_iter([Some(\"xyzzy\".into())])))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from_iter([Some(\"xyzzy\".into())])))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::new(Some(\"xyzzy\".into()))))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::new(Some(\"xyzzy\".into())))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::new(Some(\"xyzzy\".into()))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::new(Some(\"xyzzy\".into()))))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from(Some(\"xyzzy\".into()))))\n@@ -20,18 +20,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_available_override_lock() -> &'static DebugRwLock<Option<bool>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<bool>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n-    static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n-    OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n+    Box::leak(Box::new(DebugRwLock::from(Some(\"xyzzy\".into())))) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n     let lock = debug_available_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override_lock",
      "return_type": "-> &'static DebugRwLock<Option<String>>",
      "span": {
        "end": {
          "column": 2,
          "line": 30
        },
        "start": {
          "column": 1,
          "line": 26
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:28:5: replace debug_dek_override_lock -> &'static DebugRwLock<Option<String>> with Box::leak(Box::new(DebugRwLock::from(Some(\"xyzzy\".into()))))",
    "package": "butterfly-bot",
    "replacement": "Box::leak(Box::new(DebugRwLock::from(Some(\"xyzzy\".into()))))",
    "span": {
      "end": {
        "column": 52,
        "line": 29
      },
      "start": {
        "column": 5,
        "line": 28
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace set_debug_tpm_available_override with ()\n@@ -26,24 +26,17 @@\n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override_lock() -> &'static DebugRwLock<Option<String>> {\n     static OVERRIDE: DebugOnceLock<DebugRwLock<Option<String>>> = DebugOnceLock::new();\n     OVERRIDE.get_or_init(|| DebugRwLock::new(None))\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_tpm_available_override(value: Option<bool>) {\n-    let lock = debug_available_override_lock();\n-    match lock.write() {\n-        Ok(mut guard) => *guard = value,\n-        Err(poisoned) => {\n-            let mut guard = poisoned.into_inner();\n-            *guard = value;\n-        }\n-    }\n+    () /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_dek_passphrase_override(value: Option<String>) {\n     let lock = debug_dek_override_lock();\n     match lock.write() {\n         Ok(mut guard) => *guard = value,\n         Err(poisoned) => {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "set_debug_tpm_available_override",
      "return_type": "",
      "span": {
        "end": {
          "column": 2,
          "line": 42
        },
        "start": {
          "column": 1,
          "line": 32
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:34:5: replace set_debug_tpm_available_override with ()",
    "package": "butterfly-bot",
    "replacement": "()",
    "span": {
      "end": {
        "column": 6,
        "line": 41
      },
      "start": {
        "column": 5,
        "line": 34
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace set_debug_dek_passphrase_override with ()\n@@ -38,24 +38,17 @@\n             let mut guard = poisoned.into_inner();\n             *guard = value;\n         }\n     }\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n pub fn set_debug_dek_passphrase_override(value: Option<String>) {\n-    let lock = debug_dek_override_lock();\n-    match lock.write() {\n-        Ok(mut guard) => *guard = value,\n-        Err(poisoned) => {\n-            let mut guard = poisoned.into_inner();\n-            *guard = value;\n-        }\n-    }\n+    () /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_tpm_available_override() -> Option<bool> {\n     let lock = debug_available_override_lock();\n     match lock.read() {\n         Ok(guard) => *guard,\n         Err(poisoned) => *poisoned.into_inner(),\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "set_debug_dek_passphrase_override",
      "return_type": "",
      "span": {
        "end": {
          "column": 2,
          "line": 54
        },
        "start": {
          "column": 1,
          "line": 44
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:46:5: replace set_debug_dek_passphrase_override with ()",
    "package": "butterfly-bot",
    "replacement": "()",
    "span": {
      "end": {
        "column": 6,
        "line": 53
      },
      "start": {
        "column": 5,
        "line": 46
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_tpm_available_override -> Option<bool> with None\n@@ -50,21 +50,17 @@\n             let mut guard = poisoned.into_inner();\n             *guard = value;\n         }\n     }\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_tpm_available_override() -> Option<bool> {\n-    let lock = debug_available_override_lock();\n-    match lock.read() {\n-        Ok(guard) => *guard,\n-        Err(poisoned) => *poisoned.into_inner(),\n-    }\n+    None /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override() -> Option<String> {\n     let lock = debug_dek_override_lock();\n     match lock.read() {\n         Ok(guard) => guard.clone(),\n         Err(poisoned) => poisoned.into_inner().clone(),\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_tpm_available_override",
      "return_type": "-> Option<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 63
        },
        "start": {
          "column": 1,
          "line": 56
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:58:5: replace debug_tpm_available_override -> Option<bool> with None",
    "package": "butterfly-bot",
    "replacement": "None",
    "span": {
      "end": {
        "column": 6,
        "line": 62
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_tpm_available_override -> Option<bool> with Some(true)\n@@ -50,21 +50,17 @@\n             let mut guard = poisoned.into_inner();\n             *guard = value;\n         }\n     }\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_tpm_available_override() -> Option<bool> {\n-    let lock = debug_available_override_lock();\n-    match lock.read() {\n-        Ok(guard) => *guard,\n-        Err(poisoned) => *poisoned.into_inner(),\n-    }\n+    Some(true) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override() -> Option<String> {\n     let lock = debug_dek_override_lock();\n     match lock.read() {\n         Ok(guard) => guard.clone(),\n         Err(poisoned) => poisoned.into_inner().clone(),\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_tpm_available_override",
      "return_type": "-> Option<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 63
        },
        "start": {
          "column": 1,
          "line": 56
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:58:5: replace debug_tpm_available_override -> Option<bool> with Some(true)",
    "package": "butterfly-bot",
    "replacement": "Some(true)",
    "span": {
      "end": {
        "column": 6,
        "line": 62
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_tpm_available_override -> Option<bool> with Some(false)\n@@ -50,21 +50,17 @@\n             let mut guard = poisoned.into_inner();\n             *guard = value;\n         }\n     }\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_tpm_available_override() -> Option<bool> {\n-    let lock = debug_available_override_lock();\n-    match lock.read() {\n-        Ok(guard) => *guard,\n-        Err(poisoned) => *poisoned.into_inner(),\n-    }\n+    Some(false) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override() -> Option<String> {\n     let lock = debug_dek_override_lock();\n     match lock.read() {\n         Ok(guard) => guard.clone(),\n         Err(poisoned) => poisoned.into_inner().clone(),\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_tpm_available_override",
      "return_type": "-> Option<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 63
        },
        "start": {
          "column": 1,
          "line": 56
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:58:5: replace debug_tpm_available_override -> Option<bool> with Some(false)",
    "package": "butterfly-bot",
    "replacement": "Some(false)",
    "span": {
      "end": {
        "column": 6,
        "line": 62
      },
      "start": {
        "column": 5,
        "line": 58
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override -> Option<String> with None\n@@ -59,21 +59,17 @@\n     match lock.read() {\n         Ok(guard) => *guard,\n         Err(poisoned) => *poisoned.into_inner(),\n     }\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override() -> Option<String> {\n-    let lock = debug_dek_override_lock();\n-    match lock.read() {\n-        Ok(guard) => guard.clone(),\n-        Err(poisoned) => poisoned.into_inner().clone(),\n-    }\n+    None /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n fn available_override_lock() -> &'static RwLock<Option<bool>> {\n     static OVERRIDE: OnceLock<RwLock<Option<bool>>> = OnceLock::new();\n     OVERRIDE.get_or_init(|| RwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 72
        },
        "start": {
          "column": 1,
          "line": 65
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:67:5: replace debug_dek_override -> Option<String> with None",
    "package": "butterfly-bot",
    "replacement": "None",
    "span": {
      "end": {
        "column": 6,
        "line": 71
      },
      "start": {
        "column": 5,
        "line": 67
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override -> Option<String> with Some(String::new())\n@@ -59,21 +59,17 @@\n     match lock.read() {\n         Ok(guard) => *guard,\n         Err(poisoned) => *poisoned.into_inner(),\n     }\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override() -> Option<String> {\n-    let lock = debug_dek_override_lock();\n-    match lock.read() {\n-        Ok(guard) => guard.clone(),\n-        Err(poisoned) => poisoned.into_inner().clone(),\n-    }\n+    Some(String::new()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n fn available_override_lock() -> &'static RwLock<Option<bool>> {\n     static OVERRIDE: OnceLock<RwLock<Option<bool>>> = OnceLock::new();\n     OVERRIDE.get_or_init(|| RwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 72
        },
        "start": {
          "column": 1,
          "line": 65
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:67:5: replace debug_dek_override -> Option<String> with Some(String::new())",
    "package": "butterfly-bot",
    "replacement": "Some(String::new())",
    "span": {
      "end": {
        "column": 6,
        "line": 71
      },
      "start": {
        "column": 5,
        "line": 67
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace debug_dek_override -> Option<String> with Some(\"xyzzy\".into())\n@@ -59,21 +59,17 @@\n     match lock.read() {\n         Ok(guard) => *guard,\n         Err(poisoned) => *poisoned.into_inner(),\n     }\n }\n \n #[cfg(all(debug_assertions, not(test)))]\n fn debug_dek_override() -> Option<String> {\n-    let lock = debug_dek_override_lock();\n-    match lock.read() {\n-        Ok(guard) => guard.clone(),\n-        Err(poisoned) => poisoned.into_inner().clone(),\n-    }\n+    Some(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n fn available_override_lock() -> &'static RwLock<Option<bool>> {\n     static OVERRIDE: OnceLock<RwLock<Option<bool>>> = OnceLock::new();\n     OVERRIDE.get_or_init(|| RwLock::new(None))\n }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "debug_dek_override",
      "return_type": "-> Option<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 72
        },
        "start": {
          "column": 1,
          "line": 65
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:67:5: replace debug_dek_override -> Option<String> with Some(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Some(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 6,
        "line": 71
      },
      "start": {
        "column": 5,
        "line": 67
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace DeviceTpmBackend::active_device_path -> Option<&'static Path> with None\n@@ -154,23 +154,17 @@\n     fn set_kek(&self, value: &str) -> Result<()>;\n     fn clear_kek(&self) -> Result<()>;\n }\n \n struct DeviceTpmBackend;\n \n impl DeviceTpmBackend {\n     fn active_device_path(&self) -> Option<&'static Path> {\n-        if Path::new(\"/dev/tpmrm0\").exists() {\n-            return Some(Path::new(\"/dev/tpmrm0\"));\n-        }\n-        if Path::new(\"/dev/tpm0\").exists() {\n-            return Some(Path::new(\"/dev/tpm0\"));\n-        }\n-        None\n+        None /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n impl TpmBackend for DeviceTpmBackend {\n     fn is_present(&self) -> bool {\n         #[cfg(target_os = \"linux\")]\n         {\n             self.active_device_path().is_some()\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "DeviceTpmBackend::active_device_path",
      "return_type": "-> Option<&'static Path>",
      "span": {
        "end": {
          "column": 6,
          "line": 169
        },
        "start": {
          "column": 5,
          "line": 161
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:162:9: replace DeviceTpmBackend::active_device_path -> Option<&'static Path> with None",
    "package": "butterfly-bot",
    "replacement": "None",
    "span": {
      "end": {
        "column": 13,
        "line": 168
      },
      "start": {
        "column": 9,
        "line": 162
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace DeviceTpmBackend::active_device_path -> Option<&'static Path> with Some(Box::leak(Box::new(Default::default())))\n@@ -154,23 +154,17 @@\n     fn set_kek(&self, value: &str) -> Result<()>;\n     fn clear_kek(&self) -> Result<()>;\n }\n \n struct DeviceTpmBackend;\n \n impl DeviceTpmBackend {\n     fn active_device_path(&self) -> Option<&'static Path> {\n-        if Path::new(\"/dev/tpmrm0\").exists() {\n-            return Some(Path::new(\"/dev/tpmrm0\"));\n-        }\n-        if Path::new(\"/dev/tpm0\").exists() {\n-            return Some(Path::new(\"/dev/tpm0\"));\n-        }\n-        None\n+        Some(Box::leak(Box::new(Default::default()))) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n impl TpmBackend for DeviceTpmBackend {\n     fn is_present(&self) -> bool {\n         #[cfg(target_os = \"linux\")]\n         {\n             self.active_device_path().is_some()\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "DeviceTpmBackend::active_device_path",
      "return_type": "-> Option<&'static Path>",
      "span": {
        "end": {
          "column": 6,
          "line": 169
        },
        "start": {
          "column": 5,
          "line": 161
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:162:9: replace DeviceTpmBackend::active_device_path -> Option<&'static Path> with Some(Box::leak(Box::new(Default::default())))",
    "package": "butterfly-bot",
    "replacement": "Some(Box::leak(Box::new(Default::default())))",
    "span": {
      "end": {
        "column": 13,
        "line": 168
      },
      "start": {
        "column": 9,
        "line": 162
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace <impl TpmBackend for DeviceTpmBackend>::is_present -> bool with true\n@@ -166,24 +166,17 @@\n             return Some(Path::new(\"/dev/tpm0\"));\n         }\n         None\n     }\n }\n \n impl TpmBackend for DeviceTpmBackend {\n     fn is_present(&self) -> bool {\n-        #[cfg(target_os = \"linux\")]\n-        {\n-            self.active_device_path().is_some()\n-        }\n-        #[cfg(not(target_os = \"linux\"))]\n-        {\n-            false\n-        }\n+        true /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn fingerprint(&self) -> Result<String> {\n         let path = self.active_device_path().ok_or_else(|| {\n             ButterflyBotError::SecurityPolicy(\n                 \"TPM is required in strict mode; no TPM device found\".to_string(),\n             )\n         })?;\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "<impl TpmBackend for DeviceTpmBackend>::is_present",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 182
        },
        "start": {
          "column": 5,
          "line": 173
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:174:9: replace <impl TpmBackend for DeviceTpmBackend>::is_present -> bool with true",
    "package": "butterfly-bot",
    "replacement": "true",
    "span": {
      "end": {
        "column": 10,
        "line": 181
      },
      "start": {
        "column": 9,
        "line": 174
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace <impl TpmBackend for DeviceTpmBackend>::is_present -> bool with false\n@@ -166,24 +166,17 @@\n             return Some(Path::new(\"/dev/tpm0\"));\n         }\n         None\n     }\n }\n \n impl TpmBackend for DeviceTpmBackend {\n     fn is_present(&self) -> bool {\n-        #[cfg(target_os = \"linux\")]\n-        {\n-            self.active_device_path().is_some()\n-        }\n-        #[cfg(not(target_os = \"linux\"))]\n-        {\n-            false\n-        }\n+        false /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn fingerprint(&self) -> Result<String> {\n         let path = self.active_device_path().ok_or_else(|| {\n             ButterflyBotError::SecurityPolicy(\n                 \"TPM is required in strict mode; no TPM device found\".to_string(),\n             )\n         })?;\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "<impl TpmBackend for DeviceTpmBackend>::is_present",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 182
        },
        "start": {
          "column": 5,
          "line": 173
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:174:9: replace <impl TpmBackend for DeviceTpmBackend>::is_present -> bool with false",
    "package": "butterfly-bot",
    "replacement": "false",
    "span": {
      "end": {
        "column": 10,
        "line": 181
      },
      "start": {
        "column": 9,
        "line": 174
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace <impl TpmBackend for DeviceTpmBackend>::fingerprint -> Result<String> with Ok(String::new())\n@@ -177,39 +177,17 @@\n         }\n         #[cfg(not(target_os = \"linux\"))]\n         {\n             false\n         }\n     }\n \n     fn fingerprint(&self) -> Result<String> {\n-        let path = self.active_device_path().ok_or_else(|| {\n-            ButterflyBotError::SecurityPolicy(\n-                \"TPM is required in strict mode; no TPM device found\".to_string(),\n-            )\n-        })?;\n-\n-        let mut hasher = Sha256::new();\n-        hasher.update(path.to_string_lossy().as_bytes());\n-\n-        if let Ok(meta) = std::fs::metadata(path) {\n-            hasher.update(meta.len().to_le_bytes());\n-            if let Ok(modified) = meta.modified() {\n-                if let Ok(duration) = modified.duration_since(std::time::UNIX_EPOCH) {\n-                    hasher.update(duration.as_secs().to_le_bytes());\n-                }\n-            }\n-        }\n-\n-        if let Ok(uevent) = std::fs::read(\"/sys/class/tpm/tpm0/device/uevent\") {\n-            hasher.update(uevent);\n-        }\n-\n-        Ok(format!(\"{:x}\", hasher.finalize()))\n+        Ok(String::new()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n struct KeyringKekStore;\n \n impl KekStore for KeyringKekStore {\n     fn get_kek(&self) -> Result<Option<String>> {\n         let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "<impl TpmBackend for DeviceTpmBackend>::fingerprint",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 208
        },
        "start": {
          "column": 5,
          "line": 184
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:185:9: replace <impl TpmBackend for DeviceTpmBackend>::fingerprint -> Result<String> with Ok(String::new())",
    "package": "butterfly-bot",
    "replacement": "Ok(String::new())",
    "span": {
      "end": {
        "column": 47,
        "line": 207
      },
      "start": {
        "column": 9,
        "line": 185
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace <impl TpmBackend for DeviceTpmBackend>::fingerprint -> Result<String> with Ok(\"xyzzy\".into())\n@@ -177,39 +177,17 @@\n         }\n         #[cfg(not(target_os = \"linux\"))]\n         {\n             false\n         }\n     }\n \n     fn fingerprint(&self) -> Result<String> {\n-        let path = self.active_device_path().ok_or_else(|| {\n-            ButterflyBotError::SecurityPolicy(\n-                \"TPM is required in strict mode; no TPM device found\".to_string(),\n-            )\n-        })?;\n-\n-        let mut hasher = Sha256::new();\n-        hasher.update(path.to_string_lossy().as_bytes());\n-\n-        if let Ok(meta) = std::fs::metadata(path) {\n-            hasher.update(meta.len().to_le_bytes());\n-            if let Ok(modified) = meta.modified() {\n-                if let Ok(duration) = modified.duration_since(std::time::UNIX_EPOCH) {\n-                    hasher.update(duration.as_secs().to_le_bytes());\n-                }\n-            }\n-        }\n-\n-        if let Ok(uevent) = std::fs::read(\"/sys/class/tpm/tpm0/device/uevent\") {\n-            hasher.update(uevent);\n-        }\n-\n-        Ok(format!(\"{:x}\", hasher.finalize()))\n+        Ok(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n struct KeyringKekStore;\n \n impl KekStore for KeyringKekStore {\n     fn get_kek(&self) -> Result<Option<String>> {\n         let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "<impl TpmBackend for DeviceTpmBackend>::fingerprint",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 208
        },
        "start": {
          "column": 5,
          "line": 184
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:185:9: replace <impl TpmBackend for DeviceTpmBackend>::fingerprint -> Result<String> with Ok(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Ok(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 47,
        "line": 207
      },
      "start": {
        "column": 9,
        "line": 185
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace <impl KekStore for KeyringKekStore>::get_kek -> Result<Option<String>> with Ok(None)\n@@ -207,30 +207,17 @@\n         Ok(format!(\"{:x}\", hasher.finalize()))\n     }\n }\n \n struct KeyringKekStore;\n \n impl KekStore for KeyringKekStore {\n     fn get_kek(&self) -> Result<Option<String>> {\n-        let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        match entry.get_password() {\n-            Ok(value) => {\n-                let trimmed = value.trim().to_string();\n-                if trimmed.is_empty() {\n-                    Ok(None)\n-                } else {\n-                    Ok(Some(trimmed))\n-                }\n-            }\n-            Err(keyring::Error::NoEntry) => Ok(None),\n-            Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n-        }\n+        Ok(None) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn set_kek(&self, value: &str) -> Result<()> {\n         let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         entry\n             .set_password(value)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "<impl KekStore for KeyringKekStore>::get_kek",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 229
        },
        "start": {
          "column": 5,
          "line": 214
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:215:9: replace <impl KekStore for KeyringKekStore>::get_kek -> Result<Option<String>> with Ok(None)",
    "package": "butterfly-bot",
    "replacement": "Ok(None)",
    "span": {
      "end": {
        "column": 10,
        "line": 228
      },
      "start": {
        "column": 9,
        "line": 215
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace <impl KekStore for KeyringKekStore>::get_kek -> Result<Option<String>> with Ok(Some(String::new()))\n@@ -207,30 +207,17 @@\n         Ok(format!(\"{:x}\", hasher.finalize()))\n     }\n }\n \n struct KeyringKekStore;\n \n impl KekStore for KeyringKekStore {\n     fn get_kek(&self) -> Result<Option<String>> {\n-        let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        match entry.get_password() {\n-            Ok(value) => {\n-                let trimmed = value.trim().to_string();\n-                if trimmed.is_empty() {\n-                    Ok(None)\n-                } else {\n-                    Ok(Some(trimmed))\n-                }\n-            }\n-            Err(keyring::Error::NoEntry) => Ok(None),\n-            Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n-        }\n+        Ok(Some(String::new())) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn set_kek(&self, value: &str) -> Result<()> {\n         let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         entry\n             .set_password(value)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "<impl KekStore for KeyringKekStore>::get_kek",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 229
        },
        "start": {
          "column": 5,
          "line": 214
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:215:9: replace <impl KekStore for KeyringKekStore>::get_kek -> Result<Option<String>> with Ok(Some(String::new()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(String::new()))",
    "span": {
      "end": {
        "column": 10,
        "line": 228
      },
      "start": {
        "column": 9,
        "line": 215
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace <impl KekStore for KeyringKekStore>::get_kek -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))\n@@ -207,30 +207,17 @@\n         Ok(format!(\"{:x}\", hasher.finalize()))\n     }\n }\n \n struct KeyringKekStore;\n \n impl KekStore for KeyringKekStore {\n     fn get_kek(&self) -> Result<Option<String>> {\n-        let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        match entry.get_password() {\n-            Ok(value) => {\n-                let trimmed = value.trim().to_string();\n-                if trimmed.is_empty() {\n-                    Ok(None)\n-                } else {\n-                    Ok(Some(trimmed))\n-                }\n-            }\n-            Err(keyring::Error::NoEntry) => Ok(None),\n-            Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n-        }\n+        Ok(Some(\"xyzzy\".into())) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn set_kek(&self, value: &str) -> Result<()> {\n         let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         entry\n             .set_password(value)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "<impl KekStore for KeyringKekStore>::get_kek",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 229
        },
        "start": {
          "column": 5,
          "line": 214
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:215:9: replace <impl KekStore for KeyringKekStore>::get_kek -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(\"xyzzy\".into()))",
    "span": {
      "end": {
        "column": 10,
        "line": 228
      },
      "start": {
        "column": 9,
        "line": 215
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace <impl KekStore for KeyringKekStore>::set_kek -> Result<()> with Ok(())\n@@ -224,21 +224,17 @@\n                 }\n             }\n             Err(keyring::Error::NoEntry) => Ok(None),\n             Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n         }\n     }\n \n     fn set_kek(&self, value: &str) -> Result<()> {\n-        let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        entry\n-            .set_password(value)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn clear_kek(&self) -> Result<()> {\n         let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         match entry.delete_credential() {\n             Ok(()) | Err(keyring::Error::NoEntry) => Ok(()),\n             Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "<impl KekStore for KeyringKekStore>::set_kek",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 237
        },
        "start": {
          "column": 5,
          "line": 231
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:232:9: replace <impl KekStore for KeyringKekStore>::set_kek -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 76,
        "line": 236
      },
      "start": {
        "column": 9,
        "line": 232
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace <impl KekStore for KeyringKekStore>::clear_kek -> Result<()> with Ok(())\n@@ -232,22 +232,17 @@\n         let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         entry\n             .set_password(value)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))\n     }\n \n     fn clear_kek(&self) -> Result<()> {\n-        let entry = keyring::Entry::new(SERVICE, TPM_KEK_NAME)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        match entry.delete_credential() {\n-            Ok(()) | Err(keyring::Error::NoEntry) => Ok(()),\n-            Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n-        }\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n struct TpmRuntime<'a, B: TpmBackend, K: KekStore> {\n     backend: &'a B,\n     kek_store: &'a K,\n     security_root: PathBuf,\n }\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "<impl KekStore for KeyringKekStore>::clear_kek",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 246
        },
        "start": {
          "column": 5,
          "line": 239
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:240:9: replace <impl KekStore for KeyringKekStore>::clear_kek -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 10,
        "line": 245
      },
      "start": {
        "column": 9,
        "line": 240
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::policy_state_path -> PathBuf with Default::default()\n@@ -249,17 +249,17 @@\n struct TpmRuntime<'a, B: TpmBackend, K: KekStore> {\n     backend: &'a B,\n     kek_store: &'a K,\n     security_root: PathBuf,\n }\n \n impl<'a, B: TpmBackend, K: KekStore> TpmRuntime<'a, B, K> {\n     fn policy_state_path(&self) -> PathBuf {\n-        self.security_root.join(\"tpm_policy_state.json\")\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn wrapped_dek_path(&self) -> PathBuf {\n         self.security_root.join(\"wrapped_dek.cocoon\")\n     }\n \n     fn ensure_root(&self) -> Result<()> {\n         std::fs::create_dir_all(&self.security_root).map_err(|e| {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::policy_state_path",
      "return_type": "-> PathBuf",
      "span": {
        "end": {
          "column": 6,
          "line": 258
        },
        "start": {
          "column": 5,
          "line": 256
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:257:9: replace TpmRuntime<'a, B, K>::policy_state_path -> PathBuf with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 57,
        "line": 257
      },
      "start": {
        "column": 9,
        "line": 257
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::wrapped_dek_path -> PathBuf with Default::default()\n@@ -253,17 +253,17 @@\n }\n \n impl<'a, B: TpmBackend, K: KekStore> TpmRuntime<'a, B, K> {\n     fn policy_state_path(&self) -> PathBuf {\n         self.security_root.join(\"tpm_policy_state.json\")\n     }\n \n     fn wrapped_dek_path(&self) -> PathBuf {\n-        self.security_root.join(\"wrapped_dek.cocoon\")\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn ensure_root(&self) -> Result<()> {\n         std::fs::create_dir_all(&self.security_root).map_err(|e| {\n             ButterflyBotError::SecurityStorage(format!(\n                 \"failed to create security root {}: {e}\",\n                 self.security_root.to_string_lossy()\n             ))\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::wrapped_dek_path",
      "return_type": "-> PathBuf",
      "span": {
        "end": {
          "column": 6,
          "line": 262
        },
        "start": {
          "column": 5,
          "line": 260
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:261:9: replace TpmRuntime<'a, B, K>::wrapped_dek_path -> PathBuf with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 54,
        "line": 261
      },
      "start": {
        "column": 9,
        "line": 261
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::ensure_root -> Result<()> with Ok(())\n@@ -257,22 +257,17 @@\n         self.security_root.join(\"tpm_policy_state.json\")\n     }\n \n     fn wrapped_dek_path(&self) -> PathBuf {\n         self.security_root.join(\"wrapped_dek.cocoon\")\n     }\n \n     fn ensure_root(&self) -> Result<()> {\n-        std::fs::create_dir_all(&self.security_root).map_err(|e| {\n-            ButterflyBotError::SecurityStorage(format!(\n-                \"failed to create security root {}: {e}\",\n-                self.security_root.to_string_lossy()\n-            ))\n-        })\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn load_policy_state(&self) -> Result<Option<TpmPolicyState>> {\n         let path = self.policy_state_path();\n         if !path.exists() {\n             return Ok(None);\n         }\n         let raw = std::fs::read_to_string(&path).map_err(|e| {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::ensure_root",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 271
        },
        "start": {
          "column": 5,
          "line": 264
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:265:9: replace TpmRuntime<'a, B, K>::ensure_root -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 270
      },
      "start": {
        "column": 9,
        "line": 265
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::load_policy_state -> Result<Option<TpmPolicyState>> with Ok(None)\n@@ -266,33 +266,17 @@\n             ButterflyBotError::SecurityStorage(format!(\n                 \"failed to create security root {}: {e}\",\n                 self.security_root.to_string_lossy()\n             ))\n         })\n     }\n \n     fn load_policy_state(&self) -> Result<Option<TpmPolicyState>> {\n-        let path = self.policy_state_path();\n-        if !path.exists() {\n-            return Ok(None);\n-        }\n-        let raw = std::fs::read_to_string(&path).map_err(|e| {\n-            ButterflyBotError::SecurityStorage(format!(\n-                \"failed to read TPM policy state {}: {e}\",\n-                path.to_string_lossy()\n-            ))\n-        })?;\n-        let state: TpmPolicyState = serde_json::from_str(&raw).map_err(|e| {\n-            ButterflyBotError::SecurityStorage(format!(\n-                \"failed to parse TPM policy state {}: {e}\",\n-                path.to_string_lossy()\n-            ))\n-        })?;\n-        Ok(Some(state))\n+        Ok(None) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn save_policy_state(&self, state: TpmPolicyState) -> Result<()> {\n         self.ensure_root()?;\n         let path = self.policy_state_path();\n         let payload = serde_json::to_string_pretty(&state)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         std::fs::write(&path, payload).map_err(|e| {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::load_policy_state",
      "return_type": "-> Result<Option<TpmPolicyState>>",
      "span": {
        "end": {
          "column": 6,
          "line": 291
        },
        "start": {
          "column": 5,
          "line": 273
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:274:9: replace TpmRuntime<'a, B, K>::load_policy_state -> Result<Option<TpmPolicyState>> with Ok(None)",
    "package": "butterfly-bot",
    "replacement": "Ok(None)",
    "span": {
      "end": {
        "column": 24,
        "line": 290
      },
      "start": {
        "column": 9,
        "line": 274
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::load_policy_state -> Result<Option<TpmPolicyState>> with Ok(Some(Default::default()))\n@@ -266,33 +266,17 @@\n             ButterflyBotError::SecurityStorage(format!(\n                 \"failed to create security root {}: {e}\",\n                 self.security_root.to_string_lossy()\n             ))\n         })\n     }\n \n     fn load_policy_state(&self) -> Result<Option<TpmPolicyState>> {\n-        let path = self.policy_state_path();\n-        if !path.exists() {\n-            return Ok(None);\n-        }\n-        let raw = std::fs::read_to_string(&path).map_err(|e| {\n-            ButterflyBotError::SecurityStorage(format!(\n-                \"failed to read TPM policy state {}: {e}\",\n-                path.to_string_lossy()\n-            ))\n-        })?;\n-        let state: TpmPolicyState = serde_json::from_str(&raw).map_err(|e| {\n-            ButterflyBotError::SecurityStorage(format!(\n-                \"failed to parse TPM policy state {}: {e}\",\n-                path.to_string_lossy()\n-            ))\n-        })?;\n-        Ok(Some(state))\n+        Ok(Some(Default::default())) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn save_policy_state(&self, state: TpmPolicyState) -> Result<()> {\n         self.ensure_root()?;\n         let path = self.policy_state_path();\n         let payload = serde_json::to_string_pretty(&state)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         std::fs::write(&path, payload).map_err(|e| {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::load_policy_state",
      "return_type": "-> Result<Option<TpmPolicyState>>",
      "span": {
        "end": {
          "column": 6,
          "line": 291
        },
        "start": {
          "column": 5,
          "line": 273
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:274:9: replace TpmRuntime<'a, B, K>::load_policy_state -> Result<Option<TpmPolicyState>> with Ok(Some(Default::default()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(Default::default()))",
    "span": {
      "end": {
        "column": 24,
        "line": 290
      },
      "start": {
        "column": 9,
        "line": 274
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ delete ! in TpmRuntime<'a, B, K>::load_policy_state\n@@ -267,17 +267,17 @@\n                 \"failed to create security root {}: {e}\",\n                 self.security_root.to_string_lossy()\n             ))\n         })\n     }\n \n     fn load_policy_state(&self) -> Result<Option<TpmPolicyState>> {\n         let path = self.policy_state_path();\n-        if !path.exists() {\n+        if  /* ~ changed by cargo-mutants ~ */path.exists() {\n             return Ok(None);\n         }\n         let raw = std::fs::read_to_string(&path).map_err(|e| {\n             ButterflyBotError::SecurityStorage(format!(\n                 \"failed to read TPM policy state {}: {e}\",\n                 path.to_string_lossy()\n             ))\n         })?;\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::load_policy_state",
      "return_type": "-> Result<Option<TpmPolicyState>>",
      "span": {
        "end": {
          "column": 6,
          "line": 291
        },
        "start": {
          "column": 5,
          "line": 273
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/security/tpm_provider.rs:275:12: delete ! in TpmRuntime<'a, B, K>::load_policy_state",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 13,
        "line": 275
      },
      "start": {
        "column": 12,
        "line": 275
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::save_policy_state -> Result<()> with Ok(())\n@@ -286,26 +286,17 @@\n                 \"failed to parse TPM policy state {}: {e}\",\n                 path.to_string_lossy()\n             ))\n         })?;\n         Ok(Some(state))\n     }\n \n     fn save_policy_state(&self, state: TpmPolicyState) -> Result<()> {\n-        self.ensure_root()?;\n-        let path = self.policy_state_path();\n-        let payload = serde_json::to_string_pretty(&state)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        std::fs::write(&path, payload).map_err(|e| {\n-            ButterflyBotError::SecurityStorage(format!(\n-                \"failed to write TPM policy state {}: {e}\",\n-                path.to_string_lossy()\n-            ))\n-        })\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn random_secret() -> Result<String> {\n         let mut bytes = [0u8; 32];\n         let mut rng = SysRng;\n         rng.try_fill_bytes(&mut bytes)\n             .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n         Ok(URL_SAFE_NO_PAD.encode(bytes))\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::save_policy_state",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 304
        },
        "start": {
          "column": 5,
          "line": 293
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:294:9: replace TpmRuntime<'a, B, K>::save_policy_state -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 303
      },
      "start": {
        "column": 9,
        "line": 294
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::random_secret -> Result<String> with Ok(String::new())\n@@ -299,21 +299,17 @@\n             ButterflyBotError::SecurityStorage(format!(\n                 \"failed to write TPM policy state {}: {e}\",\n                 path.to_string_lossy()\n             ))\n         })\n     }\n \n     fn random_secret() -> Result<String> {\n-        let mut bytes = [0u8; 32];\n-        let mut rng = SysRng;\n-        rng.try_fill_bytes(&mut bytes)\n-            .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-        Ok(URL_SAFE_NO_PAD.encode(bytes))\n+        Ok(String::new()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn lockout_like(err: &ButterflyBotError) -> bool {\n         let lowered = err.to_string().to_ascii_lowercase();\n         lowered.contains(\"lockout\") || lowered.contains(\"locked\") || lowered.contains(\"auth\")\n     }\n \n     fn missing_tpm_error() -> ButterflyBotError {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::random_secret",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 312
        },
        "start": {
          "column": 5,
          "line": 306
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:307:9: replace TpmRuntime<'a, B, K>::random_secret -> Result<String> with Ok(String::new())",
    "package": "butterfly-bot",
    "replacement": "Ok(String::new())",
    "span": {
      "end": {
        "column": 42,
        "line": 311
      },
      "start": {
        "column": 9,
        "line": 307
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::random_secret -> Result<String> with Ok(\"xyzzy\".into())\n@@ -299,21 +299,17 @@\n             ButterflyBotError::SecurityStorage(format!(\n                 \"failed to write TPM policy state {}: {e}\",\n                 path.to_string_lossy()\n             ))\n         })\n     }\n \n     fn random_secret() -> Result<String> {\n-        let mut bytes = [0u8; 32];\n-        let mut rng = SysRng;\n-        rng.try_fill_bytes(&mut bytes)\n-            .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-        Ok(URL_SAFE_NO_PAD.encode(bytes))\n+        Ok(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn lockout_like(err: &ButterflyBotError) -> bool {\n         let lowered = err.to_string().to_ascii_lowercase();\n         lowered.contains(\"lockout\") || lowered.contains(\"locked\") || lowered.contains(\"auth\")\n     }\n \n     fn missing_tpm_error() -> ButterflyBotError {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::random_secret",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 312
        },
        "start": {
          "column": 5,
          "line": 306
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:307:9: replace TpmRuntime<'a, B, K>::random_secret -> Result<String> with Ok(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Ok(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 42,
        "line": 311
      },
      "start": {
        "column": 9,
        "line": 307
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::lockout_like -> bool with true\n@@ -307,18 +307,17 @@\n         let mut bytes = [0u8; 32];\n         let mut rng = SysRng;\n         rng.try_fill_bytes(&mut bytes)\n             .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n         Ok(URL_SAFE_NO_PAD.encode(bytes))\n     }\n \n     fn lockout_like(err: &ButterflyBotError) -> bool {\n-        let lowered = err.to_string().to_ascii_lowercase();\n-        lowered.contains(\"lockout\") || lowered.contains(\"locked\") || lowered.contains(\"auth\")\n+        true /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn missing_tpm_error() -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(\n             \"TPM is required in strict mode; no TPM device found\".to_string(),\n         )\n     }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::lockout_like",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 317
        },
        "start": {
          "column": 5,
          "line": 314
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:315:9: replace TpmRuntime<'a, B, K>::lockout_like -> bool with true",
    "package": "butterfly-bot",
    "replacement": "true",
    "span": {
      "end": {
        "column": 94,
        "line": 316
      },
      "start": {
        "column": 9,
        "line": 315
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::lockout_like -> bool with false\n@@ -307,18 +307,17 @@\n         let mut bytes = [0u8; 32];\n         let mut rng = SysRng;\n         rng.try_fill_bytes(&mut bytes)\n             .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n         Ok(URL_SAFE_NO_PAD.encode(bytes))\n     }\n \n     fn lockout_like(err: &ButterflyBotError) -> bool {\n-        let lowered = err.to_string().to_ascii_lowercase();\n-        lowered.contains(\"lockout\") || lowered.contains(\"locked\") || lowered.contains(\"auth\")\n+        false /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn missing_tpm_error() -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(\n             \"TPM is required in strict mode; no TPM device found\".to_string(),\n         )\n     }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::lockout_like",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 317
        },
        "start": {
          "column": 5,
          "line": 314
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:315:9: replace TpmRuntime<'a, B, K>::lockout_like -> bool with false",
    "package": "butterfly-bot",
    "replacement": "false",
    "span": {
      "end": {
        "column": 94,
        "line": 316
      },
      "start": {
        "column": 9,
        "line": 315
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace || with && in TpmRuntime<'a, B, K>::lockout_like\n@@ -308,17 +308,17 @@\n         let mut rng = SysRng;\n         rng.try_fill_bytes(&mut bytes)\n             .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n         Ok(URL_SAFE_NO_PAD.encode(bytes))\n     }\n \n     fn lockout_like(err: &ButterflyBotError) -> bool {\n         let lowered = err.to_string().to_ascii_lowercase();\n-        lowered.contains(\"lockout\") || lowered.contains(\"locked\") || lowered.contains(\"auth\")\n+        lowered.contains(\"lockout\") || lowered.contains(\"locked\") && /* ~ changed by cargo-mutants ~ */ lowered.contains(\"auth\")\n     }\n \n     fn missing_tpm_error() -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(\n             \"TPM is required in strict mode; no TPM device found\".to_string(),\n         )\n     }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::lockout_like",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 317
        },
        "start": {
          "column": 5,
          "line": 314
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/tpm_provider.rs:316:67: replace || with && in TpmRuntime<'a, B, K>::lockout_like",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 69,
        "line": 316
      },
      "start": {
        "column": 67,
        "line": 316
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace || with && in TpmRuntime<'a, B, K>::lockout_like\n@@ -308,17 +308,17 @@\n         let mut rng = SysRng;\n         rng.try_fill_bytes(&mut bytes)\n             .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n         Ok(URL_SAFE_NO_PAD.encode(bytes))\n     }\n \n     fn lockout_like(err: &ButterflyBotError) -> bool {\n         let lowered = err.to_string().to_ascii_lowercase();\n-        lowered.contains(\"lockout\") || lowered.contains(\"locked\") || lowered.contains(\"auth\")\n+        lowered.contains(\"lockout\") && /* ~ changed by cargo-mutants ~ */ lowered.contains(\"locked\") || lowered.contains(\"auth\")\n     }\n \n     fn missing_tpm_error() -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(\n             \"TPM is required in strict mode; no TPM device found\".to_string(),\n         )\n     }\n \n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::lockout_like",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 317
        },
        "start": {
          "column": 5,
          "line": 314
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/tpm_provider.rs:316:37: replace || with && in TpmRuntime<'a, B, K>::lockout_like",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 39,
        "line": 316
      },
      "start": {
        "column": 37,
        "line": 316
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::missing_tpm_error -> ButterflyBotError with Default::default()\n@@ -312,19 +312,17 @@\n     }\n \n     fn lockout_like(err: &ButterflyBotError) -> bool {\n         let lowered = err.to_string().to_ascii_lowercase();\n         lowered.contains(\"lockout\") || lowered.contains(\"locked\") || lowered.contains(\"auth\")\n     }\n \n     fn missing_tpm_error() -> ButterflyBotError {\n-        ButterflyBotError::SecurityPolicy(\n-            \"TPM is required in strict mode; no TPM device found\".to_string(),\n-        )\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn reset_error(detail: &str) -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(format!(\n             \"TPM reset or reprovision detected ({detail}). Recovery runbook: {}\",\n             recovery_runbook()\n         ))\n     }\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::missing_tpm_error",
      "return_type": "-> ButterflyBotError",
      "span": {
        "end": {
          "column": 6,
          "line": 323
        },
        "start": {
          "column": 5,
          "line": 319
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:320:9: replace TpmRuntime<'a, B, K>::missing_tpm_error -> ButterflyBotError with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 10,
        "line": 322
      },
      "start": {
        "column": 9,
        "line": 320
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::reset_error -> ButterflyBotError with Default::default()\n@@ -318,20 +318,17 @@\n \n     fn missing_tpm_error() -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(\n             \"TPM is required in strict mode; no TPM device found\".to_string(),\n         )\n     }\n \n     fn reset_error(detail: &str) -> ButterflyBotError {\n-        ButterflyBotError::SecurityPolicy(format!(\n-            \"TPM reset or reprovision detected ({detail}). Recovery runbook: {}\",\n-            recovery_runbook()\n-        ))\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn policy_mismatch_error() -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(format!(\n             \"TPM policy mismatch detected. Recovery runbook: {}\",\n             recovery_runbook()\n         ))\n     }\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::reset_error",
      "return_type": "-> ButterflyBotError",
      "span": {
        "end": {
          "column": 6,
          "line": 330
        },
        "start": {
          "column": 5,
          "line": 325
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:326:9: replace TpmRuntime<'a, B, K>::reset_error -> ButterflyBotError with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 11,
        "line": 329
      },
      "start": {
        "column": 9,
        "line": 326
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::policy_mismatch_error -> ButterflyBotError with Default::default()\n@@ -325,20 +325,17 @@\n     fn reset_error(detail: &str) -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(format!(\n             \"TPM reset or reprovision detected ({detail}). Recovery runbook: {}\",\n             recovery_runbook()\n         ))\n     }\n \n     fn policy_mismatch_error() -> ButterflyBotError {\n-        ButterflyBotError::SecurityPolicy(format!(\n-            \"TPM policy mismatch detected. Recovery runbook: {}\",\n-            recovery_runbook()\n-        ))\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn lockout_error() -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(format!(\n             \"TPM lockout/auth failure detected. Recovery runbook: {}\",\n             recovery_runbook()\n         ))\n     }\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::policy_mismatch_error",
      "return_type": "-> ButterflyBotError",
      "span": {
        "end": {
          "column": 6,
          "line": 337
        },
        "start": {
          "column": 5,
          "line": 332
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:333:9: replace TpmRuntime<'a, B, K>::policy_mismatch_error -> ButterflyBotError with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 11,
        "line": 336
      },
      "start": {
        "column": 9,
        "line": 333
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::lockout_error -> ButterflyBotError with Default::default()\n@@ -332,20 +332,17 @@\n     fn policy_mismatch_error() -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(format!(\n             \"TPM policy mismatch detected. Recovery runbook: {}\",\n             recovery_runbook()\n         ))\n     }\n \n     fn lockout_error() -> ButterflyBotError {\n-        ButterflyBotError::SecurityPolicy(format!(\n-            \"TPM lockout/auth failure detected. Recovery runbook: {}\",\n-            recovery_runbook()\n-        ))\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn require_present(&self) -> Result<()> {\n         if self.backend.is_present() {\n             Ok(())\n         } else {\n             Err(Self::missing_tpm_error())\n         }\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::lockout_error",
      "return_type": "-> ButterflyBotError",
      "span": {
        "end": {
          "column": 6,
          "line": 344
        },
        "start": {
          "column": 5,
          "line": 339
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:340:9: replace TpmRuntime<'a, B, K>::lockout_error -> ButterflyBotError with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 11,
        "line": 343
      },
      "start": {
        "column": 9,
        "line": 340
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::require_present -> Result<()> with Ok(())\n@@ -339,21 +339,17 @@\n     fn lockout_error() -> ButterflyBotError {\n         ButterflyBotError::SecurityPolicy(format!(\n             \"TPM lockout/auth failure detected. Recovery runbook: {}\",\n             recovery_runbook()\n         ))\n     }\n \n     fn require_present(&self) -> Result<()> {\n-        if self.backend.is_present() {\n-            Ok(())\n-        } else {\n-            Err(Self::missing_tpm_error())\n-        }\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn verify_policy_fingerprint(&self, expected: &str) -> Result<()> {\n         let current = self.backend.fingerprint()?;\n         if current == expected {\n             Ok(())\n         } else {\n             Err(Self::policy_mismatch_error())\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::require_present",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 352
        },
        "start": {
          "column": 5,
          "line": 346
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:347:9: replace TpmRuntime<'a, B, K>::require_present -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 10,
        "line": 351
      },
      "start": {
        "column": 9,
        "line": 347
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::verify_policy_fingerprint -> Result<()> with Ok(())\n@@ -347,22 +347,17 @@\n         if self.backend.is_present() {\n             Ok(())\n         } else {\n             Err(Self::missing_tpm_error())\n         }\n     }\n \n     fn verify_policy_fingerprint(&self, expected: &str) -> Result<()> {\n-        let current = self.backend.fingerprint()?;\n-        if current == expected {\n-            Ok(())\n-        } else {\n-            Err(Self::policy_mismatch_error())\n-        }\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn load_unsealed_dek(&self, kek: &str) -> Result<String> {\n         let wrapped = self.wrapped_dek_path();\n         let decoded = cocoon_store::load_secret(&wrapped, kek)\n             .map_err(|_| Self::reset_error(\"wrapped DEK decryption failed\"))?;\n         decoded.ok_or_else(|| Self::reset_error(\"wrapped DEK missing\"))\n     }\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::verify_policy_fingerprint",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 361
        },
        "start": {
          "column": 5,
          "line": 354
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:355:9: replace TpmRuntime<'a, B, K>::verify_policy_fingerprint -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 10,
        "line": 360
      },
      "start": {
        "column": 9,
        "line": 355
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace == with != in TpmRuntime<'a, B, K>::verify_policy_fingerprint\n@@ -348,17 +348,17 @@\n             Ok(())\n         } else {\n             Err(Self::missing_tpm_error())\n         }\n     }\n \n     fn verify_policy_fingerprint(&self, expected: &str) -> Result<()> {\n         let current = self.backend.fingerprint()?;\n-        if current == expected {\n+        if current != /* ~ changed by cargo-mutants ~ */ expected {\n             Ok(())\n         } else {\n             Err(Self::policy_mismatch_error())\n         }\n     }\n \n     fn load_unsealed_dek(&self, kek: &str) -> Result<String> {\n         let wrapped = self.wrapped_dek_path();\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::verify_policy_fingerprint",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 361
        },
        "start": {
          "column": 5,
          "line": 354
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/tpm_provider.rs:356:20: replace == with != in TpmRuntime<'a, B, K>::verify_policy_fingerprint",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 22,
        "line": 356
      },
      "start": {
        "column": 20,
        "line": 356
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::load_unsealed_dek -> Result<String> with Ok(String::new())\n@@ -356,20 +356,17 @@\n         if current == expected {\n             Ok(())\n         } else {\n             Err(Self::policy_mismatch_error())\n         }\n     }\n \n     fn load_unsealed_dek(&self, kek: &str) -> Result<String> {\n-        let wrapped = self.wrapped_dek_path();\n-        let decoded = cocoon_store::load_secret(&wrapped, kek)\n-            .map_err(|_| Self::reset_error(\"wrapped DEK decryption failed\"))?;\n-        decoded.ok_or_else(|| Self::reset_error(\"wrapped DEK missing\"))\n+        Ok(String::new()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn persist_wrapped_dek(&self, kek: &str, dek: &str) -> Result<()> {\n         self.ensure_root()?;\n         cocoon_store::persist_secret(&self.wrapped_dek_path(), kek, dek)\n     }\n \n     fn provision(&self) -> Result<()> {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::load_unsealed_dek",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 368
        },
        "start": {
          "column": 5,
          "line": 363
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:364:9: replace TpmRuntime<'a, B, K>::load_unsealed_dek -> Result<String> with Ok(String::new())",
    "package": "butterfly-bot",
    "replacement": "Ok(String::new())",
    "span": {
      "end": {
        "column": 72,
        "line": 367
      },
      "start": {
        "column": 9,
        "line": 364
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::load_unsealed_dek -> Result<String> with Ok(\"xyzzy\".into())\n@@ -356,20 +356,17 @@\n         if current == expected {\n             Ok(())\n         } else {\n             Err(Self::policy_mismatch_error())\n         }\n     }\n \n     fn load_unsealed_dek(&self, kek: &str) -> Result<String> {\n-        let wrapped = self.wrapped_dek_path();\n-        let decoded = cocoon_store::load_secret(&wrapped, kek)\n-            .map_err(|_| Self::reset_error(\"wrapped DEK decryption failed\"))?;\n-        decoded.ok_or_else(|| Self::reset_error(\"wrapped DEK missing\"))\n+        Ok(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn persist_wrapped_dek(&self, kek: &str, dek: &str) -> Result<()> {\n         self.ensure_root()?;\n         cocoon_store::persist_secret(&self.wrapped_dek_path(), kek, dek)\n     }\n \n     fn provision(&self) -> Result<()> {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::load_unsealed_dek",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 368
        },
        "start": {
          "column": 5,
          "line": 363
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:364:9: replace TpmRuntime<'a, B, K>::load_unsealed_dek -> Result<String> with Ok(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Ok(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 72,
        "line": 367
      },
      "start": {
        "column": 9,
        "line": 364
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::persist_wrapped_dek -> Result<()> with Ok(())\n@@ -363,18 +363,17 @@\n     fn load_unsealed_dek(&self, kek: &str) -> Result<String> {\n         let wrapped = self.wrapped_dek_path();\n         let decoded = cocoon_store::load_secret(&wrapped, kek)\n             .map_err(|_| Self::reset_error(\"wrapped DEK decryption failed\"))?;\n         decoded.ok_or_else(|| Self::reset_error(\"wrapped DEK missing\"))\n     }\n \n     fn persist_wrapped_dek(&self, kek: &str, dek: &str) -> Result<()> {\n-        self.ensure_root()?;\n-        cocoon_store::persist_secret(&self.wrapped_dek_path(), kek, dek)\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn provision(&self) -> Result<()> {\n         self.require_present()?;\n         let fingerprint = self.backend.fingerprint()?;\n         let state = self.load_policy_state()?;\n \n         if let Some(state) = state {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::persist_wrapped_dek",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 373
        },
        "start": {
          "column": 5,
          "line": 370
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:371:9: replace TpmRuntime<'a, B, K>::persist_wrapped_dek -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 73,
        "line": 372
      },
      "start": {
        "column": 9,
        "line": 371
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::provision -> Result<()> with Ok(())\n@@ -368,50 +368,17 @@\n     }\n \n     fn persist_wrapped_dek(&self, kek: &str, dek: &str) -> Result<()> {\n         self.ensure_root()?;\n         cocoon_store::persist_secret(&self.wrapped_dek_path(), kek, dek)\n     }\n \n     fn provision(&self) -> Result<()> {\n-        self.require_present()?;\n-        let fingerprint = self.backend.fingerprint()?;\n-        let state = self.load_policy_state()?;\n-\n-        if let Some(state) = state {\n-            self.verify_policy_fingerprint(&state.fingerprint)?;\n-            let kek = self.kek_store.get_kek().map_err(|e| {\n-                if Self::lockout_like(&e) {\n-                    Self::lockout_error()\n-                } else {\n-                    e\n-                }\n-            })?;\n-            let kek = kek.ok_or_else(|| Self::reset_error(\"KEK missing from TPM key store\"))?;\n-            let _ = self.load_unsealed_dek(&kek)?;\n-            return Ok(());\n-        }\n-\n-        let kek = Self::random_secret()?;\n-        self.kek_store.set_kek(&kek).map_err(|e| {\n-            if Self::lockout_like(&e) {\n-                Self::lockout_error()\n-            } else {\n-                e\n-            }\n-        })?;\n-        let dek = Self::random_secret()?;\n-        self.persist_wrapped_dek(&kek, &dek)?;\n-        self.save_policy_state(TpmPolicyState {\n-            version: POLICY_VERSION,\n-            fingerprint,\n-            lifecycle_state: KeyLifecycleState::Seal,\n-        })?;\n-        Ok(())\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn unseal_dek(&self) -> Result<String> {\n         self.require_present()?;\n         self.provision()?;\n \n         let state = self\n             .load_policy_state()?\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::provision",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 410
        },
        "start": {
          "column": 5,
          "line": 375
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:376:9: replace TpmRuntime<'a, B, K>::provision -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 15,
        "line": 409
      },
      "start": {
        "column": 9,
        "line": 376
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::unseal_dek -> Result<String> with Ok(String::new())\n@@ -405,41 +405,17 @@\n             version: POLICY_VERSION,\n             fingerprint,\n             lifecycle_state: KeyLifecycleState::Seal,\n         })?;\n         Ok(())\n     }\n \n     fn unseal_dek(&self) -> Result<String> {\n-        self.require_present()?;\n-        self.provision()?;\n-\n-        let state = self\n-            .load_policy_state()?\n-            .ok_or_else(|| Self::reset_error(\"TPM policy state missing\"))?;\n-        self.verify_policy_fingerprint(&state.fingerprint)?;\n-\n-        let kek = self.kek_store.get_kek().map_err(|e| {\n-            if Self::lockout_like(&e) {\n-                Self::lockout_error()\n-            } else {\n-                e\n-            }\n-        })?;\n-        let kek = kek.ok_or_else(|| Self::reset_error(\"KEK missing from TPM key store\"))?;\n-        let dek = self.load_unsealed_dek(&kek)?;\n-\n-        self.save_policy_state(TpmPolicyState {\n-            version: POLICY_VERSION,\n-            fingerprint: state.fingerprint,\n-            lifecycle_state: KeyLifecycleState::Use,\n-        })?;\n-\n-        Ok(dek)\n+        Ok(String::new()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn rotate_dek(&self) -> Result<()> {\n         self.require_present()?;\n         let state = self\n             .load_policy_state()?\n             .ok_or_else(|| Self::reset_error(\"TPM policy state missing\"))?;\n         self.verify_policy_fingerprint(&state.fingerprint)?;\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::unseal_dek",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 438
        },
        "start": {
          "column": 5,
          "line": 412
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:413:9: replace TpmRuntime<'a, B, K>::unseal_dek -> Result<String> with Ok(String::new())",
    "package": "butterfly-bot",
    "replacement": "Ok(String::new())",
    "span": {
      "end": {
        "column": 16,
        "line": 437
      },
      "start": {
        "column": 9,
        "line": 413
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::unseal_dek -> Result<String> with Ok(\"xyzzy\".into())\n@@ -405,41 +405,17 @@\n             version: POLICY_VERSION,\n             fingerprint,\n             lifecycle_state: KeyLifecycleState::Seal,\n         })?;\n         Ok(())\n     }\n \n     fn unseal_dek(&self) -> Result<String> {\n-        self.require_present()?;\n-        self.provision()?;\n-\n-        let state = self\n-            .load_policy_state()?\n-            .ok_or_else(|| Self::reset_error(\"TPM policy state missing\"))?;\n-        self.verify_policy_fingerprint(&state.fingerprint)?;\n-\n-        let kek = self.kek_store.get_kek().map_err(|e| {\n-            if Self::lockout_like(&e) {\n-                Self::lockout_error()\n-            } else {\n-                e\n-            }\n-        })?;\n-        let kek = kek.ok_or_else(|| Self::reset_error(\"KEK missing from TPM key store\"))?;\n-        let dek = self.load_unsealed_dek(&kek)?;\n-\n-        self.save_policy_state(TpmPolicyState {\n-            version: POLICY_VERSION,\n-            fingerprint: state.fingerprint,\n-            lifecycle_state: KeyLifecycleState::Use,\n-        })?;\n-\n-        Ok(dek)\n+        Ok(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn rotate_dek(&self) -> Result<()> {\n         self.require_present()?;\n         let state = self\n             .load_policy_state()?\n             .ok_or_else(|| Self::reset_error(\"TPM policy state missing\"))?;\n         self.verify_policy_fingerprint(&state.fingerprint)?;\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::unseal_dek",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 6,
          "line": 438
        },
        "start": {
          "column": 5,
          "line": 412
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:413:9: replace TpmRuntime<'a, B, K>::unseal_dek -> Result<String> with Ok(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Ok(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 16,
        "line": 437
      },
      "start": {
        "column": 9,
        "line": 413
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::rotate_dek -> Result<()> with Ok(())\n@@ -433,32 +433,17 @@\n             fingerprint: state.fingerprint,\n             lifecycle_state: KeyLifecycleState::Use,\n         })?;\n \n         Ok(dek)\n     }\n \n     fn rotate_dek(&self) -> Result<()> {\n-        self.require_present()?;\n-        let state = self\n-            .load_policy_state()?\n-            .ok_or_else(|| Self::reset_error(\"TPM policy state missing\"))?;\n-        self.verify_policy_fingerprint(&state.fingerprint)?;\n-        let kek = self\n-            .kek_store\n-            .get_kek()?\n-            .ok_or_else(|| Self::reset_error(\"KEK missing from TPM key store\"))?;\n-        let new_dek = Self::random_secret()?;\n-        self.persist_wrapped_dek(&kek, &new_dek)?;\n-        self.save_policy_state(TpmPolicyState {\n-            version: POLICY_VERSION,\n-            fingerprint: state.fingerprint,\n-            lifecycle_state: KeyLifecycleState::Rotate,\n-        })\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn revoke(&self) -> Result<()> {\n         let _ = std::fs::remove_file(self.wrapped_dek_path());\n         let _ = std::fs::remove_file(self.policy_state_path());\n         self.kek_store.clear_kek()?;\n         Ok(())\n     }\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::rotate_dek",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 457
        },
        "start": {
          "column": 5,
          "line": 440
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:441:9: replace TpmRuntime<'a, B, K>::rotate_dek -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 456
      },
      "start": {
        "column": 9,
        "line": 441
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace TpmRuntime<'a, B, K>::revoke -> Result<()> with Ok(())\n@@ -452,20 +452,17 @@\n         self.save_policy_state(TpmPolicyState {\n             version: POLICY_VERSION,\n             fingerprint: state.fingerprint,\n             lifecycle_state: KeyLifecycleState::Rotate,\n         })\n     }\n \n     fn revoke(&self) -> Result<()> {\n-        let _ = std::fs::remove_file(self.wrapped_dek_path());\n-        let _ = std::fs::remove_file(self.policy_state_path());\n-        self.kek_store.clear_kek()?;\n-        Ok(())\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n fn runtime_root() -> PathBuf {\n     crate::runtime_paths::app_root().join(\"security\")\n }\n \n fn production_runtime() -> TpmRuntime<'static, DeviceTpmBackend, KeyringKekStore> {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "TpmRuntime<'a, B, K>::revoke",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 464
        },
        "start": {
          "column": 5,
          "line": 459
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:460:9: replace TpmRuntime<'a, B, K>::revoke -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 15,
        "line": 463
      },
      "start": {
        "column": 9,
        "line": 460
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace runtime_root -> PathBuf with Default::default()\n@@ -460,17 +460,17 @@\n         let _ = std::fs::remove_file(self.wrapped_dek_path());\n         let _ = std::fs::remove_file(self.policy_state_path());\n         self.kek_store.clear_kek()?;\n         Ok(())\n     }\n }\n \n fn runtime_root() -> PathBuf {\n-    crate::runtime_paths::app_root().join(\"security\")\n+    Default::default() /* ~ changed by cargo-mutants ~ */\n }\n \n fn production_runtime() -> TpmRuntime<'static, DeviceTpmBackend, KeyringKekStore> {\n     static BACKEND: DeviceTpmBackend = DeviceTpmBackend;\n     static STORE: KeyringKekStore = KeyringKekStore;\n     TpmRuntime {\n         backend: &BACKEND,\n         kek_store: &STORE,\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "runtime_root",
      "return_type": "-> PathBuf",
      "span": {
        "end": {
          "column": 2,
          "line": 469
        },
        "start": {
          "column": 1,
          "line": 467
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:468:5: replace runtime_root -> PathBuf with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 54,
        "line": 468
      },
      "start": {
        "column": 5,
        "line": 468
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace production_runtime -> TpmRuntime<'static, DeviceTpmBackend, KeyringKekStore> with Default::default()\n@@ -464,23 +464,17 @@\n     }\n }\n \n fn runtime_root() -> PathBuf {\n     crate::runtime_paths::app_root().join(\"security\")\n }\n \n fn production_runtime() -> TpmRuntime<'static, DeviceTpmBackend, KeyringKekStore> {\n-    static BACKEND: DeviceTpmBackend = DeviceTpmBackend;\n-    static STORE: KeyringKekStore = KeyringKekStore;\n-    TpmRuntime {\n-        backend: &BACKEND,\n-        kek_store: &STORE,\n-        security_root: runtime_root(),\n-    }\n+    Default::default() /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn require_tpm() -> Result<()> {\n     #[cfg(all(debug_assertions, not(test)))]\n     {\n         if let Some(value) = debug_tpm_available_override() {\n             return if value {\n                 Ok(())\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "production_runtime",
      "return_type": "-> TpmRuntime<'static, DeviceTpmBackend, KeyringKekStore>",
      "span": {
        "end": {
          "column": 2,
          "line": 479
        },
        "start": {
          "column": 1,
          "line": 471
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:472:5: replace production_runtime -> TpmRuntime<'static, DeviceTpmBackend, KeyringKekStore> with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 6,
        "line": 478
      },
      "start": {
        "column": 5,
        "line": 472
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace require_tpm -> Result<()> with Ok(())\n@@ -474,43 +474,17 @@\n     TpmRuntime {\n         backend: &BACKEND,\n         kek_store: &STORE,\n         security_root: runtime_root(),\n     }\n }\n \n pub fn require_tpm() -> Result<()> {\n-    #[cfg(all(debug_assertions, not(test)))]\n-    {\n-        if let Some(value) = debug_tpm_available_override() {\n-            return if value {\n-                Ok(())\n-            } else {\n-                Err(ButterflyBotError::SecurityPolicy(\n-                    \"TPM is required in strict mode; no TPM device found\".to_string(),\n-                ))\n-            };\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    {\n-        if let Some(value) = tpm_available_override() {\n-            return if value {\n-                Ok(())\n-            } else {\n-                Err(ButterflyBotError::SecurityPolicy(\n-                    \"TPM is required in strict mode; no TPM device found\".to_string(),\n-                ))\n-            };\n-        }\n-    }\n-\n-    production_runtime().require_present()\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn resolve_dek_passphrase() -> Result<String> {\n     #[cfg(all(debug_assertions, not(test)))]\n     {\n         if let Some(value) = debug_dek_override() {\n             return Ok(value);\n         }\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "require_tpm",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 509
        },
        "start": {
          "column": 1,
          "line": 481
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:482:5: replace require_tpm -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 43,
        "line": 508
      },
      "start": {
        "column": 5,
        "line": 482
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace resolve_dek_passphrase -> Result<String> with Ok(String::new())\n@@ -504,31 +504,17 @@\n             };\n         }\n     }\n \n     production_runtime().require_present()\n }\n \n pub fn resolve_dek_passphrase() -> Result<String> {\n-    #[cfg(all(debug_assertions, not(test)))]\n-    {\n-        if let Some(value) = debug_dek_override() {\n-            return Ok(value);\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    {\n-        if let Some(value) = dek_override() {\n-            return Ok(value);\n-        }\n-    }\n-\n-    production_runtime().unseal_dek()\n+    Ok(String::new()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn provision_kek_and_dek() -> Result<()> {\n     production_runtime().provision()\n }\n \n pub fn rotate_dek() -> Result<()> {\n     production_runtime().rotate_dek()\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "resolve_dek_passphrase",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 527
        },
        "start": {
          "column": 1,
          "line": 511
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:512:5: replace resolve_dek_passphrase -> Result<String> with Ok(String::new())",
    "package": "butterfly-bot",
    "replacement": "Ok(String::new())",
    "span": {
      "end": {
        "column": 38,
        "line": 526
      },
      "start": {
        "column": 5,
        "line": 512
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace resolve_dek_passphrase -> Result<String> with Ok(\"xyzzy\".into())\n@@ -504,31 +504,17 @@\n             };\n         }\n     }\n \n     production_runtime().require_present()\n }\n \n pub fn resolve_dek_passphrase() -> Result<String> {\n-    #[cfg(all(debug_assertions, not(test)))]\n-    {\n-        if let Some(value) = debug_dek_override() {\n-            return Ok(value);\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    {\n-        if let Some(value) = dek_override() {\n-            return Ok(value);\n-        }\n-    }\n-\n-    production_runtime().unseal_dek()\n+    Ok(\"xyzzy\".into()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn provision_kek_and_dek() -> Result<()> {\n     production_runtime().provision()\n }\n \n pub fn rotate_dek() -> Result<()> {\n     production_runtime().rotate_dek()\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "resolve_dek_passphrase",
      "return_type": "-> Result<String>",
      "span": {
        "end": {
          "column": 2,
          "line": 527
        },
        "start": {
          "column": 1,
          "line": 511
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:512:5: replace resolve_dek_passphrase -> Result<String> with Ok(\"xyzzy\".into())",
    "package": "butterfly-bot",
    "replacement": "Ok(\"xyzzy\".into())",
    "span": {
      "end": {
        "column": 38,
        "line": 526
      },
      "start": {
        "column": 5,
        "line": 512
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace provision_kek_and_dek -> Result<()> with Ok(())\n@@ -522,17 +522,17 @@\n             return Ok(value);\n         }\n     }\n \n     production_runtime().unseal_dek()\n }\n \n pub fn provision_kek_and_dek() -> Result<()> {\n-    production_runtime().provision()\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn rotate_dek() -> Result<()> {\n     production_runtime().rotate_dek()\n }\n \n pub fn revoke_keys() -> Result<()> {\n     production_runtime().revoke()\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "provision_kek_and_dek",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 531
        },
        "start": {
          "column": 1,
          "line": 529
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:530:5: replace provision_kek_and_dek -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 37,
        "line": 530
      },
      "start": {
        "column": 5,
        "line": 530
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace rotate_dek -> Result<()> with Ok(())\n@@ -526,17 +526,17 @@\n     production_runtime().unseal_dek()\n }\n \n pub fn provision_kek_and_dek() -> Result<()> {\n     production_runtime().provision()\n }\n \n pub fn rotate_dek() -> Result<()> {\n-    production_runtime().rotate_dek()\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn revoke_keys() -> Result<()> {\n     production_runtime().revoke()\n }\n \n pub fn recovery_runbook() -> &'static str {\n     \"1) stop the daemon and UI, 2) verify TPM device presence and ownership, 3) if TPM was reset/reprovisioned, run migration/recovery path and reprovision keys, 4) restore secrets from trusted backup, 5) restart in strict mode and verify checks\"\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "rotate_dek",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 535
        },
        "start": {
          "column": 1,
          "line": 533
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:534:5: replace rotate_dek -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 38,
        "line": 534
      },
      "start": {
        "column": 5,
        "line": 534
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace revoke_keys -> Result<()> with Ok(())\n@@ -530,17 +530,17 @@\n     production_runtime().provision()\n }\n \n pub fn rotate_dek() -> Result<()> {\n     production_runtime().rotate_dek()\n }\n \n pub fn revoke_keys() -> Result<()> {\n-    production_runtime().revoke()\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn recovery_runbook() -> &'static str {\n     \"1) stop the daemon and UI, 2) verify TPM device presence and ownership, 3) if TPM was reset/reprovisioned, run migration/recovery path and reprovision keys, 4) restore secrets from trusted backup, 5) restart in strict mode and verify checks\"\n }\n \n #[cfg(test)]\n mod tests {\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "revoke_keys",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 539
        },
        "start": {
          "column": 1,
          "line": 537
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:538:5: replace revoke_keys -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 34,
        "line": 538
      },
      "start": {
        "column": 5,
        "line": 538
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace recovery_runbook -> &'static str with \"\"\n@@ -534,17 +534,17 @@\n     production_runtime().rotate_dek()\n }\n \n pub fn revoke_keys() -> Result<()> {\n     production_runtime().revoke()\n }\n \n pub fn recovery_runbook() -> &'static str {\n-    \"1) stop the daemon and UI, 2) verify TPM device presence and ownership, 3) if TPM was reset/reprovisioned, run migration/recovery path and reprovision keys, 4) restore secrets from trusted backup, 5) restart in strict mode and verify checks\"\n+    \"\" /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     use std::sync::Mutex;\n \n     #[derive(Clone)]\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "recovery_runbook",
      "return_type": "-> &'static str",
      "span": {
        "end": {
          "column": 2,
          "line": 543
        },
        "start": {
          "column": 1,
          "line": 541
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:542:5: replace recovery_runbook -> &'static str with \"\"",
    "package": "butterfly-bot",
    "replacement": "\"\"",
    "span": {
      "end": {
        "column": 247,
        "line": 542
      },
      "start": {
        "column": 5,
        "line": 542
      }
    }
  },
  {
    "diff": "--- src/security/tpm_provider.rs\n+++ replace recovery_runbook -> &'static str with \"xyzzy\"\n@@ -534,17 +534,17 @@\n     production_runtime().rotate_dek()\n }\n \n pub fn revoke_keys() -> Result<()> {\n     production_runtime().revoke()\n }\n \n pub fn recovery_runbook() -> &'static str {\n-    \"1) stop the daemon and UI, 2) verify TPM device presence and ownership, 3) if TPM was reset/reprovisioned, run migration/recovery path and reprovision keys, 4) restore secrets from trusted backup, 5) restart in strict mode and verify checks\"\n+    \"xyzzy\" /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     use std::sync::Mutex;\n \n     #[derive(Clone)]\n",
    "file": "src/security/tpm_provider.rs",
    "function": {
      "function_name": "recovery_runbook",
      "return_type": "-> &'static str",
      "span": {
        "end": {
          "column": 2,
          "line": 543
        },
        "start": {
          "column": 1,
          "line": 541
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/tpm_provider.rs:542:5: replace recovery_runbook -> &'static str with \"xyzzy\"",
    "package": "butterfly-bot",
    "replacement": "\"xyzzy\"",
    "span": {
      "end": {
        "column": 247,
        "line": 542
      },
      "start": {
        "column": 5,
        "line": 542
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace <impl LegacySecretStore for KeyringLegacySecretStore>::get_secret -> Result<Option<String>> with Ok(None)\n@@ -46,30 +46,17 @@\n     fn get_secret(&self, name: &str) -> Result<Option<String>>;\n     fn set_secret_required(&self, name: &str, value: &str) -> Result<()>;\n }\n \n struct KeyringLegacySecretStore;\n \n impl LegacySecretStore for KeyringLegacySecretStore {\n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n-        let entry = keyring::Entry::new(SERVICE, name)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        match entry.get_password() {\n-            Ok(value) => {\n-                let trimmed = value.trim().to_string();\n-                if trimmed.is_empty() {\n-                    Ok(None)\n-                } else {\n-                    Ok(Some(trimmed))\n-                }\n-            }\n-            Err(keyring::Error::NoEntry) => Ok(None),\n-            Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n-        }\n+        Ok(None) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn delete_secret(&self, name: &str) -> Result<()> {\n         let entry = keyring::Entry::new(SERVICE, name)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         match entry.delete_credential() {\n             Ok(()) | Err(keyring::Error::NoEntry) => Ok(()),\n             Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "<impl LegacySecretStore for KeyringLegacySecretStore>::get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 68
        },
        "start": {
          "column": 5,
          "line": 53
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:54:9: replace <impl LegacySecretStore for KeyringLegacySecretStore>::get_secret -> Result<Option<String>> with Ok(None)",
    "package": "butterfly-bot",
    "replacement": "Ok(None)",
    "span": {
      "end": {
        "column": 10,
        "line": 67
      },
      "start": {
        "column": 9,
        "line": 54
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace <impl LegacySecretStore for KeyringLegacySecretStore>::get_secret -> Result<Option<String>> with Ok(Some(String::new()))\n@@ -46,30 +46,17 @@\n     fn get_secret(&self, name: &str) -> Result<Option<String>>;\n     fn set_secret_required(&self, name: &str, value: &str) -> Result<()>;\n }\n \n struct KeyringLegacySecretStore;\n \n impl LegacySecretStore for KeyringLegacySecretStore {\n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n-        let entry = keyring::Entry::new(SERVICE, name)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        match entry.get_password() {\n-            Ok(value) => {\n-                let trimmed = value.trim().to_string();\n-                if trimmed.is_empty() {\n-                    Ok(None)\n-                } else {\n-                    Ok(Some(trimmed))\n-                }\n-            }\n-            Err(keyring::Error::NoEntry) => Ok(None),\n-            Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n-        }\n+        Ok(Some(String::new())) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn delete_secret(&self, name: &str) -> Result<()> {\n         let entry = keyring::Entry::new(SERVICE, name)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         match entry.delete_credential() {\n             Ok(()) | Err(keyring::Error::NoEntry) => Ok(()),\n             Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "<impl LegacySecretStore for KeyringLegacySecretStore>::get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 68
        },
        "start": {
          "column": 5,
          "line": 53
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:54:9: replace <impl LegacySecretStore for KeyringLegacySecretStore>::get_secret -> Result<Option<String>> with Ok(Some(String::new()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(String::new()))",
    "span": {
      "end": {
        "column": 10,
        "line": 67
      },
      "start": {
        "column": 9,
        "line": 54
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace <impl LegacySecretStore for KeyringLegacySecretStore>::get_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))\n@@ -46,30 +46,17 @@\n     fn get_secret(&self, name: &str) -> Result<Option<String>>;\n     fn set_secret_required(&self, name: &str, value: &str) -> Result<()>;\n }\n \n struct KeyringLegacySecretStore;\n \n impl LegacySecretStore for KeyringLegacySecretStore {\n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n-        let entry = keyring::Entry::new(SERVICE, name)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        match entry.get_password() {\n-            Ok(value) => {\n-                let trimmed = value.trim().to_string();\n-                if trimmed.is_empty() {\n-                    Ok(None)\n-                } else {\n-                    Ok(Some(trimmed))\n-                }\n-            }\n-            Err(keyring::Error::NoEntry) => Ok(None),\n-            Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n-        }\n+        Ok(Some(\"xyzzy\".into())) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn delete_secret(&self, name: &str) -> Result<()> {\n         let entry = keyring::Entry::new(SERVICE, name)\n             .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n         match entry.delete_credential() {\n             Ok(()) | Err(keyring::Error::NoEntry) => Ok(()),\n             Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "<impl LegacySecretStore for KeyringLegacySecretStore>::get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 68
        },
        "start": {
          "column": 5,
          "line": 53
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:54:9: replace <impl LegacySecretStore for KeyringLegacySecretStore>::get_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(\"xyzzy\".into()))",
    "span": {
      "end": {
        "column": 10,
        "line": 67
      },
      "start": {
        "column": 9,
        "line": 54
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace <impl LegacySecretStore for KeyringLegacySecretStore>::delete_secret -> Result<()> with Ok(())\n@@ -63,22 +63,17 @@\n                 }\n             }\n             Err(keyring::Error::NoEntry) => Ok(None),\n             Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n         }\n     }\n \n     fn delete_secret(&self, name: &str) -> Result<()> {\n-        let entry = keyring::Entry::new(SERVICE, name)\n-            .map_err(|e| ButterflyBotError::SecurityStorage(e.to_string()))?;\n-        match entry.delete_credential() {\n-            Ok(()) | Err(keyring::Error::NoEntry) => Ok(()),\n-            Err(err) => Err(ButterflyBotError::SecurityStorage(err.to_string())),\n-        }\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n struct VaultTargetSecretStore;\n \n impl TargetSecretStore for VaultTargetSecretStore {\n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n         crate::vault::get_secret(name)\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "<impl LegacySecretStore for KeyringLegacySecretStore>::delete_secret",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 77
        },
        "start": {
          "column": 5,
          "line": 70
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:71:9: replace <impl LegacySecretStore for KeyringLegacySecretStore>::delete_secret -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 10,
        "line": 76
      },
      "start": {
        "column": 9,
        "line": 71
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace <impl TargetSecretStore for VaultTargetSecretStore>::get_secret -> Result<Option<String>> with Ok(None)\n@@ -76,17 +76,17 @@\n         }\n     }\n }\n \n struct VaultTargetSecretStore;\n \n impl TargetSecretStore for VaultTargetSecretStore {\n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n-        crate::vault::get_secret(name)\n+        Ok(None) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn set_secret_required(&self, name: &str, value: &str) -> Result<()> {\n         crate::vault::set_secret_required(name, value)\n     }\n }\n \n fn migrate_with_stores(\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "<impl TargetSecretStore for VaultTargetSecretStore>::get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 85
        },
        "start": {
          "column": 5,
          "line": 83
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:84:9: replace <impl TargetSecretStore for VaultTargetSecretStore>::get_secret -> Result<Option<String>> with Ok(None)",
    "package": "butterfly-bot",
    "replacement": "Ok(None)",
    "span": {
      "end": {
        "column": 39,
        "line": 84
      },
      "start": {
        "column": 9,
        "line": 84
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace <impl TargetSecretStore for VaultTargetSecretStore>::get_secret -> Result<Option<String>> with Ok(Some(String::new()))\n@@ -76,17 +76,17 @@\n         }\n     }\n }\n \n struct VaultTargetSecretStore;\n \n impl TargetSecretStore for VaultTargetSecretStore {\n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n-        crate::vault::get_secret(name)\n+        Ok(Some(String::new())) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn set_secret_required(&self, name: &str, value: &str) -> Result<()> {\n         crate::vault::set_secret_required(name, value)\n     }\n }\n \n fn migrate_with_stores(\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "<impl TargetSecretStore for VaultTargetSecretStore>::get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 85
        },
        "start": {
          "column": 5,
          "line": 83
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:84:9: replace <impl TargetSecretStore for VaultTargetSecretStore>::get_secret -> Result<Option<String>> with Ok(Some(String::new()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(String::new()))",
    "span": {
      "end": {
        "column": 39,
        "line": 84
      },
      "start": {
        "column": 9,
        "line": 84
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace <impl TargetSecretStore for VaultTargetSecretStore>::get_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))\n@@ -76,17 +76,17 @@\n         }\n     }\n }\n \n struct VaultTargetSecretStore;\n \n impl TargetSecretStore for VaultTargetSecretStore {\n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n-        crate::vault::get_secret(name)\n+        Ok(Some(\"xyzzy\".into())) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn set_secret_required(&self, name: &str, value: &str) -> Result<()> {\n         crate::vault::set_secret_required(name, value)\n     }\n }\n \n fn migrate_with_stores(\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "<impl TargetSecretStore for VaultTargetSecretStore>::get_secret",
      "return_type": "-> Result<Option<String>>",
      "span": {
        "end": {
          "column": 6,
          "line": 85
        },
        "start": {
          "column": 5,
          "line": 83
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:84:9: replace <impl TargetSecretStore for VaultTargetSecretStore>::get_secret -> Result<Option<String>> with Ok(Some(\"xyzzy\".into()))",
    "package": "butterfly-bot",
    "replacement": "Ok(Some(\"xyzzy\".into()))",
    "span": {
      "end": {
        "column": 39,
        "line": 84
      },
      "start": {
        "column": 9,
        "line": 84
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace <impl TargetSecretStore for VaultTargetSecretStore>::set_secret_required -> Result<()> with Ok(())\n@@ -80,17 +80,17 @@\n struct VaultTargetSecretStore;\n \n impl TargetSecretStore for VaultTargetSecretStore {\n     fn get_secret(&self, name: &str) -> Result<Option<String>> {\n         crate::vault::get_secret(name)\n     }\n \n     fn set_secret_required(&self, name: &str, value: &str) -> Result<()> {\n-        crate::vault::set_secret_required(name, value)\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n fn migrate_with_stores(\n     mode: MigrationMode,\n     names: &[&str],\n     legacy: &dyn LegacySecretStore,\n     target: &dyn TargetSecretStore,\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "<impl TargetSecretStore for VaultTargetSecretStore>::set_secret_required",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 89
        },
        "start": {
          "column": 5,
          "line": 87
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:88:9: replace <impl TargetSecretStore for VaultTargetSecretStore>::set_secret_required -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 55,
        "line": 88
      },
      "start": {
        "column": 9,
        "line": 88
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace migrate_with_stores -> MigrationReport with Default::default()\n@@ -90,121 +90,17 @@\n }\n \n fn migrate_with_stores(\n     mode: MigrationMode,\n     names: &[&str],\n     legacy: &dyn LegacySecretStore,\n     target: &dyn TargetSecretStore,\n ) -> MigrationReport {\n-    let mut report = MigrationReport {\n-        mode,\n-        checked: 0,\n-        migrated: 0,\n-        skipped: 0,\n-        errors: 0,\n-        items: Vec::new(),\n-    };\n-\n-    for name in names {\n-        report.checked += 1;\n-\n-        let target_value = match target.get_secret(name) {\n-            Ok(value) => value,\n-            Err(err) => {\n-                report.errors += 1;\n-                report.items.push(MigrationItem {\n-                    name: (*name).to_string(),\n-                    status: \"error\".to_string(),\n-                    detail: format!(\"target_read_failed: {err}\"),\n-                });\n-                continue;\n-            }\n-        };\n-\n-        if target_value\n-            .as_ref()\n-            .is_some_and(|value| !value.trim().is_empty())\n-        {\n-            report.skipped += 1;\n-            report.items.push(MigrationItem {\n-                name: (*name).to_string(),\n-                status: \"skipped\".to_string(),\n-                detail: \"already_migrated\".to_string(),\n-            });\n-            continue;\n-        }\n-\n-        let legacy_value = match legacy.get_secret(name) {\n-            Ok(value) => value,\n-            Err(err) => {\n-                report.errors += 1;\n-                report.items.push(MigrationItem {\n-                    name: (*name).to_string(),\n-                    status: \"error\".to_string(),\n-                    detail: format!(\"legacy_read_failed: {err}\"),\n-                });\n-                continue;\n-            }\n-        };\n-\n-        let Some(legacy_value) = legacy_value else {\n-            report.skipped += 1;\n-            report.items.push(MigrationItem {\n-                name: (*name).to_string(),\n-                status: \"skipped\".to_string(),\n-                detail: \"legacy_missing\".to_string(),\n-            });\n-            continue;\n-        };\n-\n-        if legacy_value.trim().is_empty() {\n-            report.errors += 1;\n-            report.items.push(MigrationItem {\n-                name: (*name).to_string(),\n-                status: \"error\".to_string(),\n-                detail: \"legacy_empty_value\".to_string(),\n-            });\n-            continue;\n-        }\n-\n-        if mode == MigrationMode::DryRun {\n-            report.migrated += 1;\n-            report.items.push(MigrationItem {\n-                name: (*name).to_string(),\n-                status: \"planned\".to_string(),\n-                detail: \"ready_to_migrate\".to_string(),\n-            });\n-            continue;\n-        }\n-\n-        if let Err(err) = target.set_secret_required(name, &legacy_value) {\n-            report.errors += 1;\n-            report.items.push(MigrationItem {\n-                name: (*name).to_string(),\n-                status: \"error\".to_string(),\n-                detail: format!(\"target_write_failed: {err}\"),\n-            });\n-            continue;\n-        }\n-\n-        let detail = match legacy.delete_secret(name) {\n-            Ok(()) => \"migrated_and_legacy_deleted\".to_string(),\n-            Err(err) => format!(\"migrated_legacy_delete_failed: {err}\"),\n-        };\n-\n-        report.migrated += 1;\n-        report.items.push(MigrationItem {\n-            name: (*name).to_string(),\n-            status: \"migrated\".to_string(),\n-            detail,\n-        });\n-    }\n-\n-    report\n+    Default::default() /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn run_legacy_secret_migration(mode: MigrationMode) -> Result<MigrationReport> {\n     crate::security::tpm_provider::require_tpm()?;\n \n     let legacy = KeyringLegacySecretStore;\n     let target = VaultTargetSecretStore;\n     Ok(migrate_with_stores(mode, LEGACY_SECRET_NAMES, &legacy, &target))\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:98:5: replace migrate_with_stores -> MigrationReport with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 11,
        "line": 202
      },
      "start": {
        "column": 5,
        "line": 98
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with -= in migrate_with_stores\n@@ -100,17 +100,17 @@\n         checked: 0,\n         migrated: 0,\n         skipped: 0,\n         errors: 0,\n         items: Vec::new(),\n     };\n \n     for name in names {\n-        report.checked += 1;\n+        report.checked -= /* ~ changed by cargo-mutants ~ */ 1;\n \n         let target_value = match target.get_secret(name) {\n             Ok(value) => value,\n             Err(err) => {\n                 report.errors += 1;\n                 report.items.push(MigrationItem {\n                     name: (*name).to_string(),\n                     status: \"error\".to_string(),\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:108:24: replace += with -= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "-=",
    "span": {
      "end": {
        "column": 26,
        "line": 108
      },
      "start": {
        "column": 24,
        "line": 108
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with *= in migrate_with_stores\n@@ -100,17 +100,17 @@\n         checked: 0,\n         migrated: 0,\n         skipped: 0,\n         errors: 0,\n         items: Vec::new(),\n     };\n \n     for name in names {\n-        report.checked += 1;\n+        report.checked *= /* ~ changed by cargo-mutants ~ */ 1;\n \n         let target_value = match target.get_secret(name) {\n             Ok(value) => value,\n             Err(err) => {\n                 report.errors += 1;\n                 report.items.push(MigrationItem {\n                     name: (*name).to_string(),\n                     status: \"error\".to_string(),\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:108:24: replace += with *= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "*=",
    "span": {
      "end": {
        "column": 26,
        "line": 108
      },
      "start": {
        "column": 24,
        "line": 108
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with -= in migrate_with_stores\n@@ -105,17 +105,17 @@\n     };\n \n     for name in names {\n         report.checked += 1;\n \n         let target_value = match target.get_secret(name) {\n             Ok(value) => value,\n             Err(err) => {\n-                report.errors += 1;\n+                report.errors -= /* ~ changed by cargo-mutants ~ */ 1;\n                 report.items.push(MigrationItem {\n                     name: (*name).to_string(),\n                     status: \"error\".to_string(),\n                     detail: format!(\"target_read_failed: {err}\"),\n                 });\n                 continue;\n             }\n         };\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:113:31: replace += with -= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "-=",
    "span": {
      "end": {
        "column": 33,
        "line": 113
      },
      "start": {
        "column": 31,
        "line": 113
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with *= in migrate_with_stores\n@@ -105,17 +105,17 @@\n     };\n \n     for name in names {\n         report.checked += 1;\n \n         let target_value = match target.get_secret(name) {\n             Ok(value) => value,\n             Err(err) => {\n-                report.errors += 1;\n+                report.errors *= /* ~ changed by cargo-mutants ~ */ 1;\n                 report.items.push(MigrationItem {\n                     name: (*name).to_string(),\n                     status: \"error\".to_string(),\n                     detail: format!(\"target_read_failed: {err}\"),\n                 });\n                 continue;\n             }\n         };\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:113:31: replace += with *= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "*=",
    "span": {
      "end": {
        "column": 33,
        "line": 113
      },
      "start": {
        "column": 31,
        "line": 113
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ delete ! in migrate_with_stores\n@@ -117,17 +117,17 @@\n                     detail: format!(\"target_read_failed: {err}\"),\n                 });\n                 continue;\n             }\n         };\n \n         if target_value\n             .as_ref()\n-            .is_some_and(|value| !value.trim().is_empty())\n+            .is_some_and(|value|  /* ~ changed by cargo-mutants ~ */value.trim().is_empty())\n         {\n             report.skipped += 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"skipped\".to_string(),\n                 detail: \"already_migrated\".to_string(),\n             });\n             continue;\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/security/migration.rs:125:34: delete ! in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 35,
        "line": 125
      },
      "start": {
        "column": 34,
        "line": 125
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with -= in migrate_with_stores\n@@ -119,17 +119,17 @@\n                 continue;\n             }\n         };\n \n         if target_value\n             .as_ref()\n             .is_some_and(|value| !value.trim().is_empty())\n         {\n-            report.skipped += 1;\n+            report.skipped -= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"skipped\".to_string(),\n                 detail: \"already_migrated\".to_string(),\n             });\n             continue;\n         }\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:127:28: replace += with -= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "-=",
    "span": {
      "end": {
        "column": 30,
        "line": 127
      },
      "start": {
        "column": 28,
        "line": 127
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with *= in migrate_with_stores\n@@ -119,17 +119,17 @@\n                 continue;\n             }\n         };\n \n         if target_value\n             .as_ref()\n             .is_some_and(|value| !value.trim().is_empty())\n         {\n-            report.skipped += 1;\n+            report.skipped *= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"skipped\".to_string(),\n                 detail: \"already_migrated\".to_string(),\n             });\n             continue;\n         }\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:127:28: replace += with *= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "*=",
    "span": {
      "end": {
        "column": 30,
        "line": 127
      },
      "start": {
        "column": 28,
        "line": 127
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with -= in migrate_with_stores\n@@ -131,17 +131,17 @@\n                 detail: \"already_migrated\".to_string(),\n             });\n             continue;\n         }\n \n         let legacy_value = match legacy.get_secret(name) {\n             Ok(value) => value,\n             Err(err) => {\n-                report.errors += 1;\n+                report.errors -= /* ~ changed by cargo-mutants ~ */ 1;\n                 report.items.push(MigrationItem {\n                     name: (*name).to_string(),\n                     status: \"error\".to_string(),\n                     detail: format!(\"legacy_read_failed: {err}\"),\n                 });\n                 continue;\n             }\n         };\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:139:31: replace += with -= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "-=",
    "span": {
      "end": {
        "column": 33,
        "line": 139
      },
      "start": {
        "column": 31,
        "line": 139
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with *= in migrate_with_stores\n@@ -131,17 +131,17 @@\n                 detail: \"already_migrated\".to_string(),\n             });\n             continue;\n         }\n \n         let legacy_value = match legacy.get_secret(name) {\n             Ok(value) => value,\n             Err(err) => {\n-                report.errors += 1;\n+                report.errors *= /* ~ changed by cargo-mutants ~ */ 1;\n                 report.items.push(MigrationItem {\n                     name: (*name).to_string(),\n                     status: \"error\".to_string(),\n                     detail: format!(\"legacy_read_failed: {err}\"),\n                 });\n                 continue;\n             }\n         };\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:139:31: replace += with *= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "*=",
    "span": {
      "end": {
        "column": 33,
        "line": 139
      },
      "start": {
        "column": 31,
        "line": 139
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with -= in migrate_with_stores\n@@ -142,17 +142,17 @@\n                     status: \"error\".to_string(),\n                     detail: format!(\"legacy_read_failed: {err}\"),\n                 });\n                 continue;\n             }\n         };\n \n         let Some(legacy_value) = legacy_value else {\n-            report.skipped += 1;\n+            report.skipped -= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"skipped\".to_string(),\n                 detail: \"legacy_missing\".to_string(),\n             });\n             continue;\n         };\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:150:28: replace += with -= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "-=",
    "span": {
      "end": {
        "column": 30,
        "line": 150
      },
      "start": {
        "column": 28,
        "line": 150
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with *= in migrate_with_stores\n@@ -142,17 +142,17 @@\n                     status: \"error\".to_string(),\n                     detail: format!(\"legacy_read_failed: {err}\"),\n                 });\n                 continue;\n             }\n         };\n \n         let Some(legacy_value) = legacy_value else {\n-            report.skipped += 1;\n+            report.skipped *= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"skipped\".to_string(),\n                 detail: \"legacy_missing\".to_string(),\n             });\n             continue;\n         };\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:150:28: replace += with *= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "*=",
    "span": {
      "end": {
        "column": 30,
        "line": 150
      },
      "start": {
        "column": 28,
        "line": 150
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with -= in migrate_with_stores\n@@ -152,17 +152,17 @@\n                 name: (*name).to_string(),\n                 status: \"skipped\".to_string(),\n                 detail: \"legacy_missing\".to_string(),\n             });\n             continue;\n         };\n \n         if legacy_value.trim().is_empty() {\n-            report.errors += 1;\n+            report.errors -= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"error\".to_string(),\n                 detail: \"legacy_empty_value\".to_string(),\n             });\n             continue;\n         }\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:160:27: replace += with -= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "-=",
    "span": {
      "end": {
        "column": 29,
        "line": 160
      },
      "start": {
        "column": 27,
        "line": 160
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with *= in migrate_with_stores\n@@ -152,17 +152,17 @@\n                 name: (*name).to_string(),\n                 status: \"skipped\".to_string(),\n                 detail: \"legacy_missing\".to_string(),\n             });\n             continue;\n         };\n \n         if legacy_value.trim().is_empty() {\n-            report.errors += 1;\n+            report.errors *= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"error\".to_string(),\n                 detail: \"legacy_empty_value\".to_string(),\n             });\n             continue;\n         }\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:160:27: replace += with *= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "*=",
    "span": {
      "end": {
        "column": 29,
        "line": 160
      },
      "start": {
        "column": 27,
        "line": 160
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace == with != in migrate_with_stores\n@@ -161,17 +161,17 @@\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"error\".to_string(),\n                 detail: \"legacy_empty_value\".to_string(),\n             });\n             continue;\n         }\n \n-        if mode == MigrationMode::DryRun {\n+        if mode != /* ~ changed by cargo-mutants ~ */ MigrationMode::DryRun {\n             report.migrated += 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"planned\".to_string(),\n                 detail: \"ready_to_migrate\".to_string(),\n             });\n             continue;\n         }\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:169:17: replace == with != in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 19,
        "line": 169
      },
      "start": {
        "column": 17,
        "line": 169
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with -= in migrate_with_stores\n@@ -162,17 +162,17 @@\n                 name: (*name).to_string(),\n                 status: \"error\".to_string(),\n                 detail: \"legacy_empty_value\".to_string(),\n             });\n             continue;\n         }\n \n         if mode == MigrationMode::DryRun {\n-            report.migrated += 1;\n+            report.migrated -= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"planned\".to_string(),\n                 detail: \"ready_to_migrate\".to_string(),\n             });\n             continue;\n         }\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:170:29: replace += with -= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "-=",
    "span": {
      "end": {
        "column": 31,
        "line": 170
      },
      "start": {
        "column": 29,
        "line": 170
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with *= in migrate_with_stores\n@@ -162,17 +162,17 @@\n                 name: (*name).to_string(),\n                 status: \"error\".to_string(),\n                 detail: \"legacy_empty_value\".to_string(),\n             });\n             continue;\n         }\n \n         if mode == MigrationMode::DryRun {\n-            report.migrated += 1;\n+            report.migrated *= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"planned\".to_string(),\n                 detail: \"ready_to_migrate\".to_string(),\n             });\n             continue;\n         }\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:170:29: replace += with *= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "*=",
    "span": {
      "end": {
        "column": 31,
        "line": 170
      },
      "start": {
        "column": 29,
        "line": 170
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with -= in migrate_with_stores\n@@ -172,17 +172,17 @@\n                 name: (*name).to_string(),\n                 status: \"planned\".to_string(),\n                 detail: \"ready_to_migrate\".to_string(),\n             });\n             continue;\n         }\n \n         if let Err(err) = target.set_secret_required(name, &legacy_value) {\n-            report.errors += 1;\n+            report.errors -= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"error\".to_string(),\n                 detail: format!(\"target_write_failed: {err}\"),\n             });\n             continue;\n         }\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:180:27: replace += with -= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "-=",
    "span": {
      "end": {
        "column": 29,
        "line": 180
      },
      "start": {
        "column": 27,
        "line": 180
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with *= in migrate_with_stores\n@@ -172,17 +172,17 @@\n                 name: (*name).to_string(),\n                 status: \"planned\".to_string(),\n                 detail: \"ready_to_migrate\".to_string(),\n             });\n             continue;\n         }\n \n         if let Err(err) = target.set_secret_required(name, &legacy_value) {\n-            report.errors += 1;\n+            report.errors *= /* ~ changed by cargo-mutants ~ */ 1;\n             report.items.push(MigrationItem {\n                 name: (*name).to_string(),\n                 status: \"error\".to_string(),\n                 detail: format!(\"target_write_failed: {err}\"),\n             });\n             continue;\n         }\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:180:27: replace += with *= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "*=",
    "span": {
      "end": {
        "column": 29,
        "line": 180
      },
      "start": {
        "column": 27,
        "line": 180
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with -= in migrate_with_stores\n@@ -186,17 +186,17 @@\n             continue;\n         }\n \n         let detail = match legacy.delete_secret(name) {\n             Ok(()) => \"migrated_and_legacy_deleted\".to_string(),\n             Err(err) => format!(\"migrated_legacy_delete_failed: {err}\"),\n         };\n \n-        report.migrated += 1;\n+        report.migrated -= /* ~ changed by cargo-mutants ~ */ 1;\n         report.items.push(MigrationItem {\n             name: (*name).to_string(),\n             status: \"migrated\".to_string(),\n             detail,\n         });\n     }\n \n     report\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:194:25: replace += with -= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "-=",
    "span": {
      "end": {
        "column": 27,
        "line": 194
      },
      "start": {
        "column": 25,
        "line": 194
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace += with *= in migrate_with_stores\n@@ -186,17 +186,17 @@\n             continue;\n         }\n \n         let detail = match legacy.delete_secret(name) {\n             Ok(()) => \"migrated_and_legacy_deleted\".to_string(),\n             Err(err) => format!(\"migrated_legacy_delete_failed: {err}\"),\n         };\n \n-        report.migrated += 1;\n+        report.migrated *= /* ~ changed by cargo-mutants ~ */ 1;\n         report.items.push(MigrationItem {\n             name: (*name).to_string(),\n             status: \"migrated\".to_string(),\n             detail,\n         });\n     }\n \n     report\n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "migrate_with_stores",
      "return_type": "-> MigrationReport",
      "span": {
        "end": {
          "column": 2,
          "line": 203
        },
        "start": {
          "column": 1,
          "line": 92
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/migration.rs:194:25: replace += with *= in migrate_with_stores",
    "package": "butterfly-bot",
    "replacement": "*=",
    "span": {
      "end": {
        "column": 27,
        "line": 194
      },
      "start": {
        "column": 25,
        "line": 194
      }
    }
  },
  {
    "diff": "--- src/security/migration.rs\n+++ replace run_legacy_secret_migration -> Result<MigrationReport> with Ok(Default::default())\n@@ -198,21 +198,17 @@\n             detail,\n         });\n     }\n \n     report\n }\n \n pub fn run_legacy_secret_migration(mode: MigrationMode) -> Result<MigrationReport> {\n-    crate::security::tpm_provider::require_tpm()?;\n-\n-    let legacy = KeyringLegacySecretStore;\n-    let target = VaultTargetSecretStore;\n-    Ok(migrate_with_stores(mode, LEGACY_SECRET_NAMES, &legacy, &target))\n+    Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     use std::collections::HashMap;\n     use std::sync::Mutex;\n \n",
    "file": "src/security/migration.rs",
    "function": {
      "function_name": "run_legacy_secret_migration",
      "return_type": "-> Result<MigrationReport>",
      "span": {
        "end": {
          "column": 2,
          "line": 211
        },
        "start": {
          "column": 1,
          "line": 205
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/migration.rs:206:5: replace run_legacy_secret_migration -> Result<MigrationReport> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 73,
        "line": 210
      },
      "start": {
        "column": 5,
        "line": 206
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace validate_session_transition -> Result<()> with Ok(())\n@@ -15,20 +15,17 @@\n     Established(Expired) => Expired,\n     Expired(Rekeyed) => Established\n }\n \n pub fn validate_session_transition(\n     machine: &mut ipc_session::StateMachine,\n     input: ipc_session::Input,\n ) -> Result<()> {\n-    machine\n-        .consume(&input)\n-        .map_err(|_| ButterflyBotError::SecurityPolicy(\"DENY_INVALID_TRANSITION\".to_string()))?;\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub struct ReplayGuard {\n     highest_seen: u64,\n     seen: HashSet<u64>,\n }\n \n impl ReplayGuard {\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "validate_session_transition",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 27
        },
        "start": {
          "column": 1,
          "line": 19
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:23:5: replace validate_session_transition -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 26
      },
      "start": {
        "column": 5,
        "line": 23
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace ReplayGuard::validate_counter -> Result<()> with Ok(())\n@@ -35,39 +35,17 @@\n     pub fn new() -> Self {\n         Self {\n             highest_seen: 0,\n             seen: HashSet::new(),\n         }\n     }\n \n     pub fn validate_counter(&mut self, counter: u64) -> Result<()> {\n-        if counter == 0 {\n-            return Err(ButterflyBotError::SecurityPolicy(\n-                \"DENY_REPLAY: counter must start at 1\".to_string(),\n-            ));\n-        }\n-\n-        if self.seen.contains(&counter) {\n-            return Err(ButterflyBotError::SecurityPolicy(\n-                \"DENY_REPLAY: duplicate counter\".to_string(),\n-            ));\n-        }\n-\n-        if counter + 1024 < self.highest_seen {\n-            return Err(ButterflyBotError::SecurityPolicy(\n-                \"DENY_REPLAY: stale counter\".to_string(),\n-            ));\n-        }\n-\n-        self.seen.insert(counter);\n-        if counter > self.highest_seen {\n-            self.highest_seen = counter;\n-        }\n-        Ok(())\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n impl Default for ReplayGuard {\n     fn default() -> Self {\n         Self::new()\n     }\n }\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:43:9: replace ReplayGuard::validate_counter -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 15,
        "line": 65
      },
      "start": {
        "column": 9,
        "line": 43
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace == with != in ReplayGuard::validate_counter\n@@ -35,17 +35,17 @@\n     pub fn new() -> Self {\n         Self {\n             highest_seen: 0,\n             seen: HashSet::new(),\n         }\n     }\n \n     pub fn validate_counter(&mut self, counter: u64) -> Result<()> {\n-        if counter == 0 {\n+        if counter != /* ~ changed by cargo-mutants ~ */ 0 {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: counter must start at 1\".to_string(),\n             ));\n         }\n \n         if self.seen.contains(&counter) {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: duplicate counter\".to_string(),\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:43:20: replace == with != in ReplayGuard::validate_counter",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 22,
        "line": 43
      },
      "start": {
        "column": 20,
        "line": 43
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace < with == in ReplayGuard::validate_counter\n@@ -47,17 +47,17 @@\n         }\n \n         if self.seen.contains(&counter) {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: duplicate counter\".to_string(),\n             ));\n         }\n \n-        if counter + 1024 < self.highest_seen {\n+        if counter + 1024 == /* ~ changed by cargo-mutants ~ */ self.highest_seen {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: stale counter\".to_string(),\n             ));\n         }\n \n         self.seen.insert(counter);\n         if counter > self.highest_seen {\n             self.highest_seen = counter;\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:55:27: replace < with == in ReplayGuard::validate_counter",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 28,
        "line": 55
      },
      "start": {
        "column": 27,
        "line": 55
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace < with > in ReplayGuard::validate_counter\n@@ -47,17 +47,17 @@\n         }\n \n         if self.seen.contains(&counter) {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: duplicate counter\".to_string(),\n             ));\n         }\n \n-        if counter + 1024 < self.highest_seen {\n+        if counter + 1024 > /* ~ changed by cargo-mutants ~ */ self.highest_seen {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: stale counter\".to_string(),\n             ));\n         }\n \n         self.seen.insert(counter);\n         if counter > self.highest_seen {\n             self.highest_seen = counter;\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:55:27: replace < with > in ReplayGuard::validate_counter",
    "package": "butterfly-bot",
    "replacement": ">",
    "span": {
      "end": {
        "column": 28,
        "line": 55
      },
      "start": {
        "column": 27,
        "line": 55
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace < with <= in ReplayGuard::validate_counter\n@@ -47,17 +47,17 @@\n         }\n \n         if self.seen.contains(&counter) {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: duplicate counter\".to_string(),\n             ));\n         }\n \n-        if counter + 1024 < self.highest_seen {\n+        if counter + 1024 <= /* ~ changed by cargo-mutants ~ */ self.highest_seen {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: stale counter\".to_string(),\n             ));\n         }\n \n         self.seen.insert(counter);\n         if counter > self.highest_seen {\n             self.highest_seen = counter;\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:55:27: replace < with <= in ReplayGuard::validate_counter",
    "package": "butterfly-bot",
    "replacement": "<=",
    "span": {
      "end": {
        "column": 28,
        "line": 55
      },
      "start": {
        "column": 27,
        "line": 55
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace + with - in ReplayGuard::validate_counter\n@@ -47,17 +47,17 @@\n         }\n \n         if self.seen.contains(&counter) {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: duplicate counter\".to_string(),\n             ));\n         }\n \n-        if counter + 1024 < self.highest_seen {\n+        if counter - /* ~ changed by cargo-mutants ~ */ 1024 < self.highest_seen {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: stale counter\".to_string(),\n             ));\n         }\n \n         self.seen.insert(counter);\n         if counter > self.highest_seen {\n             self.highest_seen = counter;\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:55:20: replace + with - in ReplayGuard::validate_counter",
    "package": "butterfly-bot",
    "replacement": "-",
    "span": {
      "end": {
        "column": 21,
        "line": 55
      },
      "start": {
        "column": 20,
        "line": 55
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace + with * in ReplayGuard::validate_counter\n@@ -47,17 +47,17 @@\n         }\n \n         if self.seen.contains(&counter) {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: duplicate counter\".to_string(),\n             ));\n         }\n \n-        if counter + 1024 < self.highest_seen {\n+        if counter * /* ~ changed by cargo-mutants ~ */ 1024 < self.highest_seen {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: stale counter\".to_string(),\n             ));\n         }\n \n         self.seen.insert(counter);\n         if counter > self.highest_seen {\n             self.highest_seen = counter;\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:55:20: replace + with * in ReplayGuard::validate_counter",
    "package": "butterfly-bot",
    "replacement": "*",
    "span": {
      "end": {
        "column": 21,
        "line": 55
      },
      "start": {
        "column": 20,
        "line": 55
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace > with == in ReplayGuard::validate_counter\n@@ -54,17 +54,17 @@\n \n         if counter + 1024 < self.highest_seen {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: stale counter\".to_string(),\n             ));\n         }\n \n         self.seen.insert(counter);\n-        if counter > self.highest_seen {\n+        if counter == /* ~ changed by cargo-mutants ~ */ self.highest_seen {\n             self.highest_seen = counter;\n         }\n         Ok(())\n     }\n }\n \n impl Default for ReplayGuard {\n     fn default() -> Self {\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:62:20: replace > with == in ReplayGuard::validate_counter",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 21,
        "line": 62
      },
      "start": {
        "column": 20,
        "line": 62
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace > with < in ReplayGuard::validate_counter\n@@ -54,17 +54,17 @@\n \n         if counter + 1024 < self.highest_seen {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: stale counter\".to_string(),\n             ));\n         }\n \n         self.seen.insert(counter);\n-        if counter > self.highest_seen {\n+        if counter < /* ~ changed by cargo-mutants ~ */ self.highest_seen {\n             self.highest_seen = counter;\n         }\n         Ok(())\n     }\n }\n \n impl Default for ReplayGuard {\n     fn default() -> Self {\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:62:20: replace > with < in ReplayGuard::validate_counter",
    "package": "butterfly-bot",
    "replacement": "<",
    "span": {
      "end": {
        "column": 21,
        "line": 62
      },
      "start": {
        "column": 20,
        "line": 62
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace > with >= in ReplayGuard::validate_counter\n@@ -54,17 +54,17 @@\n \n         if counter + 1024 < self.highest_seen {\n             return Err(ButterflyBotError::SecurityPolicy(\n                 \"DENY_REPLAY: stale counter\".to_string(),\n             ));\n         }\n \n         self.seen.insert(counter);\n-        if counter > self.highest_seen {\n+        if counter >= /* ~ changed by cargo-mutants ~ */ self.highest_seen {\n             self.highest_seen = counter;\n         }\n         Ok(())\n     }\n }\n \n impl Default for ReplayGuard {\n     fn default() -> Self {\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "ReplayGuard::validate_counter",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 66
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:62:20: replace > with >= in ReplayGuard::validate_counter",
    "package": "butterfly-bot",
    "replacement": ">=",
    "span": {
      "end": {
        "column": 21,
        "line": 62
      },
      "start": {
        "column": 20,
        "line": 62
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace enforce_same_user_peer -> Result<()> with Ok(())\n@@ -69,50 +69,17 @@\n impl Default for ReplayGuard {\n     fn default() -> Self {\n         Self::new()\n     }\n }\n \n #[cfg(target_os = \"linux\")]\n pub fn enforce_same_user_peer(stream: &UnixStream) -> Result<()> {\n-    use std::os::fd::AsRawFd;\n-\n-    let fd = stream.as_raw_fd();\n-    let mut cred = libc::ucred {\n-        pid: 0,\n-        uid: 0,\n-        gid: 0,\n-    };\n-    let mut len = std::mem::size_of::<libc::ucred>() as libc::socklen_t;\n-\n-    let rc = unsafe {\n-        libc::getsockopt(\n-            fd,\n-            libc::SOL_SOCKET,\n-            libc::SO_PEERCRED,\n-            &mut cred as *mut _ as *mut libc::c_void,\n-            &mut len,\n-        )\n-    };\n-\n-    if rc != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"DENY_UNAUTHORIZED_IPC_CALLER: peer credential lookup failed\".to_string(),\n-        ));\n-    }\n-\n-    let current_uid = unsafe { libc::geteuid() };\n-    if cred.uid != current_uid {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"DENY_UNAUTHORIZED_IPC_CALLER: uid mismatch\".to_string(),\n-        ));\n-    }\n-\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(not(target_os = \"linux\"))]\n pub fn enforce_same_user_peer(_stream: &UnixStream) -> Result<()> {\n     Ok(())\n }\n \n fn nonce_from_counter(counter: u64, direction: u8) -> [u8; 24] {\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "enforce_same_user_peer",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 111
        },
        "start": {
          "column": 1,
          "line": 75
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:77:5: replace enforce_same_user_peer -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 110
      },
      "start": {
        "column": 5,
        "line": 77
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace != with == in enforce_same_user_peer\n@@ -89,17 +89,17 @@\n             fd,\n             libc::SOL_SOCKET,\n             libc::SO_PEERCRED,\n             &mut cred as *mut _ as *mut libc::c_void,\n             &mut len,\n         )\n     };\n \n-    if rc != 0 {\n+    if rc == /* ~ changed by cargo-mutants ~ */ 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"DENY_UNAUTHORIZED_IPC_CALLER: peer credential lookup failed\".to_string(),\n         ));\n     }\n \n     let current_uid = unsafe { libc::geteuid() };\n     if cred.uid != current_uid {\n         return Err(ButterflyBotError::SecurityPolicy(\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "enforce_same_user_peer",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 111
        },
        "start": {
          "column": 1,
          "line": 75
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:97:11: replace != with == in enforce_same_user_peer",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 13,
        "line": 97
      },
      "start": {
        "column": 11,
        "line": 97
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace != with == in enforce_same_user_peer\n@@ -96,17 +96,17 @@\n \n     if rc != 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"DENY_UNAUTHORIZED_IPC_CALLER: peer credential lookup failed\".to_string(),\n         ));\n     }\n \n     let current_uid = unsafe { libc::geteuid() };\n-    if cred.uid != current_uid {\n+    if cred.uid == /* ~ changed by cargo-mutants ~ */ current_uid {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"DENY_UNAUTHORIZED_IPC_CALLER: uid mismatch\".to_string(),\n         ));\n     }\n \n     Ok(())\n }\n \n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "enforce_same_user_peer",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 111
        },
        "start": {
          "column": 1,
          "line": 75
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:104:17: replace != with == in enforce_same_user_peer",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 19,
        "line": 104
      },
      "start": {
        "column": 17,
        "line": 104
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace nonce_from_counter -> [u8; 24] with [0; 24]\n@@ -111,20 +111,17 @@\n }\n \n #[cfg(not(target_os = \"linux\"))]\n pub fn enforce_same_user_peer(_stream: &UnixStream) -> Result<()> {\n     Ok(())\n }\n \n fn nonce_from_counter(counter: u64, direction: u8) -> [u8; 24] {\n-    let mut nonce = [0u8; 24];\n-    nonce[0] = direction;\n-    nonce[8..16].copy_from_slice(&counter.to_be_bytes());\n-    nonce\n+    [0; 24] /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn encrypt_payload(\n     session_key: &[u8; 32],\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n     plaintext: &[u8],\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "nonce_from_counter",
      "return_type": "-> [u8; 24]",
      "span": {
        "end": {
          "column": 2,
          "line": 123
        },
        "start": {
          "column": 1,
          "line": 118
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:119:5: replace nonce_from_counter -> [u8; 24] with [0; 24]",
    "package": "butterfly-bot",
    "replacement": "[0; 24]",
    "span": {
      "end": {
        "column": 10,
        "line": 122
      },
      "start": {
        "column": 5,
        "line": 119
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace nonce_from_counter -> [u8; 24] with [1; 24]\n@@ -111,20 +111,17 @@\n }\n \n #[cfg(not(target_os = \"linux\"))]\n pub fn enforce_same_user_peer(_stream: &UnixStream) -> Result<()> {\n     Ok(())\n }\n \n fn nonce_from_counter(counter: u64, direction: u8) -> [u8; 24] {\n-    let mut nonce = [0u8; 24];\n-    nonce[0] = direction;\n-    nonce[8..16].copy_from_slice(&counter.to_be_bytes());\n-    nonce\n+    [1; 24] /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn encrypt_payload(\n     session_key: &[u8; 32],\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n     plaintext: &[u8],\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "nonce_from_counter",
      "return_type": "-> [u8; 24]",
      "span": {
        "end": {
          "column": 2,
          "line": 123
        },
        "start": {
          "column": 1,
          "line": 118
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:119:5: replace nonce_from_counter -> [u8; 24] with [1; 24]",
    "package": "butterfly-bot",
    "replacement": "[1; 24]",
    "span": {
      "end": {
        "column": 10,
        "line": 122
      },
      "start": {
        "column": 5,
        "line": 119
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace encrypt_payload -> Result<Vec<u8>> with Ok(vec![])\n@@ -124,35 +124,17 @@\n \n pub fn encrypt_payload(\n     session_key: &[u8; 32],\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n     plaintext: &[u8],\n ) -> Result<Vec<u8>> {\n-    if counter == 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"DENY_REPLAY: counter must start at 1\".to_string(),\n-        ));\n-    }\n-\n-    let cipher = XChaCha20Poly1305::new(Key::from_slice(session_key));\n-    let nonce_bytes = nonce_from_counter(counter, direction);\n-    let nonce = XNonce::from_slice(&nonce_bytes);\n-\n-    cipher\n-        .encrypt(\n-            nonce,\n-            Payload {\n-                msg: plaintext,\n-                aad,\n-            },\n-        )\n-        .map_err(|_| ButterflyBotError::SecurityPolicy(\"DENY_AEAD_INTEGRITY\".to_string()))\n+    Ok(vec![]) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn decrypt_payload(\n     session_key: &[u8; 32],\n     replay_guard: &mut ReplayGuard,\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "encrypt_payload",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 151
        },
        "start": {
          "column": 1,
          "line": 125
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:132:5: replace encrypt_payload -> Result<Vec<u8>> with Ok(vec![])",
    "package": "butterfly-bot",
    "replacement": "Ok(vec![])",
    "span": {
      "end": {
        "column": 91,
        "line": 150
      },
      "start": {
        "column": 5,
        "line": 132
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace encrypt_payload -> Result<Vec<u8>> with Ok(vec![0])\n@@ -124,35 +124,17 @@\n \n pub fn encrypt_payload(\n     session_key: &[u8; 32],\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n     plaintext: &[u8],\n ) -> Result<Vec<u8>> {\n-    if counter == 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"DENY_REPLAY: counter must start at 1\".to_string(),\n-        ));\n-    }\n-\n-    let cipher = XChaCha20Poly1305::new(Key::from_slice(session_key));\n-    let nonce_bytes = nonce_from_counter(counter, direction);\n-    let nonce = XNonce::from_slice(&nonce_bytes);\n-\n-    cipher\n-        .encrypt(\n-            nonce,\n-            Payload {\n-                msg: plaintext,\n-                aad,\n-            },\n-        )\n-        .map_err(|_| ButterflyBotError::SecurityPolicy(\"DENY_AEAD_INTEGRITY\".to_string()))\n+    Ok(vec![0]) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn decrypt_payload(\n     session_key: &[u8; 32],\n     replay_guard: &mut ReplayGuard,\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "encrypt_payload",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 151
        },
        "start": {
          "column": 1,
          "line": 125
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:132:5: replace encrypt_payload -> Result<Vec<u8>> with Ok(vec![0])",
    "package": "butterfly-bot",
    "replacement": "Ok(vec![0])",
    "span": {
      "end": {
        "column": 91,
        "line": 150
      },
      "start": {
        "column": 5,
        "line": 132
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace encrypt_payload -> Result<Vec<u8>> with Ok(vec![1])\n@@ -124,35 +124,17 @@\n \n pub fn encrypt_payload(\n     session_key: &[u8; 32],\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n     plaintext: &[u8],\n ) -> Result<Vec<u8>> {\n-    if counter == 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"DENY_REPLAY: counter must start at 1\".to_string(),\n-        ));\n-    }\n-\n-    let cipher = XChaCha20Poly1305::new(Key::from_slice(session_key));\n-    let nonce_bytes = nonce_from_counter(counter, direction);\n-    let nonce = XNonce::from_slice(&nonce_bytes);\n-\n-    cipher\n-        .encrypt(\n-            nonce,\n-            Payload {\n-                msg: plaintext,\n-                aad,\n-            },\n-        )\n-        .map_err(|_| ButterflyBotError::SecurityPolicy(\"DENY_AEAD_INTEGRITY\".to_string()))\n+    Ok(vec![1]) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn decrypt_payload(\n     session_key: &[u8; 32],\n     replay_guard: &mut ReplayGuard,\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "encrypt_payload",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 151
        },
        "start": {
          "column": 1,
          "line": 125
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:132:5: replace encrypt_payload -> Result<Vec<u8>> with Ok(vec![1])",
    "package": "butterfly-bot",
    "replacement": "Ok(vec![1])",
    "span": {
      "end": {
        "column": 91,
        "line": 150
      },
      "start": {
        "column": 5,
        "line": 132
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace == with != in encrypt_payload\n@@ -124,17 +124,17 @@\n \n pub fn encrypt_payload(\n     session_key: &[u8; 32],\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n     plaintext: &[u8],\n ) -> Result<Vec<u8>> {\n-    if counter == 0 {\n+    if counter != /* ~ changed by cargo-mutants ~ */ 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"DENY_REPLAY: counter must start at 1\".to_string(),\n         ));\n     }\n \n     let cipher = XChaCha20Poly1305::new(Key::from_slice(session_key));\n     let nonce_bytes = nonce_from_counter(counter, direction);\n     let nonce = XNonce::from_slice(&nonce_bytes);\n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "encrypt_payload",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 151
        },
        "start": {
          "column": 1,
          "line": 125
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/ipc.rs:132:16: replace == with != in encrypt_payload",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 18,
        "line": 132
      },
      "start": {
        "column": 16,
        "line": 132
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace decrypt_payload -> Result<Vec<u8>> with Ok(vec![])\n@@ -153,31 +153,17 @@\n pub fn decrypt_payload(\n     session_key: &[u8; 32],\n     replay_guard: &mut ReplayGuard,\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n     ciphertext: &[u8],\n ) -> Result<Vec<u8>> {\n-    replay_guard.validate_counter(counter)?;\n-\n-    let cipher = XChaCha20Poly1305::new(Key::from_slice(session_key));\n-    let nonce_bytes = nonce_from_counter(counter, direction);\n-    let nonce = XNonce::from_slice(&nonce_bytes);\n-\n-    cipher\n-        .decrypt(\n-            nonce,\n-            Payload {\n-                msg: ciphertext,\n-                aad,\n-            },\n-        )\n-        .map_err(|_| ButterflyBotError::SecurityPolicy(\"DENY_AEAD_INTEGRITY\".to_string()))\n+    Ok(vec![]) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     #[cfg(unix)]\n     use std::os::unix::net::UnixStream;\n \n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "decrypt_payload",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 176
        },
        "start": {
          "column": 1,
          "line": 153
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:161:5: replace decrypt_payload -> Result<Vec<u8>> with Ok(vec![])",
    "package": "butterfly-bot",
    "replacement": "Ok(vec![])",
    "span": {
      "end": {
        "column": 91,
        "line": 175
      },
      "start": {
        "column": 5,
        "line": 161
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace decrypt_payload -> Result<Vec<u8>> with Ok(vec![0])\n@@ -153,31 +153,17 @@\n pub fn decrypt_payload(\n     session_key: &[u8; 32],\n     replay_guard: &mut ReplayGuard,\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n     ciphertext: &[u8],\n ) -> Result<Vec<u8>> {\n-    replay_guard.validate_counter(counter)?;\n-\n-    let cipher = XChaCha20Poly1305::new(Key::from_slice(session_key));\n-    let nonce_bytes = nonce_from_counter(counter, direction);\n-    let nonce = XNonce::from_slice(&nonce_bytes);\n-\n-    cipher\n-        .decrypt(\n-            nonce,\n-            Payload {\n-                msg: ciphertext,\n-                aad,\n-            },\n-        )\n-        .map_err(|_| ButterflyBotError::SecurityPolicy(\"DENY_AEAD_INTEGRITY\".to_string()))\n+    Ok(vec![0]) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     #[cfg(unix)]\n     use std::os::unix::net::UnixStream;\n \n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "decrypt_payload",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 176
        },
        "start": {
          "column": 1,
          "line": 153
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:161:5: replace decrypt_payload -> Result<Vec<u8>> with Ok(vec![0])",
    "package": "butterfly-bot",
    "replacement": "Ok(vec![0])",
    "span": {
      "end": {
        "column": 91,
        "line": 175
      },
      "start": {
        "column": 5,
        "line": 161
      }
    }
  },
  {
    "diff": "--- src/security/ipc.rs\n+++ replace decrypt_payload -> Result<Vec<u8>> with Ok(vec![1])\n@@ -153,31 +153,17 @@\n pub fn decrypt_payload(\n     session_key: &[u8; 32],\n     replay_guard: &mut ReplayGuard,\n     counter: u64,\n     direction: u8,\n     aad: &[u8],\n     ciphertext: &[u8],\n ) -> Result<Vec<u8>> {\n-    replay_guard.validate_counter(counter)?;\n-\n-    let cipher = XChaCha20Poly1305::new(Key::from_slice(session_key));\n-    let nonce_bytes = nonce_from_counter(counter, direction);\n-    let nonce = XNonce::from_slice(&nonce_bytes);\n-\n-    cipher\n-        .decrypt(\n-            nonce,\n-            Payload {\n-                msg: ciphertext,\n-                aad,\n-            },\n-        )\n-        .map_err(|_| ButterflyBotError::SecurityPolicy(\"DENY_AEAD_INTEGRITY\".to_string()))\n+    Ok(vec![1]) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     #[cfg(unix)]\n     use std::os::unix::net::UnixStream;\n \n",
    "file": "src/security/ipc.rs",
    "function": {
      "function_name": "decrypt_payload",
      "return_type": "-> Result<Vec<u8>>",
      "span": {
        "end": {
          "column": 2,
          "line": 176
        },
        "start": {
          "column": 1,
          "line": 153
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/ipc.rs:161:5: replace decrypt_payload -> Result<Vec<u8>> with Ok(vec![1])",
    "package": "butterfly-bot",
    "replacement": "Ok(vec![1])",
    "span": {
      "end": {
        "column": 91,
        "line": 175
      },
      "start": {
        "column": 5,
        "line": 161
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace PolicyEngine::evaluate -> PolicyDecision with Default::default()\n@@ -35,51 +35,17 @@\n pub struct PolicyEngine {\n     pub user_limits: PolicyLimits,\n     pub global_limits: PolicyLimits,\n     pub trusted_payees: Vec<String>,\n }\n \n impl PolicyEngine {\n     pub fn evaluate(&self, intent: &SigningIntent, user_daily_spend: u64) -> PolicyDecision {\n-        if intent.context_requires_approval {\n-            return PolicyDecision::NeedsApproval {\n-                reason_code: PROMPT_CONTEXT_REQUIRED,\n-            };\n-        }\n-\n-        if !self\n-            .trusted_payees\n-            .iter()\n-            .any(|payee| payee == &intent.payee)\n-        {\n-            return PolicyDecision::Denied {\n-                reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n-            };\n-        }\n-\n-        if intent.amount_atomic > self.global_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n-        {\n-            return PolicyDecision::Denied {\n-                reason_code: DENY_GLOBAL_LIMIT,\n-            };\n-        }\n-\n-        if intent.amount_atomic > self.user_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n-        {\n-            return PolicyDecision::NeedsApproval {\n-                reason_code: PROMPT_USER_LIMIT_EXCEEDED,\n-            };\n-        }\n-\n-        PolicyDecision::AutoApproved {\n-            reason_code: ALLOW_AUTO_POLICY_OK,\n-        }\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n impl PolicyEngine {\n     pub fn from_json(value: &serde_json::Value) -> Result<Self, ButterflyBotError> {\n         let object = value.as_object().ok_or_else(|| {\n             ButterflyBotError::SecurityPolicy(\"policy config must be an object\".to_string())\n         })?;\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/policy.rs:43:9: replace PolicyEngine::evaluate -> PolicyDecision with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 10,
        "line": 77
      },
      "start": {
        "column": 9,
        "line": 43
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ delete ! in PolicyEngine::evaluate\n@@ -41,17 +41,17 @@\n impl PolicyEngine {\n     pub fn evaluate(&self, intent: &SigningIntent, user_daily_spend: u64) -> PolicyDecision {\n         if intent.context_requires_approval {\n             return PolicyDecision::NeedsApproval {\n                 reason_code: PROMPT_CONTEXT_REQUIRED,\n             };\n         }\n \n-        if !self\n+        if  /* ~ changed by cargo-mutants ~ */self\n             .trusted_payees\n             .iter()\n             .any(|payee| payee == &intent.payee)\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n             };\n         }\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/security/policy.rs:49:12: delete ! in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 13,
        "line": 49
      },
      "start": {
        "column": 12,
        "line": 49
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace == with != in PolicyEngine::evaluate\n@@ -44,17 +44,17 @@\n             return PolicyDecision::NeedsApproval {\n                 reason_code: PROMPT_CONTEXT_REQUIRED,\n             };\n         }\n \n         if !self\n             .trusted_payees\n             .iter()\n-            .any(|payee| payee == &intent.payee)\n+            .any(|payee| payee != /* ~ changed by cargo-mutants ~ */ &intent.payee)\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n             };\n         }\n \n         if intent.amount_atomic > self.global_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:52:32: replace == with != in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 34,
        "line": 52
      },
      "start": {
        "column": 32,
        "line": 52
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace || with && in PolicyEngine::evaluate\n@@ -52,17 +52,17 @@\n             .any(|payee| payee == &intent.payee)\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n             };\n         }\n \n         if intent.amount_atomic > self.global_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n+            && /* ~ changed by cargo-mutants ~ */ user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:60:13: replace || with && in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 15,
        "line": 60
      },
      "start": {
        "column": 13,
        "line": 60
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with == in PolicyEngine::evaluate\n@@ -51,17 +51,17 @@\n             .iter()\n             .any(|payee| payee == &intent.payee)\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n             };\n         }\n \n-        if intent.amount_atomic > self.global_limits.per_tx_limit\n+        if intent.amount_atomic == /* ~ changed by cargo-mutants ~ */ self.global_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:59:33: replace > with == in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 34,
        "line": 59
      },
      "start": {
        "column": 33,
        "line": 59
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with < in PolicyEngine::evaluate\n@@ -51,17 +51,17 @@\n             .iter()\n             .any(|payee| payee == &intent.payee)\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n             };\n         }\n \n-        if intent.amount_atomic > self.global_limits.per_tx_limit\n+        if intent.amount_atomic < /* ~ changed by cargo-mutants ~ */ self.global_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:59:33: replace > with < in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "<",
    "span": {
      "end": {
        "column": 34,
        "line": 59
      },
      "start": {
        "column": 33,
        "line": 59
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with >= in PolicyEngine::evaluate\n@@ -51,17 +51,17 @@\n             .iter()\n             .any(|payee| payee == &intent.payee)\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n             };\n         }\n \n-        if intent.amount_atomic > self.global_limits.per_tx_limit\n+        if intent.amount_atomic >= /* ~ changed by cargo-mutants ~ */ self.global_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:59:33: replace > with >= in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": ">=",
    "span": {
      "end": {
        "column": 34,
        "line": 59
      },
      "start": {
        "column": 33,
        "line": 59
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with == in PolicyEngine::evaluate\n@@ -52,17 +52,17 @@\n             .any(|payee| payee == &intent.payee)\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n             };\n         }\n \n         if intent.amount_atomic > self.global_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n+            || user_daily_spend.saturating_add(intent.amount_atomic) == /* ~ changed by cargo-mutants ~ */ self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:60:70: replace > with == in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 71,
        "line": 60
      },
      "start": {
        "column": 70,
        "line": 60
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with < in PolicyEngine::evaluate\n@@ -52,17 +52,17 @@\n             .any(|payee| payee == &intent.payee)\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n             };\n         }\n \n         if intent.amount_atomic > self.global_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n+            || user_daily_spend.saturating_add(intent.amount_atomic) < /* ~ changed by cargo-mutants ~ */ self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:60:70: replace > with < in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "<",
    "span": {
      "end": {
        "column": 71,
        "line": 60
      },
      "start": {
        "column": 70,
        "line": 60
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with >= in PolicyEngine::evaluate\n@@ -52,17 +52,17 @@\n             .any(|payee| payee == &intent.payee)\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_UNTRUSTED_FACILITATOR_OR_PAYEE,\n             };\n         }\n \n         if intent.amount_atomic > self.global_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n+            || user_daily_spend.saturating_add(intent.amount_atomic) >= /* ~ changed by cargo-mutants ~ */ self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:60:70: replace > with >= in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": ">=",
    "span": {
      "end": {
        "column": 71,
        "line": 60
      },
      "start": {
        "column": 70,
        "line": 60
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace || with && in PolicyEngine::evaluate\n@@ -60,17 +60,17 @@\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n+            && /* ~ changed by cargo-mutants ~ */ user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n         {\n             return PolicyDecision::NeedsApproval {\n                 reason_code: PROMPT_USER_LIMIT_EXCEEDED,\n             };\n         }\n \n         PolicyDecision::AutoApproved {\n             reason_code: ALLOW_AUTO_POLICY_OK,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:68:13: replace || with && in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 15,
        "line": 68
      },
      "start": {
        "column": 13,
        "line": 68
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with == in PolicyEngine::evaluate\n@@ -59,17 +59,17 @@\n         if intent.amount_atomic > self.global_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n-        if intent.amount_atomic > self.user_limits.per_tx_limit\n+        if intent.amount_atomic == /* ~ changed by cargo-mutants ~ */ self.user_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n         {\n             return PolicyDecision::NeedsApproval {\n                 reason_code: PROMPT_USER_LIMIT_EXCEEDED,\n             };\n         }\n \n         PolicyDecision::AutoApproved {\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:67:33: replace > with == in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 34,
        "line": 67
      },
      "start": {
        "column": 33,
        "line": 67
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with < in PolicyEngine::evaluate\n@@ -59,17 +59,17 @@\n         if intent.amount_atomic > self.global_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n-        if intent.amount_atomic > self.user_limits.per_tx_limit\n+        if intent.amount_atomic < /* ~ changed by cargo-mutants ~ */ self.user_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n         {\n             return PolicyDecision::NeedsApproval {\n                 reason_code: PROMPT_USER_LIMIT_EXCEEDED,\n             };\n         }\n \n         PolicyDecision::AutoApproved {\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:67:33: replace > with < in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "<",
    "span": {
      "end": {
        "column": 34,
        "line": 67
      },
      "start": {
        "column": 33,
        "line": 67
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with >= in PolicyEngine::evaluate\n@@ -59,17 +59,17 @@\n         if intent.amount_atomic > self.global_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n-        if intent.amount_atomic > self.user_limits.per_tx_limit\n+        if intent.amount_atomic >= /* ~ changed by cargo-mutants ~ */ self.user_limits.per_tx_limit\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n         {\n             return PolicyDecision::NeedsApproval {\n                 reason_code: PROMPT_USER_LIMIT_EXCEEDED,\n             };\n         }\n \n         PolicyDecision::AutoApproved {\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:67:33: replace > with >= in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": ">=",
    "span": {
      "end": {
        "column": 34,
        "line": 67
      },
      "start": {
        "column": 33,
        "line": 67
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with == in PolicyEngine::evaluate\n@@ -60,17 +60,17 @@\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n+            || user_daily_spend.saturating_add(intent.amount_atomic) == /* ~ changed by cargo-mutants ~ */ self.user_limits.daily_limit\n         {\n             return PolicyDecision::NeedsApproval {\n                 reason_code: PROMPT_USER_LIMIT_EXCEEDED,\n             };\n         }\n \n         PolicyDecision::AutoApproved {\n             reason_code: ALLOW_AUTO_POLICY_OK,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:68:70: replace > with == in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 71,
        "line": 68
      },
      "start": {
        "column": 70,
        "line": 68
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with < in PolicyEngine::evaluate\n@@ -60,17 +60,17 @@\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n+            || user_daily_spend.saturating_add(intent.amount_atomic) < /* ~ changed by cargo-mutants ~ */ self.user_limits.daily_limit\n         {\n             return PolicyDecision::NeedsApproval {\n                 reason_code: PROMPT_USER_LIMIT_EXCEEDED,\n             };\n         }\n \n         PolicyDecision::AutoApproved {\n             reason_code: ALLOW_AUTO_POLICY_OK,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:68:70: replace > with < in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": "<",
    "span": {
      "end": {
        "column": 71,
        "line": 68
      },
      "start": {
        "column": 70,
        "line": 68
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with >= in PolicyEngine::evaluate\n@@ -60,17 +60,17 @@\n             || user_daily_spend.saturating_add(intent.amount_atomic) > self.global_limits.daily_limit\n         {\n             return PolicyDecision::Denied {\n                 reason_code: DENY_GLOBAL_LIMIT,\n             };\n         }\n \n         if intent.amount_atomic > self.user_limits.per_tx_limit\n-            || user_daily_spend.saturating_add(intent.amount_atomic) > self.user_limits.daily_limit\n+            || user_daily_spend.saturating_add(intent.amount_atomic) >= /* ~ changed by cargo-mutants ~ */ self.user_limits.daily_limit\n         {\n             return PolicyDecision::NeedsApproval {\n                 reason_code: PROMPT_USER_LIMIT_EXCEEDED,\n             };\n         }\n \n         PolicyDecision::AutoApproved {\n             reason_code: ALLOW_AUTO_POLICY_OK,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::evaluate",
      "return_type": "-> PolicyDecision",
      "span": {
        "end": {
          "column": 6,
          "line": 78
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:68:70: replace > with >= in PolicyEngine::evaluate",
    "package": "butterfly-bot",
    "replacement": ">=",
    "span": {
      "end": {
        "column": 71,
        "line": 68
      },
      "start": {
        "column": 70,
        "line": 68
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace PolicyEngine::from_json -> Result<Self, ButterflyBotError> with Ok(Default::default())\n@@ -75,84 +75,17 @@\n         PolicyDecision::AutoApproved {\n             reason_code: ALLOW_AUTO_POLICY_OK,\n         }\n     }\n }\n \n impl PolicyEngine {\n     pub fn from_json(value: &serde_json::Value) -> Result<Self, ButterflyBotError> {\n-        let object = value.as_object().ok_or_else(|| {\n-            ButterflyBotError::SecurityPolicy(\"policy config must be an object\".to_string())\n-        })?;\n-\n-        let user = object.get(\"user_limits\").and_then(|v| v.as_object()).ok_or_else(|| {\n-            ButterflyBotError::SecurityPolicy(\"policy config missing user_limits\".to_string())\n-        })?;\n-        let global = object\n-            .get(\"global_limits\")\n-            .and_then(|v| v.as_object())\n-            .ok_or_else(|| {\n-                ButterflyBotError::SecurityPolicy(\"policy config missing global_limits\".to_string())\n-            })?;\n-        let trusted_payees = object\n-            .get(\"trusted_payees\")\n-            .and_then(|v| v.as_array())\n-            .ok_or_else(|| {\n-                ButterflyBotError::SecurityPolicy(\"policy config missing trusted_payees\".to_string())\n-            })?;\n-\n-        let parse_limits = |entry: &serde_json::Map<String, serde_json::Value>| -> Result<PolicyLimits, ButterflyBotError> {\n-            let per_tx_limit = entry\n-                .get(\"per_tx_limit\")\n-                .and_then(|v| v.as_u64())\n-                .ok_or_else(|| {\n-                    ButterflyBotError::SecurityPolicy(\n-                        \"policy limits require per_tx_limit\".to_string(),\n-                    )\n-                })?;\n-            let daily_limit = entry\n-                .get(\"daily_limit\")\n-                .and_then(|v| v.as_u64())\n-                .ok_or_else(|| {\n-                    ButterflyBotError::SecurityPolicy(\n-                        \"policy limits require daily_limit\".to_string(),\n-                    )\n-                })?;\n-\n-            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit > daily_limit {\n-                return Err(ButterflyBotError::SecurityPolicy(\n-                    \"policy limits are invalid\".to_string(),\n-                ));\n-            }\n-\n-            Ok(PolicyLimits {\n-                per_tx_limit,\n-                daily_limit,\n-            })\n-        };\n-\n-        let mut payees = Vec::new();\n-        for value in trusted_payees {\n-            let payee = value.as_str().ok_or_else(|| {\n-                ButterflyBotError::SecurityPolicy(\"trusted_payees must be strings\".to_string())\n-            })?;\n-            if payee.trim().is_empty() {\n-                return Err(ButterflyBotError::SecurityPolicy(\n-                    \"trusted_payees cannot be empty\".to_string(),\n-                ));\n-            }\n-            payees.push(payee.to_string());\n-        }\n-\n-        Ok(Self {\n-            user_limits: parse_limits(user)?,\n-            global_limits: parse_limits(global)?,\n-            trusted_payees: payees,\n-        })\n+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n pub fn default_policy_engine() -> PolicyEngine {\n     PolicyEngine {\n         user_limits: PolicyLimits {\n             per_tx_limit: 100_000,\n             daily_limit: 500_000,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::from_json",
      "return_type": "-> Result<Self, ButterflyBotError>",
      "span": {
        "end": {
          "column": 6,
          "line": 151
        },
        "start": {
          "column": 5,
          "line": 82
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/policy.rs:83:9: replace PolicyEngine::from_json -> Result<Self, ButterflyBotError> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 11,
        "line": 150
      },
      "start": {
        "column": 9,
        "line": 83
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace || with && in PolicyEngine::from_json\n@@ -113,17 +113,17 @@\n                 .get(\"daily_limit\")\n                 .and_then(|v| v.as_u64())\n                 .ok_or_else(|| {\n                     ButterflyBotError::SecurityPolicy(\n                         \"policy limits require daily_limit\".to_string(),\n                     )\n                 })?;\n \n-            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit > daily_limit {\n+            if per_tx_limit == 0 || daily_limit == 0 && /* ~ changed by cargo-mutants ~ */ per_tx_limit > daily_limit {\n                 return Err(ButterflyBotError::SecurityPolicy(\n                     \"policy limits are invalid\".to_string(),\n                 ));\n             }\n \n             Ok(PolicyLimits {\n                 per_tx_limit,\n                 daily_limit,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::from_json",
      "return_type": "-> Result<Self, ButterflyBotError>",
      "span": {
        "end": {
          "column": 6,
          "line": 151
        },
        "start": {
          "column": 5,
          "line": 82
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:121:54: replace || with && in PolicyEngine::from_json",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 56,
        "line": 121
      },
      "start": {
        "column": 54,
        "line": 121
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace || with && in PolicyEngine::from_json\n@@ -113,17 +113,17 @@\n                 .get(\"daily_limit\")\n                 .and_then(|v| v.as_u64())\n                 .ok_or_else(|| {\n                     ButterflyBotError::SecurityPolicy(\n                         \"policy limits require daily_limit\".to_string(),\n                     )\n                 })?;\n \n-            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit > daily_limit {\n+            if per_tx_limit == 0 && /* ~ changed by cargo-mutants ~ */ daily_limit == 0 || per_tx_limit > daily_limit {\n                 return Err(ButterflyBotError::SecurityPolicy(\n                     \"policy limits are invalid\".to_string(),\n                 ));\n             }\n \n             Ok(PolicyLimits {\n                 per_tx_limit,\n                 daily_limit,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::from_json",
      "return_type": "-> Result<Self, ButterflyBotError>",
      "span": {
        "end": {
          "column": 6,
          "line": 151
        },
        "start": {
          "column": 5,
          "line": 82
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:121:34: replace || with && in PolicyEngine::from_json",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 36,
        "line": 121
      },
      "start": {
        "column": 34,
        "line": 121
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace == with != in PolicyEngine::from_json\n@@ -113,17 +113,17 @@\n                 .get(\"daily_limit\")\n                 .and_then(|v| v.as_u64())\n                 .ok_or_else(|| {\n                     ButterflyBotError::SecurityPolicy(\n                         \"policy limits require daily_limit\".to_string(),\n                     )\n                 })?;\n \n-            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit > daily_limit {\n+            if per_tx_limit != /* ~ changed by cargo-mutants ~ */ 0 || daily_limit == 0 || per_tx_limit > daily_limit {\n                 return Err(ButterflyBotError::SecurityPolicy(\n                     \"policy limits are invalid\".to_string(),\n                 ));\n             }\n \n             Ok(PolicyLimits {\n                 per_tx_limit,\n                 daily_limit,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::from_json",
      "return_type": "-> Result<Self, ButterflyBotError>",
      "span": {
        "end": {
          "column": 6,
          "line": 151
        },
        "start": {
          "column": 5,
          "line": 82
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:121:29: replace == with != in PolicyEngine::from_json",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 31,
        "line": 121
      },
      "start": {
        "column": 29,
        "line": 121
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace == with != in PolicyEngine::from_json\n@@ -113,17 +113,17 @@\n                 .get(\"daily_limit\")\n                 .and_then(|v| v.as_u64())\n                 .ok_or_else(|| {\n                     ButterflyBotError::SecurityPolicy(\n                         \"policy limits require daily_limit\".to_string(),\n                     )\n                 })?;\n \n-            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit > daily_limit {\n+            if per_tx_limit == 0 || daily_limit != /* ~ changed by cargo-mutants ~ */ 0 || per_tx_limit > daily_limit {\n                 return Err(ButterflyBotError::SecurityPolicy(\n                     \"policy limits are invalid\".to_string(),\n                 ));\n             }\n \n             Ok(PolicyLimits {\n                 per_tx_limit,\n                 daily_limit,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::from_json",
      "return_type": "-> Result<Self, ButterflyBotError>",
      "span": {
        "end": {
          "column": 6,
          "line": 151
        },
        "start": {
          "column": 5,
          "line": 82
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:121:49: replace == with != in PolicyEngine::from_json",
    "package": "butterfly-bot",
    "replacement": "!=",
    "span": {
      "end": {
        "column": 51,
        "line": 121
      },
      "start": {
        "column": 49,
        "line": 121
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with == in PolicyEngine::from_json\n@@ -113,17 +113,17 @@\n                 .get(\"daily_limit\")\n                 .and_then(|v| v.as_u64())\n                 .ok_or_else(|| {\n                     ButterflyBotError::SecurityPolicy(\n                         \"policy limits require daily_limit\".to_string(),\n                     )\n                 })?;\n \n-            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit > daily_limit {\n+            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit == /* ~ changed by cargo-mutants ~ */ daily_limit {\n                 return Err(ButterflyBotError::SecurityPolicy(\n                     \"policy limits are invalid\".to_string(),\n                 ));\n             }\n \n             Ok(PolicyLimits {\n                 per_tx_limit,\n                 daily_limit,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::from_json",
      "return_type": "-> Result<Self, ButterflyBotError>",
      "span": {
        "end": {
          "column": 6,
          "line": 151
        },
        "start": {
          "column": 5,
          "line": 82
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:121:70: replace > with == in PolicyEngine::from_json",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 71,
        "line": 121
      },
      "start": {
        "column": 70,
        "line": 121
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with < in PolicyEngine::from_json\n@@ -113,17 +113,17 @@\n                 .get(\"daily_limit\")\n                 .and_then(|v| v.as_u64())\n                 .ok_or_else(|| {\n                     ButterflyBotError::SecurityPolicy(\n                         \"policy limits require daily_limit\".to_string(),\n                     )\n                 })?;\n \n-            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit > daily_limit {\n+            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit < /* ~ changed by cargo-mutants ~ */ daily_limit {\n                 return Err(ButterflyBotError::SecurityPolicy(\n                     \"policy limits are invalid\".to_string(),\n                 ));\n             }\n \n             Ok(PolicyLimits {\n                 per_tx_limit,\n                 daily_limit,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::from_json",
      "return_type": "-> Result<Self, ButterflyBotError>",
      "span": {
        "end": {
          "column": 6,
          "line": 151
        },
        "start": {
          "column": 5,
          "line": 82
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:121:70: replace > with < in PolicyEngine::from_json",
    "package": "butterfly-bot",
    "replacement": "<",
    "span": {
      "end": {
        "column": 71,
        "line": 121
      },
      "start": {
        "column": 70,
        "line": 121
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace > with >= in PolicyEngine::from_json\n@@ -113,17 +113,17 @@\n                 .get(\"daily_limit\")\n                 .and_then(|v| v.as_u64())\n                 .ok_or_else(|| {\n                     ButterflyBotError::SecurityPolicy(\n                         \"policy limits require daily_limit\".to_string(),\n                     )\n                 })?;\n \n-            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit > daily_limit {\n+            if per_tx_limit == 0 || daily_limit == 0 || per_tx_limit >= /* ~ changed by cargo-mutants ~ */ daily_limit {\n                 return Err(ButterflyBotError::SecurityPolicy(\n                     \"policy limits are invalid\".to_string(),\n                 ));\n             }\n \n             Ok(PolicyLimits {\n                 per_tx_limit,\n                 daily_limit,\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "PolicyEngine::from_json",
      "return_type": "-> Result<Self, ButterflyBotError>",
      "span": {
        "end": {
          "column": 6,
          "line": 151
        },
        "start": {
          "column": 5,
          "line": 82
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/policy.rs:121:70: replace > with >= in PolicyEngine::from_json",
    "package": "butterfly-bot",
    "replacement": ">=",
    "span": {
      "end": {
        "column": 71,
        "line": 121
      },
      "start": {
        "column": 70,
        "line": 121
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace default_policy_engine -> PolicyEngine with Default::default()\n@@ -147,27 +147,17 @@\n             user_limits: parse_limits(user)?,\n             global_limits: parse_limits(global)?,\n             trusted_payees: payees,\n         })\n     }\n }\n \n pub fn default_policy_engine() -> PolicyEngine {\n-    PolicyEngine {\n-        user_limits: PolicyLimits {\n-            per_tx_limit: 100_000,\n-            daily_limit: 500_000,\n-        },\n-        global_limits: PolicyLimits {\n-            per_tx_limit: 1_000_000,\n-            daily_limit: 5_000_000,\n-        },\n-        trusted_payees: vec![\"merchant.local\".to_string()],\n-    }\n+    Default::default() /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn ensure_policy_allows(decision: &PolicyDecision) -> Result<(), ButterflyBotError> {\n     match decision {\n         PolicyDecision::Denied { reason_code } => Err(ButterflyBotError::SecurityPolicy(\n             reason_code.to_string(),\n         )),\n         _ => Ok(()),\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "default_policy_engine",
      "return_type": "-> PolicyEngine",
      "span": {
        "end": {
          "column": 2,
          "line": 166
        },
        "start": {
          "column": 1,
          "line": 154
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/policy.rs:155:5: replace default_policy_engine -> PolicyEngine with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 6,
        "line": 165
      },
      "start": {
        "column": 5,
        "line": 155
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ replace ensure_policy_allows -> Result<(), ButterflyBotError> with Ok(())\n@@ -161,22 +161,17 @@\n             per_tx_limit: 1_000_000,\n             daily_limit: 5_000_000,\n         },\n         trusted_payees: vec![\"merchant.local\".to_string()],\n     }\n }\n \n pub fn ensure_policy_allows(decision: &PolicyDecision) -> Result<(), ButterflyBotError> {\n-    match decision {\n-        PolicyDecision::Denied { reason_code } => Err(ButterflyBotError::SecurityPolicy(\n-            reason_code.to_string(),\n-        )),\n-        _ => Ok(()),\n-    }\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     fn base_intent() -> SigningIntent {\n         SigningIntent {\n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "ensure_policy_allows",
      "return_type": "-> Result<(), ButterflyBotError>",
      "span": {
        "end": {
          "column": 2,
          "line": 175
        },
        "start": {
          "column": 1,
          "line": 168
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/policy.rs:169:5: replace ensure_policy_allows -> Result<(), ButterflyBotError> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 6,
        "line": 174
      },
      "start": {
        "column": 5,
        "line": 169
      }
    }
  },
  {
    "diff": "--- src/security/policy.rs\n+++ delete match arm PolicyDecision::Denied{reason_code} in ensure_policy_allows\n@@ -162,19 +162,17 @@\n             daily_limit: 5_000_000,\n         },\n         trusted_payees: vec![\"merchant.local\".to_string()],\n     }\n }\n \n pub fn ensure_policy_allows(decision: &PolicyDecision) -> Result<(), ButterflyBotError> {\n     match decision {\n-        PolicyDecision::Denied { reason_code } => Err(ButterflyBotError::SecurityPolicy(\n-            reason_code.to_string(),\n-        )),\n+         /* ~ changed by cargo-mutants ~ */\n         _ => Ok(()),\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n \n",
    "file": "src/security/policy.rs",
    "function": {
      "function_name": "ensure_policy_allows",
      "return_type": "-> Result<(), ButterflyBotError>",
      "span": {
        "end": {
          "column": 2,
          "line": 175
        },
        "start": {
          "column": 1,
          "line": 168
        }
      }
    },
    "genre": "MatchArm",
    "name": "src/security/policy.rs:170:9: delete match arm PolicyDecision::Denied{reason_code} in ensure_policy_allows",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 12,
        "line": 172
      },
      "start": {
        "column": 9,
        "line": 170
      }
    }
  },
  {
    "diff": "--- src/security/signer_daemon.rs\n+++ replace serve_one_unix_request -> Result<()> with Ok(())\n@@ -60,58 +60,17 @@\n     policy: PolicyEngine,\n     states: Arc<Mutex<HashMap<String, RequestState>>>,\n     machines: Arc<Mutex<HashMap<String, signer_flow::StateMachine>>>,\n     intents: Arc<Mutex<HashMap<String, SigningIntent>>>,\n }\n \n #[cfg(unix)]\n pub fn serve_one_unix_request(socket_path: &Path, service: &SignerService) -> Result<()> {\n-    if socket_path.exists() {\n-        let _ = std::fs::remove_file(socket_path);\n-    }\n-\n-    let listener = UnixListener::bind(socket_path).map_err(|e| {\n-        ButterflyBotError::Runtime(format!(\n-            \"failed to bind signer socket {}: {e}\",\n-            socket_path.to_string_lossy()\n-        ))\n-    })?;\n-\n-    let (stream, _) = listener\n-        .accept()\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    crate::security::ipc::enforce_same_user_peer(&stream)?;\n-\n-    let mut reader = BufReader::new(\n-        stream\n-            .try_clone()\n-            .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?,\n-    );\n-    let mut request_line = String::new();\n-    reader\n-        .read_line(&mut request_line)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-\n-    let request: SignerRequest = serde_json::from_str(request_line.trim()).map_err(|e| {\n-        ButterflyBotError::Serialization(format!(\"failed to parse signer request: {e}\"))\n-    })?;\n-    let response = service.process(request)?;\n-    let payload = serde_json::to_string(&response)\n-        .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n-\n-    let mut write_stream = stream;\n-    write_stream\n-        .write_all(payload.as_bytes())\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    write_stream\n-        .write_all(b\"\\n\")\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(unix)]\n pub fn send_unix_request(socket_path: &Path, request: &SignerRequest) -> Result<SignerResponse> {\n     let mut stream = {\n         let mut connected = None;\n         for _ in 0..20 {\n             match UnixStream::connect(socket_path) {\n",
    "file": "src/security/signer_daemon.rs",
    "function": {
      "function_name": "serve_one_unix_request",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 110
        },
        "start": {
          "column": 1,
          "line": 66
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/signer_daemon.rs:68:5: replace serve_one_unix_request -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 109
      },
      "start": {
        "column": 5,
        "line": 68
      }
    }
  },
  {
    "diff": "--- src/security/signer_daemon.rs\n+++ replace send_unix_request -> Result<SignerResponse> with Ok(Default::default())\n@@ -106,53 +106,17 @@\n         .write_all(b\"\\n\")\n         .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n \n     Ok(())\n }\n \n #[cfg(unix)]\n pub fn send_unix_request(socket_path: &Path, request: &SignerRequest) -> Result<SignerResponse> {\n-    let mut stream = {\n-        let mut connected = None;\n-        for _ in 0..20 {\n-            match UnixStream::connect(socket_path) {\n-                Ok(stream) => {\n-                    connected = Some(stream);\n-                    break;\n-                }\n-                Err(_) => std::thread::sleep(std::time::Duration::from_millis(10)),\n-            }\n-        }\n-\n-        connected.ok_or_else(|| {\n-            ButterflyBotError::Runtime(format!(\n-                \"failed to connect signer socket {}\",\n-                socket_path.to_string_lossy()\n-            ))\n-        })?\n-    };\n-\n-    let payload = serde_json::to_string(request)\n-        .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n-    stream\n-        .write_all(payload.as_bytes())\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    stream\n-        .write_all(b\"\\n\")\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-\n-    let mut reader = BufReader::new(stream);\n-    let mut line = String::new();\n-    reader\n-        .read_line(&mut line)\n-        .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-    let response: SignerResponse = serde_json::from_str(line.trim())\n-        .map_err(|e| ButterflyBotError::Serialization(e.to_string()))?;\n-    Ok(response)\n+    Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n }\n \n impl SignerService {\n     pub fn new(policy: PolicyEngine) -> Self {\n         Self {\n             policy,\n             states: Arc::new(Mutex::new(HashMap::new())),\n             machines: Arc::new(Mutex::new(HashMap::new())),\n",
    "file": "src/security/signer_daemon.rs",
    "function": {
      "function_name": "send_unix_request",
      "return_type": "-> Result<SignerResponse>",
      "span": {
        "end": {
          "column": 2,
          "line": 151
        },
        "start": {
          "column": 1,
          "line": 112
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/signer_daemon.rs:114:5: replace send_unix_request -> Result<SignerResponse> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 17,
        "line": 150
      },
      "start": {
        "column": 5,
        "line": 114
      }
    }
  },
  {
    "diff": "--- src/security/signer_daemon.rs\n+++ replace SignerService::default -> Self with Default::default()\n@@ -156,17 +156,17 @@\n             policy,\n             states: Arc::new(Mutex::new(HashMap::new())),\n             machines: Arc::new(Mutex::new(HashMap::new())),\n             intents: Arc::new(Mutex::new(HashMap::new())),\n         }\n     }\n \n     pub fn default() -> Self {\n-        Self::new(default_policy_engine())\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n \n     pub fn process(&self, request: SignerRequest) -> Result<SignerResponse> {\n         match request {\n             SignerRequest::Preview { intent } => self.preview(intent),\n             SignerRequest::Approve { request_id } => self.approve(&request_id),\n             SignerRequest::Sign { request_id } => self.sign(&request_id),\n             SignerRequest::Deny { request_id } => self.deny(&request_id),\n",
    "file": "src/security/signer_daemon.rs",
    "function": {
      "function_name": "SignerService::default",
      "return_type": "-> Self",
      "span": {
        "end": {
          "column": 6,
          "line": 165
        },
        "start": {
          "column": 5,
          "line": 163
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/signer_daemon.rs:164:9: replace SignerService::default -> Self with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 43,
        "line": 164
      },
      "start": {
        "column": 9,
        "line": 164
      }
    }
  },
  {
    "diff": "--- src/security/signer_daemon.rs\n+++ replace SignerService::process -> Result<SignerResponse> with Ok(Default::default())\n@@ -160,22 +160,17 @@\n         }\n     }\n \n     pub fn default() -> Self {\n         Self::new(default_policy_engine())\n     }\n \n     pub fn process(&self, request: SignerRequest) -> Result<SignerResponse> {\n-        match request {\n-            SignerRequest::Preview { intent } => self.preview(intent),\n-            SignerRequest::Approve { request_id } => self.approve(&request_id),\n-            SignerRequest::Sign { request_id } => self.sign(&request_id),\n-            SignerRequest::Deny { request_id } => self.deny(&request_id),\n-        }\n+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn preview(&self, intent: SigningIntent) -> Result<SignerResponse> {\n         let decision = self.policy.evaluate(&intent, 0);\n \n         let mut machine = signer_flow::StateMachine::new();\n         machine.consume(&signer_flow::Input::PolicyChecked).map_err(|_| {\n             ButterflyBotError::SecurityPolicy(\"DENY_INVALID_TRANSITION\".to_string())\n",
    "file": "src/security/signer_daemon.rs",
    "function": {
      "function_name": "SignerService::process",
      "return_type": "-> Result<SignerResponse>",
      "span": {
        "end": {
          "column": 6,
          "line": 174
        },
        "start": {
          "column": 5,
          "line": 167
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/signer_daemon.rs:168:9: replace SignerService::process -> Result<SignerResponse> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 10,
        "line": 173
      },
      "start": {
        "column": 9,
        "line": 168
      }
    }
  },
  {
    "diff": "--- src/security/signer_daemon.rs\n+++ replace SignerService::preview -> Result<SignerResponse> with Ok(Default::default())\n@@ -169,76 +169,17 @@\n             SignerRequest::Preview { intent } => self.preview(intent),\n             SignerRequest::Approve { request_id } => self.approve(&request_id),\n             SignerRequest::Sign { request_id } => self.sign(&request_id),\n             SignerRequest::Deny { request_id } => self.deny(&request_id),\n         }\n     }\n \n     fn preview(&self, intent: SigningIntent) -> Result<SignerResponse> {\n-        let decision = self.policy.evaluate(&intent, 0);\n-\n-        let mut machine = signer_flow::StateMachine::new();\n-        machine.consume(&signer_flow::Input::PolicyChecked).map_err(|_| {\n-            ButterflyBotError::SecurityPolicy(\"DENY_INVALID_TRANSITION\".to_string())\n-        })?;\n-\n-        {\n-            let mut intents = self\n-                .intents\n-                .lock()\n-                .map_err(|_| ButterflyBotError::Runtime(\"intent lock poisoned\".to_string()))?;\n-            intents.insert(intent.request_id.clone(), intent.clone());\n-        }\n-\n-        {\n-            let mut machines = self\n-                .machines\n-                .lock()\n-                .map_err(|_| ButterflyBotError::Runtime(\"machine lock poisoned\".to_string()))?;\n-            machines.insert(intent.request_id.clone(), machine);\n-        }\n-\n-        let mut states = self\n-            .states\n-            .lock()\n-            .map_err(|_| ButterflyBotError::Runtime(\"state lock poisoned\".to_string()))?;\n-\n-        states.insert(intent.request_id.clone(), RequestState::PolicyEvaluated);\n-\n-        match decision {\n-            PolicyDecision::AutoApproved { reason_code } => {\n-                self.consume_transition(&intent.request_id, signer_flow::Input::AutoApprove)?;\n-                states.insert(intent.request_id, RequestState::Approved);\n-                Ok(SignerResponse {\n-                    status: \"approved\".to_string(),\n-                    reason_code: reason_code.to_string(),\n-                    signature: None,\n-                })\n-            }\n-            PolicyDecision::NeedsApproval { reason_code } => {\n-                self.consume_transition(&intent.request_id, signer_flow::Input::RequireApproval)?;\n-                states.insert(intent.request_id, RequestState::AwaitUserApproval);\n-                Ok(SignerResponse {\n-                    status: \"await_user_approval\".to_string(),\n-                    reason_code: reason_code.to_string(),\n-                    signature: None,\n-                })\n-            }\n-            PolicyDecision::Denied { reason_code } => {\n-                self.consume_transition(&intent.request_id, signer_flow::Input::Deny)?;\n-                states.insert(intent.request_id, RequestState::Denied);\n-                ensure_policy_allows(&PolicyDecision::Denied { reason_code })?;\n-                Ok(SignerResponse {\n-                    status: \"denied\".to_string(),\n-                    reason_code: reason_code.to_string(),\n-                    signature: None,\n-                })\n-            }\n-        }\n+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn approve(&self, request_id: &str) -> Result<SignerResponse> {\n         self.consume_transition(request_id, signer_flow::Input::Approve)?;\n \n         let mut states = self\n             .states\n             .lock()\n",
    "file": "src/security/signer_daemon.rs",
    "function": {
      "function_name": "SignerService::preview",
      "return_type": "-> Result<SignerResponse>",
      "span": {
        "end": {
          "column": 6,
          "line": 237
        },
        "start": {
          "column": 5,
          "line": 176
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/signer_daemon.rs:177:9: replace SignerService::preview -> Result<SignerResponse> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 10,
        "line": 236
      },
      "start": {
        "column": 9,
        "line": 177
      }
    }
  },
  {
    "diff": "--- src/security/signer_daemon.rs\n+++ replace SignerService::approve -> Result<SignerResponse> with Ok(Default::default())\n@@ -232,29 +232,17 @@\n                     reason_code: reason_code.to_string(),\n                     signature: None,\n                 })\n             }\n         }\n     }\n \n     fn approve(&self, request_id: &str) -> Result<SignerResponse> {\n-        self.consume_transition(request_id, signer_flow::Input::Approve)?;\n-\n-        let mut states = self\n-            .states\n-            .lock()\n-            .map_err(|_| ButterflyBotError::Runtime(\"state lock poisoned\".to_string()))?;\n-\n-        states.insert(request_id.to_string(), RequestState::Approved);\n-        Ok(SignerResponse {\n-            status: \"approved\".to_string(),\n-            reason_code: \"ALLOW_USER_INITIATED\".to_string(),\n-            signature: None,\n-        })\n+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn sign(&self, request_id: &str) -> Result<SignerResponse> {\n         self.consume_transition(request_id, signer_flow::Input::Sign)?;\n \n         {\n             let mut states = self\n                 .states\n",
    "file": "src/security/signer_daemon.rs",
    "function": {
      "function_name": "SignerService::approve",
      "return_type": "-> Result<SignerResponse>",
      "span": {
        "end": {
          "column": 6,
          "line": 253
        },
        "start": {
          "column": 5,
          "line": 239
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/signer_daemon.rs:240:9: replace SignerService::approve -> Result<SignerResponse> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 11,
        "line": 252
      },
      "start": {
        "column": 9,
        "line": 240
      }
    }
  },
  {
    "diff": "--- src/security/signer_daemon.rs\n+++ replace SignerService::sign -> Result<SignerResponse> with Ok(Default::default())\n@@ -248,47 +248,17 @@\n         Ok(SignerResponse {\n             status: \"approved\".to_string(),\n             reason_code: \"ALLOW_USER_INITIATED\".to_string(),\n             signature: None,\n         })\n     }\n \n     fn sign(&self, request_id: &str) -> Result<SignerResponse> {\n-        self.consume_transition(request_id, signer_flow::Input::Sign)?;\n-\n-        {\n-            let mut states = self\n-                .states\n-                .lock()\n-                .map_err(|_| ButterflyBotError::Runtime(\"state lock poisoned\".to_string()))?;\n-            states.insert(request_id.to_string(), RequestState::Signing);\n-        }\n-\n-        let mut random = [0u8; 16];\n-        let mut rng = SysRng;\n-        rng.try_fill_bytes(&mut random)\n-            .map_err(|e| ButterflyBotError::Runtime(e.to_string()))?;\n-        let signature = URL_SAFE_NO_PAD.encode(random);\n-\n-        self.consume_transition(request_id, signer_flow::Input::Signed)?;\n-\n-        {\n-            let mut states = self\n-                .states\n-                .lock()\n-                .map_err(|_| ButterflyBotError::Runtime(\"state lock poisoned\".to_string()))?;\n-            states.insert(request_id.to_string(), RequestState::Approved);\n-        }\n-\n-        Ok(SignerResponse {\n-            status: \"signed\".to_string(),\n-            reason_code: \"ALLOW_AUTO_POLICY_OK\".to_string(),\n-            signature: Some(signature),\n-        })\n+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn deny(&self, request_id: &str) -> Result<SignerResponse> {\n         let _ = self.consume_transition(request_id, signer_flow::Input::Deny);\n         let mut states = self\n             .states\n             .lock()\n             .map_err(|_| ButterflyBotError::Runtime(\"state lock poisoned\".to_string()))?;\n",
    "file": "src/security/signer_daemon.rs",
    "function": {
      "function_name": "SignerService::sign",
      "return_type": "-> Result<SignerResponse>",
      "span": {
        "end": {
          "column": 6,
          "line": 287
        },
        "start": {
          "column": 5,
          "line": 255
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/signer_daemon.rs:256:9: replace SignerService::sign -> Result<SignerResponse> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 11,
        "line": 286
      },
      "start": {
        "column": 9,
        "line": 256
      }
    }
  },
  {
    "diff": "--- src/security/signer_daemon.rs\n+++ replace SignerService::deny -> Result<SignerResponse> with Ok(Default::default())\n@@ -282,27 +282,17 @@\n         Ok(SignerResponse {\n             status: \"signed\".to_string(),\n             reason_code: \"ALLOW_AUTO_POLICY_OK\".to_string(),\n             signature: Some(signature),\n         })\n     }\n \n     fn deny(&self, request_id: &str) -> Result<SignerResponse> {\n-        let _ = self.consume_transition(request_id, signer_flow::Input::Deny);\n-        let mut states = self\n-            .states\n-            .lock()\n-            .map_err(|_| ButterflyBotError::Runtime(\"state lock poisoned\".to_string()))?;\n-        states.insert(request_id.to_string(), RequestState::Denied);\n-        Ok(SignerResponse {\n-            status: \"denied\".to_string(),\n-            reason_code: \"DENY_USER_POLICY\".to_string(),\n-            signature: None,\n-        })\n+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     fn consume_transition(&self, request_id: &str, input: signer_flow::Input) -> Result<()> {\n         let mut machines = self\n             .machines\n             .lock()\n             .map_err(|_| ButterflyBotError::Runtime(\"machine lock poisoned\".to_string()))?;\n         let machine = machines.get_mut(request_id).ok_or_else(|| {\n",
    "file": "src/security/signer_daemon.rs",
    "function": {
      "function_name": "SignerService::deny",
      "return_type": "-> Result<SignerResponse>",
      "span": {
        "end": {
          "column": 6,
          "line": 301
        },
        "start": {
          "column": 5,
          "line": 289
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/signer_daemon.rs:290:9: replace SignerService::deny -> Result<SignerResponse> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 11,
        "line": 300
      },
      "start": {
        "column": 9,
        "line": 290
      }
    }
  },
  {
    "diff": "--- src/security/signer_daemon.rs\n+++ replace SignerService::consume_transition -> Result<()> with Ok(())\n@@ -296,27 +296,17 @@\n         Ok(SignerResponse {\n             status: \"denied\".to_string(),\n             reason_code: \"DENY_USER_POLICY\".to_string(),\n             signature: None,\n         })\n     }\n \n     fn consume_transition(&self, request_id: &str, input: signer_flow::Input) -> Result<()> {\n-        let mut machines = self\n-            .machines\n-            .lock()\n-            .map_err(|_| ButterflyBotError::Runtime(\"machine lock poisoned\".to_string()))?;\n-        let machine = machines.get_mut(request_id).ok_or_else(|| {\n-            ButterflyBotError::SecurityPolicy(\"DENY_INVALID_TRANSITION\".to_string())\n-        })?;\n-        machine\n-            .consume(&input)\n-            .map_err(|_| ButterflyBotError::SecurityPolicy(\"DENY_INVALID_TRANSITION\".to_string()))?;\n-        Ok(())\n+        Ok(()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n #[cfg(test)]\n mod tests {\n     use super::*;\n     #[cfg(unix)]\n     use std::thread;\n",
    "file": "src/security/signer_daemon.rs",
    "function": {
      "function_name": "SignerService::consume_transition",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 6,
          "line": 315
        },
        "start": {
          "column": 5,
          "line": 303
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/signer_daemon.rs:304:9: replace SignerService::consume_transition -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 15,
        "line": 314
      },
      "start": {
        "column": 9,
        "line": 304
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace StartupComplianceReport::is_compliant -> bool with true\n@@ -7,20 +7,17 @@\n     pub strict_profile: bool,\n     pub page_locking_ready: bool,\n     pub core_dump_protection_ready: bool,\n     pub ptrace_protection_ready: bool,\n }\n \n impl StartupComplianceReport {\n     pub fn is_compliant(&self) -> bool {\n-        self.strict_profile\n-            && self.page_locking_ready\n-            && self.core_dump_protection_ready\n-            && self.ptrace_protection_ready\n+        true /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n impl fmt::Display for StartupComplianceReport {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n             \"strict_profile={}, page_locking_ready={}, core_dump_protection_ready={}, ptrace_protection_ready={}, compliant={}\",\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "StartupComplianceReport::is_compliant",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 19
        },
        "start": {
          "column": 5,
          "line": 14
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:15:9: replace StartupComplianceReport::is_compliant -> bool with true",
    "package": "butterfly-bot",
    "replacement": "true",
    "span": {
      "end": {
        "column": 44,
        "line": 18
      },
      "start": {
        "column": 9,
        "line": 15
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace StartupComplianceReport::is_compliant -> bool with false\n@@ -7,20 +7,17 @@\n     pub strict_profile: bool,\n     pub page_locking_ready: bool,\n     pub core_dump_protection_ready: bool,\n     pub ptrace_protection_ready: bool,\n }\n \n impl StartupComplianceReport {\n     pub fn is_compliant(&self) -> bool {\n-        self.strict_profile\n-            && self.page_locking_ready\n-            && self.core_dump_protection_ready\n-            && self.ptrace_protection_ready\n+        false /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n impl fmt::Display for StartupComplianceReport {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n             \"strict_profile={}, page_locking_ready={}, core_dump_protection_ready={}, ptrace_protection_ready={}, compliant={}\",\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "StartupComplianceReport::is_compliant",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 19
        },
        "start": {
          "column": 5,
          "line": 14
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:15:9: replace StartupComplianceReport::is_compliant -> bool with false",
    "package": "butterfly-bot",
    "replacement": "false",
    "span": {
      "end": {
        "column": 44,
        "line": 18
      },
      "start": {
        "column": 9,
        "line": 15
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace && with || in StartupComplianceReport::is_compliant\n@@ -10,17 +10,17 @@\n     pub ptrace_protection_ready: bool,\n }\n \n impl StartupComplianceReport {\n     pub fn is_compliant(&self) -> bool {\n         self.strict_profile\n             && self.page_locking_ready\n             && self.core_dump_protection_ready\n-            && self.ptrace_protection_ready\n+            || /* ~ changed by cargo-mutants ~ */ self.ptrace_protection_ready\n     }\n }\n \n impl fmt::Display for StartupComplianceReport {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n             \"strict_profile={}, page_locking_ready={}, core_dump_protection_ready={}, ptrace_protection_ready={}, compliant={}\",\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "StartupComplianceReport::is_compliant",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 19
        },
        "start": {
          "column": 5,
          "line": 14
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:18:13: replace && with || in StartupComplianceReport::is_compliant",
    "package": "butterfly-bot",
    "replacement": "||",
    "span": {
      "end": {
        "column": 15,
        "line": 18
      },
      "start": {
        "column": 13,
        "line": 18
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace && with || in StartupComplianceReport::is_compliant\n@@ -9,17 +9,17 @@\n     pub core_dump_protection_ready: bool,\n     pub ptrace_protection_ready: bool,\n }\n \n impl StartupComplianceReport {\n     pub fn is_compliant(&self) -> bool {\n         self.strict_profile\n             && self.page_locking_ready\n-            && self.core_dump_protection_ready\n+            || /* ~ changed by cargo-mutants ~ */ self.core_dump_protection_ready\n             && self.ptrace_protection_ready\n     }\n }\n \n impl fmt::Display for StartupComplianceReport {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n             f,\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "StartupComplianceReport::is_compliant",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 19
        },
        "start": {
          "column": 5,
          "line": 14
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:17:13: replace && with || in StartupComplianceReport::is_compliant",
    "package": "butterfly-bot",
    "replacement": "||",
    "span": {
      "end": {
        "column": 15,
        "line": 17
      },
      "start": {
        "column": 13,
        "line": 17
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace && with || in StartupComplianceReport::is_compliant\n@@ -8,17 +8,17 @@\n     pub page_locking_ready: bool,\n     pub core_dump_protection_ready: bool,\n     pub ptrace_protection_ready: bool,\n }\n \n impl StartupComplianceReport {\n     pub fn is_compliant(&self) -> bool {\n         self.strict_profile\n-            && self.page_locking_ready\n+            || /* ~ changed by cargo-mutants ~ */ self.page_locking_ready\n             && self.core_dump_protection_ready\n             && self.ptrace_protection_ready\n     }\n }\n \n impl fmt::Display for StartupComplianceReport {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "StartupComplianceReport::is_compliant",
      "return_type": "-> bool",
      "span": {
        "end": {
          "column": 6,
          "line": 19
        },
        "start": {
          "column": 5,
          "line": 14
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:16:13: replace && with || in StartupComplianceReport::is_compliant",
    "package": "butterfly-bot",
    "replacement": "||",
    "span": {
      "end": {
        "column": 15,
        "line": 16
      },
      "start": {
        "column": 13,
        "line": 16
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace <impl fmt::Display for StartupComplianceReport>::fmt -> fmt::Result with Ok(Default::default())\n@@ -16,25 +16,17 @@\n             && self.page_locking_ready\n             && self.core_dump_protection_ready\n             && self.ptrace_protection_ready\n     }\n }\n \n impl fmt::Display for StartupComplianceReport {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"strict_profile={}, page_locking_ready={}, core_dump_protection_ready={}, ptrace_protection_ready={}, compliant={}\",\n-            self.strict_profile,\n-            self.page_locking_ready,\n-            self.core_dump_protection_ready,\n-            self.ptrace_protection_ready,\n-            self.is_compliant()\n-        )\n+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n pub struct SensitiveBuffer {\n     bytes: Vec<u8>,\n     locked: bool,\n }\n \n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "<impl fmt::Display for StartupComplianceReport>::fmt",
      "return_type": "-> fmt::Result",
      "span": {
        "end": {
          "column": 6,
          "line": 33
        },
        "start": {
          "column": 5,
          "line": 23
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:24:9: replace <impl fmt::Display for StartupComplianceReport>::fmt -> fmt::Result with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 10,
        "line": 32
      },
      "start": {
        "column": 9,
        "line": 24
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace SensitiveBuffer::from_vec -> Result<Self> with Ok(Default::default())\n@@ -35,23 +35,17 @@\n \n pub struct SensitiveBuffer {\n     bytes: Vec<u8>,\n     locked: bool,\n }\n \n impl SensitiveBuffer {\n     pub fn from_vec(bytes: Vec<u8>) -> Result<Self> {\n-        if !bytes.is_empty() {\n-            lock_bytes(&bytes)?;\n-        }\n-        Ok(Self {\n-            bytes,\n-            locked: true,\n-        })\n+        Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n     }\n \n     pub fn expose<R>(&self, f: impl FnOnce(&[u8]) -> R) -> R {\n         f(&self.bytes)\n     }\n }\n \n impl Drop for SensitiveBuffer {\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "SensitiveBuffer::from_vec",
      "return_type": "-> Result<Self>",
      "span": {
        "end": {
          "column": 6,
          "line": 50
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:43:9: replace SensitiveBuffer::from_vec -> Result<Self> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 11,
        "line": 49
      },
      "start": {
        "column": 9,
        "line": 43
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ delete ! in SensitiveBuffer::from_vec\n@@ -35,17 +35,17 @@\n \n pub struct SensitiveBuffer {\n     bytes: Vec<u8>,\n     locked: bool,\n }\n \n impl SensitiveBuffer {\n     pub fn from_vec(bytes: Vec<u8>) -> Result<Self> {\n-        if !bytes.is_empty() {\n+        if  /* ~ changed by cargo-mutants ~ */bytes.is_empty() {\n             lock_bytes(&bytes)?;\n         }\n         Ok(Self {\n             bytes,\n             locked: true,\n         })\n     }\n \n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "SensitiveBuffer::from_vec",
      "return_type": "-> Result<Self>",
      "span": {
        "end": {
          "column": 6,
          "line": 50
        },
        "start": {
          "column": 5,
          "line": 42
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/security/hardening.rs:43:12: delete ! in SensitiveBuffer::from_vec",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 13,
        "line": 43
      },
      "start": {
        "column": 12,
        "line": 43
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace SensitiveBuffer::expose -> R with Default::default()\n@@ -45,17 +45,17 @@\n         }\n         Ok(Self {\n             bytes,\n             locked: true,\n         })\n     }\n \n     pub fn expose<R>(&self, f: impl FnOnce(&[u8]) -> R) -> R {\n-        f(&self.bytes)\n+        Default::default() /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n impl Drop for SensitiveBuffer {\n     fn drop(&mut self) {\n         if self.locked && !self.bytes.is_empty() {\n             let _ = unlock_bytes(&self.bytes);\n         }\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "SensitiveBuffer::expose",
      "return_type": "-> R",
      "span": {
        "end": {
          "column": 6,
          "line": 54
        },
        "start": {
          "column": 5,
          "line": 52
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:53:9: replace SensitiveBuffer::expose -> R with Default::default()",
    "package": "butterfly-bot",
    "replacement": "Default::default()",
    "span": {
      "end": {
        "column": 23,
        "line": 53
      },
      "start": {
        "column": 9,
        "line": 53
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace <impl Drop for SensitiveBuffer>::drop with ()\n@@ -51,21 +51,17 @@\n \n     pub fn expose<R>(&self, f: impl FnOnce(&[u8]) -> R) -> R {\n         f(&self.bytes)\n     }\n }\n \n impl Drop for SensitiveBuffer {\n     fn drop(&mut self) {\n-        if self.locked && !self.bytes.is_empty() {\n-            let _ = unlock_bytes(&self.bytes);\n-        }\n-        self.bytes.zeroize();\n-        self.locked = false;\n+        () /* ~ changed by cargo-mutants ~ */\n     }\n }\n \n pub fn with_sensitive_string<T, F>(secret: String, f: F) -> Result<T>\n where\n     F: FnOnce(&str) -> Result<T>,\n {\n     let buffer = SensitiveBuffer::from_vec(secret.into_bytes())?;\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "<impl Drop for SensitiveBuffer>::drop",
      "return_type": "",
      "span": {
        "end": {
          "column": 6,
          "line": 64
        },
        "start": {
          "column": 5,
          "line": 58
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:59:9: replace <impl Drop for SensitiveBuffer>::drop with ()",
    "package": "butterfly-bot",
    "replacement": "()",
    "span": {
      "end": {
        "column": 29,
        "line": 63
      },
      "start": {
        "column": 9,
        "line": 59
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace && with || in <impl Drop for SensitiveBuffer>::drop\n@@ -51,17 +51,17 @@\n \n     pub fn expose<R>(&self, f: impl FnOnce(&[u8]) -> R) -> R {\n         f(&self.bytes)\n     }\n }\n \n impl Drop for SensitiveBuffer {\n     fn drop(&mut self) {\n-        if self.locked && !self.bytes.is_empty() {\n+        if self.locked || /* ~ changed by cargo-mutants ~ */ !self.bytes.is_empty() {\n             let _ = unlock_bytes(&self.bytes);\n         }\n         self.bytes.zeroize();\n         self.locked = false;\n     }\n }\n \n pub fn with_sensitive_string<T, F>(secret: String, f: F) -> Result<T>\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "<impl Drop for SensitiveBuffer>::drop",
      "return_type": "",
      "span": {
        "end": {
          "column": 6,
          "line": 64
        },
        "start": {
          "column": 5,
          "line": 58
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:59:24: replace && with || in <impl Drop for SensitiveBuffer>::drop",
    "package": "butterfly-bot",
    "replacement": "||",
    "span": {
      "end": {
        "column": 26,
        "line": 59
      },
      "start": {
        "column": 24,
        "line": 59
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ delete ! in <impl Drop for SensitiveBuffer>::drop\n@@ -51,17 +51,17 @@\n \n     pub fn expose<R>(&self, f: impl FnOnce(&[u8]) -> R) -> R {\n         f(&self.bytes)\n     }\n }\n \n impl Drop for SensitiveBuffer {\n     fn drop(&mut self) {\n-        if self.locked && !self.bytes.is_empty() {\n+        if self.locked &&  /* ~ changed by cargo-mutants ~ */self.bytes.is_empty() {\n             let _ = unlock_bytes(&self.bytes);\n         }\n         self.bytes.zeroize();\n         self.locked = false;\n     }\n }\n \n pub fn with_sensitive_string<T, F>(secret: String, f: F) -> Result<T>\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "<impl Drop for SensitiveBuffer>::drop",
      "return_type": "",
      "span": {
        "end": {
          "column": 6,
          "line": 64
        },
        "start": {
          "column": 5,
          "line": 58
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/security/hardening.rs:59:27: delete ! in <impl Drop for SensitiveBuffer>::drop",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 28,
        "line": 59
      },
      "start": {
        "column": 27,
        "line": 59
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace with_sensitive_string -> Result<T> with Ok(Default::default())\n@@ -63,20 +63,17 @@\n         self.locked = false;\n     }\n }\n \n pub fn with_sensitive_string<T, F>(secret: String, f: F) -> Result<T>\n where\n     F: FnOnce(&str) -> Result<T>,\n {\n-    let buffer = SensitiveBuffer::from_vec(secret.into_bytes())?;\n-    let text = std::str::from_utf8(buffer.bytes.as_slice())\n-        .map_err(|e| ButterflyBotError::SecurityPolicy(format!(\"invalid utf-8 in sensitive string: {e}\")))?;\n-    f(text)\n+    Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n }\n \n pub fn run_startup_self_check() -> Result<StartupComplianceReport> {\n     let report = StartupComplianceReport {\n         strict_profile: true,\n         page_locking_ready: verify_page_locking()?,\n         core_dump_protection_ready: enforce_core_dump_protection()?,\n         ptrace_protection_ready: enforce_ptrace_protection()?,\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "with_sensitive_string",
      "return_type": "-> Result<T>",
      "span": {
        "end": {
          "column": 2,
          "line": 75
        },
        "start": {
          "column": 1,
          "line": 67
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:71:5: replace with_sensitive_string -> Result<T> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 12,
        "line": 74
      },
      "start": {
        "column": 5,
        "line": 71
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace run_startup_self_check -> Result<StartupComplianceReport> with Ok(Default::default())\n@@ -70,41 +70,17 @@\n {\n     let buffer = SensitiveBuffer::from_vec(secret.into_bytes())?;\n     let text = std::str::from_utf8(buffer.bytes.as_slice())\n         .map_err(|e| ButterflyBotError::SecurityPolicy(format!(\"invalid utf-8 in sensitive string: {e}\")))?;\n     f(text)\n }\n \n pub fn run_startup_self_check() -> Result<StartupComplianceReport> {\n-    let report = StartupComplianceReport {\n-        strict_profile: true,\n-        page_locking_ready: verify_page_locking()?,\n-        core_dump_protection_ready: enforce_core_dump_protection()?,\n-        ptrace_protection_ready: enforce_ptrace_protection()?,\n-    };\n-\n-    tracing::info!(\n-        target: \"security\",\n-        event = \"strict_profile_startup_self_check\",\n-        strict_profile = report.strict_profile,\n-        page_locking_ready = report.page_locking_ready,\n-        core_dump_protection_ready = report.core_dump_protection_ready,\n-        ptrace_protection_ready = report.ptrace_protection_ready,\n-        compliant = report.is_compliant(),\n-        \"security startup self-check complete\"\n-    );\n-\n-    if !report.is_compliant() {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"Strict profile compliance self-check failed\".to_string(),\n-        ));\n-    }\n-\n-    Ok(report)\n+    Ok(Default::default()) /* ~ changed by cargo-mutants ~ */\n }\n \n fn verify_page_locking() -> Result<bool> {\n     let sample = vec![0u8; 4096];\n     lock_bytes(&sample)?;\n     unlock_bytes(&sample)?;\n     Ok(true)\n }\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "run_startup_self_check",
      "return_type": "-> Result<StartupComplianceReport>",
      "span": {
        "end": {
          "column": 2,
          "line": 103
        },
        "start": {
          "column": 1,
          "line": 77
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:78:5: replace run_startup_self_check -> Result<StartupComplianceReport> with Ok(Default::default())",
    "package": "butterfly-bot",
    "replacement": "Ok(Default::default())",
    "span": {
      "end": {
        "column": 15,
        "line": 102
      },
      "start": {
        "column": 5,
        "line": 78
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ delete ! in run_startup_self_check\n@@ -88,17 +88,17 @@\n         strict_profile = report.strict_profile,\n         page_locking_ready = report.page_locking_ready,\n         core_dump_protection_ready = report.core_dump_protection_ready,\n         ptrace_protection_ready = report.ptrace_protection_ready,\n         compliant = report.is_compliant(),\n         \"security startup self-check complete\"\n     );\n \n-    if !report.is_compliant() {\n+    if  /* ~ changed by cargo-mutants ~ */report.is_compliant() {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"Strict profile compliance self-check failed\".to_string(),\n         ));\n     }\n \n     Ok(report)\n }\n \n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "run_startup_self_check",
      "return_type": "-> Result<StartupComplianceReport>",
      "span": {
        "end": {
          "column": 2,
          "line": 103
        },
        "start": {
          "column": 1,
          "line": 77
        }
      }
    },
    "genre": "UnaryOperator",
    "name": "src/security/hardening.rs:96:8: delete ! in run_startup_self_check",
    "package": "butterfly-bot",
    "replacement": "",
    "span": {
      "end": {
        "column": 9,
        "line": 96
      },
      "start": {
        "column": 8,
        "line": 96
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace verify_page_locking -> Result<bool> with Ok(true)\n@@ -98,20 +98,17 @@\n             \"Strict profile compliance self-check failed\".to_string(),\n         ));\n     }\n \n     Ok(report)\n }\n \n fn verify_page_locking() -> Result<bool> {\n-    let sample = vec![0u8; 4096];\n-    lock_bytes(&sample)?;\n-    unlock_bytes(&sample)?;\n-    Ok(true)\n+    Ok(true) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(target_os = \"linux\")]\n fn enforce_core_dump_protection() -> Result<bool> {\n     let mut current = libc::rlimit {\n         rlim_cur: 0,\n         rlim_max: 0,\n     };\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "verify_page_locking",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 110
        },
        "start": {
          "column": 1,
          "line": 105
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:106:5: replace verify_page_locking -> Result<bool> with Ok(true)",
    "package": "butterfly-bot",
    "replacement": "Ok(true)",
    "span": {
      "end": {
        "column": 13,
        "line": 109
      },
      "start": {
        "column": 5,
        "line": 106
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace verify_page_locking -> Result<bool> with Ok(false)\n@@ -98,20 +98,17 @@\n             \"Strict profile compliance self-check failed\".to_string(),\n         ));\n     }\n \n     Ok(report)\n }\n \n fn verify_page_locking() -> Result<bool> {\n-    let sample = vec![0u8; 4096];\n-    lock_bytes(&sample)?;\n-    unlock_bytes(&sample)?;\n-    Ok(true)\n+    Ok(false) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(target_os = \"linux\")]\n fn enforce_core_dump_protection() -> Result<bool> {\n     let mut current = libc::rlimit {\n         rlim_cur: 0,\n         rlim_max: 0,\n     };\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "verify_page_locking",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 110
        },
        "start": {
          "column": 1,
          "line": 105
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:106:5: replace verify_page_locking -> Result<bool> with Ok(false)",
    "package": "butterfly-bot",
    "replacement": "Ok(false)",
    "span": {
      "end": {
        "column": 13,
        "line": 109
      },
      "start": {
        "column": 5,
        "line": 106
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace enforce_core_dump_protection -> Result<bool> with Ok(true)\n@@ -106,52 +106,17 @@\n     let sample = vec![0u8; 4096];\n     lock_bytes(&sample)?;\n     unlock_bytes(&sample)?;\n     Ok(true)\n }\n \n #[cfg(target_os = \"linux\")]\n fn enforce_core_dump_protection() -> Result<bool> {\n-    let mut current = libc::rlimit {\n-        rlim_cur: 0,\n-        rlim_max: 0,\n-    };\n-\n-    let get_before = unsafe { libc::getrlimit(libc::RLIMIT_CORE, &mut current) };\n-    if get_before != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"failed to read RLIMIT_CORE\".to_string(),\n-        ));\n-    }\n-\n-    let hardened = libc::rlimit {\n-        rlim_cur: 0,\n-        rlim_max: current.rlim_max,\n-    };\n-\n-    let set_result = unsafe { libc::setrlimit(libc::RLIMIT_CORE, &hardened) };\n-    if set_result != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"failed to disable core dumps\".to_string(),\n-        ));\n-    }\n-\n-    let mut after = libc::rlimit {\n-        rlim_cur: 0,\n-        rlim_max: 0,\n-    };\n-    let get_after = unsafe { libc::getrlimit(libc::RLIMIT_CORE, &mut after) };\n-    if get_after != 0 || after.rlim_cur != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"core dump protection verification failed\".to_string(),\n-        ));\n-    }\n-\n-    Ok(true)\n+    Ok(true) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn enforce_core_dump_protection() -> Result<bool> {\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires Linux core dump protection controls\".to_string(),\n     ))\n }\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_core_dump_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 150
        },
        "start": {
          "column": 1,
          "line": 112
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:114:5: replace enforce_core_dump_protection -> Result<bool> with Ok(true)",
    "package": "butterfly-bot",
    "replacement": "Ok(true)",
    "span": {
      "end": {
        "column": 13,
        "line": 149
      },
      "start": {
        "column": 5,
        "line": 114
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace enforce_core_dump_protection -> Result<bool> with Ok(false)\n@@ -106,52 +106,17 @@\n     let sample = vec![0u8; 4096];\n     lock_bytes(&sample)?;\n     unlock_bytes(&sample)?;\n     Ok(true)\n }\n \n #[cfg(target_os = \"linux\")]\n fn enforce_core_dump_protection() -> Result<bool> {\n-    let mut current = libc::rlimit {\n-        rlim_cur: 0,\n-        rlim_max: 0,\n-    };\n-\n-    let get_before = unsafe { libc::getrlimit(libc::RLIMIT_CORE, &mut current) };\n-    if get_before != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"failed to read RLIMIT_CORE\".to_string(),\n-        ));\n-    }\n-\n-    let hardened = libc::rlimit {\n-        rlim_cur: 0,\n-        rlim_max: current.rlim_max,\n-    };\n-\n-    let set_result = unsafe { libc::setrlimit(libc::RLIMIT_CORE, &hardened) };\n-    if set_result != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"failed to disable core dumps\".to_string(),\n-        ));\n-    }\n-\n-    let mut after = libc::rlimit {\n-        rlim_cur: 0,\n-        rlim_max: 0,\n-    };\n-    let get_after = unsafe { libc::getrlimit(libc::RLIMIT_CORE, &mut after) };\n-    if get_after != 0 || after.rlim_cur != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"core dump protection verification failed\".to_string(),\n-        ));\n-    }\n-\n-    Ok(true)\n+    Ok(false) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn enforce_core_dump_protection() -> Result<bool> {\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires Linux core dump protection controls\".to_string(),\n     ))\n }\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_core_dump_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 150
        },
        "start": {
          "column": 1,
          "line": 112
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:114:5: replace enforce_core_dump_protection -> Result<bool> with Ok(false)",
    "package": "butterfly-bot",
    "replacement": "Ok(false)",
    "span": {
      "end": {
        "column": 13,
        "line": 149
      },
      "start": {
        "column": 5,
        "line": 114
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace != with == in enforce_core_dump_protection\n@@ -112,17 +112,17 @@\n #[cfg(target_os = \"linux\")]\n fn enforce_core_dump_protection() -> Result<bool> {\n     let mut current = libc::rlimit {\n         rlim_cur: 0,\n         rlim_max: 0,\n     };\n \n     let get_before = unsafe { libc::getrlimit(libc::RLIMIT_CORE, &mut current) };\n-    if get_before != 0 {\n+    if get_before == /* ~ changed by cargo-mutants ~ */ 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"failed to read RLIMIT_CORE\".to_string(),\n         ));\n     }\n \n     let hardened = libc::rlimit {\n         rlim_cur: 0,\n         rlim_max: current.rlim_max,\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_core_dump_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 150
        },
        "start": {
          "column": 1,
          "line": 112
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:120:19: replace != with == in enforce_core_dump_protection",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 21,
        "line": 120
      },
      "start": {
        "column": 19,
        "line": 120
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace != with == in enforce_core_dump_protection\n@@ -124,17 +124,17 @@\n     }\n \n     let hardened = libc::rlimit {\n         rlim_cur: 0,\n         rlim_max: current.rlim_max,\n     };\n \n     let set_result = unsafe { libc::setrlimit(libc::RLIMIT_CORE, &hardened) };\n-    if set_result != 0 {\n+    if set_result == /* ~ changed by cargo-mutants ~ */ 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"failed to disable core dumps\".to_string(),\n         ));\n     }\n \n     let mut after = libc::rlimit {\n         rlim_cur: 0,\n         rlim_max: 0,\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_core_dump_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 150
        },
        "start": {
          "column": 1,
          "line": 112
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:132:19: replace != with == in enforce_core_dump_protection",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 21,
        "line": 132
      },
      "start": {
        "column": 19,
        "line": 132
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace || with && in enforce_core_dump_protection\n@@ -135,17 +135,17 @@\n         ));\n     }\n \n     let mut after = libc::rlimit {\n         rlim_cur: 0,\n         rlim_max: 0,\n     };\n     let get_after = unsafe { libc::getrlimit(libc::RLIMIT_CORE, &mut after) };\n-    if get_after != 0 || after.rlim_cur != 0 {\n+    if get_after != 0 && /* ~ changed by cargo-mutants ~ */ after.rlim_cur != 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"core dump protection verification failed\".to_string(),\n         ));\n     }\n \n     Ok(true)\n }\n \n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_core_dump_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 150
        },
        "start": {
          "column": 1,
          "line": 112
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:143:23: replace || with && in enforce_core_dump_protection",
    "package": "butterfly-bot",
    "replacement": "&&",
    "span": {
      "end": {
        "column": 25,
        "line": 143
      },
      "start": {
        "column": 23,
        "line": 143
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace != with == in enforce_core_dump_protection\n@@ -135,17 +135,17 @@\n         ));\n     }\n \n     let mut after = libc::rlimit {\n         rlim_cur: 0,\n         rlim_max: 0,\n     };\n     let get_after = unsafe { libc::getrlimit(libc::RLIMIT_CORE, &mut after) };\n-    if get_after != 0 || after.rlim_cur != 0 {\n+    if get_after == /* ~ changed by cargo-mutants ~ */ 0 || after.rlim_cur != 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"core dump protection verification failed\".to_string(),\n         ));\n     }\n \n     Ok(true)\n }\n \n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_core_dump_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 150
        },
        "start": {
          "column": 1,
          "line": 112
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:143:18: replace != with == in enforce_core_dump_protection",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 20,
        "line": 143
      },
      "start": {
        "column": 18,
        "line": 143
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace != with == in enforce_core_dump_protection\n@@ -135,17 +135,17 @@\n         ));\n     }\n \n     let mut after = libc::rlimit {\n         rlim_cur: 0,\n         rlim_max: 0,\n     };\n     let get_after = unsafe { libc::getrlimit(libc::RLIMIT_CORE, &mut after) };\n-    if get_after != 0 || after.rlim_cur != 0 {\n+    if get_after != 0 || after.rlim_cur == /* ~ changed by cargo-mutants ~ */ 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"core dump protection verification failed\".to_string(),\n         ));\n     }\n \n     Ok(true)\n }\n \n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_core_dump_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 150
        },
        "start": {
          "column": 1,
          "line": 112
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:143:41: replace != with == in enforce_core_dump_protection",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 43,
        "line": 143
      },
      "start": {
        "column": 41,
        "line": 143
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace enforce_core_dump_protection -> Result<bool> with Ok(true)\n@@ -146,19 +146,17 @@\n         ));\n     }\n \n     Ok(true)\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn enforce_core_dump_protection() -> Result<bool> {\n-    Err(ButterflyBotError::SecurityPolicy(\n-        \"strict profile requires Linux core dump protection controls\".to_string(),\n-    ))\n+    Ok(true) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(target_os = \"linux\")]\n fn enforce_ptrace_protection() -> Result<bool> {\n     let deny_ptrace = unsafe { libc::prctl(libc::PR_SET_DUMPABLE, 0, 0, 0, 0) };\n     if deny_ptrace != 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"failed to set ptrace protection (PR_SET_DUMPABLE=0)\".to_string(),\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_core_dump_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 157
        },
        "start": {
          "column": 1,
          "line": 152
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:154:5: replace enforce_core_dump_protection -> Result<bool> with Ok(true)",
    "package": "butterfly-bot",
    "replacement": "Ok(true)",
    "span": {
      "end": {
        "column": 7,
        "line": 156
      },
      "start": {
        "column": 5,
        "line": 154
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace enforce_core_dump_protection -> Result<bool> with Ok(false)\n@@ -146,19 +146,17 @@\n         ));\n     }\n \n     Ok(true)\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn enforce_core_dump_protection() -> Result<bool> {\n-    Err(ButterflyBotError::SecurityPolicy(\n-        \"strict profile requires Linux core dump protection controls\".to_string(),\n-    ))\n+    Ok(false) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(target_os = \"linux\")]\n fn enforce_ptrace_protection() -> Result<bool> {\n     let deny_ptrace = unsafe { libc::prctl(libc::PR_SET_DUMPABLE, 0, 0, 0, 0) };\n     if deny_ptrace != 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"failed to set ptrace protection (PR_SET_DUMPABLE=0)\".to_string(),\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_core_dump_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 157
        },
        "start": {
          "column": 1,
          "line": 152
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:154:5: replace enforce_core_dump_protection -> Result<bool> with Ok(false)",
    "package": "butterfly-bot",
    "replacement": "Ok(false)",
    "span": {
      "end": {
        "column": 7,
        "line": 156
      },
      "start": {
        "column": 5,
        "line": 154
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace enforce_ptrace_protection -> Result<bool> with Ok(true)\n@@ -153,31 +153,17 @@\n fn enforce_core_dump_protection() -> Result<bool> {\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires Linux core dump protection controls\".to_string(),\n     ))\n }\n \n #[cfg(target_os = \"linux\")]\n fn enforce_ptrace_protection() -> Result<bool> {\n-    let deny_ptrace = unsafe { libc::prctl(libc::PR_SET_DUMPABLE, 0, 0, 0, 0) };\n-    if deny_ptrace != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"failed to set ptrace protection (PR_SET_DUMPABLE=0)\".to_string(),\n-        ));\n-    }\n-\n-    let dumpable = unsafe { libc::prctl(libc::PR_GET_DUMPABLE, 0, 0, 0, 0) };\n-    if dumpable != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"ptrace protection verification failed\".to_string(),\n-        ));\n-    }\n-\n-    Ok(true)\n+    Ok(true) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn enforce_ptrace_protection() -> Result<bool> {\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires Linux ptrace protection controls\".to_string(),\n     ))\n }\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_ptrace_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 176
        },
        "start": {
          "column": 1,
          "line": 159
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:161:5: replace enforce_ptrace_protection -> Result<bool> with Ok(true)",
    "package": "butterfly-bot",
    "replacement": "Ok(true)",
    "span": {
      "end": {
        "column": 13,
        "line": 175
      },
      "start": {
        "column": 5,
        "line": 161
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace enforce_ptrace_protection -> Result<bool> with Ok(false)\n@@ -153,31 +153,17 @@\n fn enforce_core_dump_protection() -> Result<bool> {\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires Linux core dump protection controls\".to_string(),\n     ))\n }\n \n #[cfg(target_os = \"linux\")]\n fn enforce_ptrace_protection() -> Result<bool> {\n-    let deny_ptrace = unsafe { libc::prctl(libc::PR_SET_DUMPABLE, 0, 0, 0, 0) };\n-    if deny_ptrace != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"failed to set ptrace protection (PR_SET_DUMPABLE=0)\".to_string(),\n-        ));\n-    }\n-\n-    let dumpable = unsafe { libc::prctl(libc::PR_GET_DUMPABLE, 0, 0, 0, 0) };\n-    if dumpable != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"ptrace protection verification failed\".to_string(),\n-        ));\n-    }\n-\n-    Ok(true)\n+    Ok(false) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn enforce_ptrace_protection() -> Result<bool> {\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires Linux ptrace protection controls\".to_string(),\n     ))\n }\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_ptrace_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 176
        },
        "start": {
          "column": 1,
          "line": 159
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:161:5: replace enforce_ptrace_protection -> Result<bool> with Ok(false)",
    "package": "butterfly-bot",
    "replacement": "Ok(false)",
    "span": {
      "end": {
        "column": 13,
        "line": 175
      },
      "start": {
        "column": 5,
        "line": 161
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace != with == in enforce_ptrace_protection\n@@ -154,17 +154,17 @@\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires Linux core dump protection controls\".to_string(),\n     ))\n }\n \n #[cfg(target_os = \"linux\")]\n fn enforce_ptrace_protection() -> Result<bool> {\n     let deny_ptrace = unsafe { libc::prctl(libc::PR_SET_DUMPABLE, 0, 0, 0, 0) };\n-    if deny_ptrace != 0 {\n+    if deny_ptrace == /* ~ changed by cargo-mutants ~ */ 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"failed to set ptrace protection (PR_SET_DUMPABLE=0)\".to_string(),\n         ));\n     }\n \n     let dumpable = unsafe { libc::prctl(libc::PR_GET_DUMPABLE, 0, 0, 0, 0) };\n     if dumpable != 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_ptrace_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 176
        },
        "start": {
          "column": 1,
          "line": 159
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:162:20: replace != with == in enforce_ptrace_protection",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 22,
        "line": 162
      },
      "start": {
        "column": 20,
        "line": 162
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace != with == in enforce_ptrace_protection\n@@ -161,17 +161,17 @@\n     let deny_ptrace = unsafe { libc::prctl(libc::PR_SET_DUMPABLE, 0, 0, 0, 0) };\n     if deny_ptrace != 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"failed to set ptrace protection (PR_SET_DUMPABLE=0)\".to_string(),\n         ));\n     }\n \n     let dumpable = unsafe { libc::prctl(libc::PR_GET_DUMPABLE, 0, 0, 0, 0) };\n-    if dumpable != 0 {\n+    if dumpable == /* ~ changed by cargo-mutants ~ */ 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"ptrace protection verification failed\".to_string(),\n         ));\n     }\n \n     Ok(true)\n }\n \n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_ptrace_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 176
        },
        "start": {
          "column": 1,
          "line": 159
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:169:17: replace != with == in enforce_ptrace_protection",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 19,
        "line": 169
      },
      "start": {
        "column": 17,
        "line": 169
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace enforce_ptrace_protection -> Result<bool> with Ok(true)\n@@ -172,19 +172,17 @@\n         ));\n     }\n \n     Ok(true)\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn enforce_ptrace_protection() -> Result<bool> {\n-    Err(ButterflyBotError::SecurityPolicy(\n-        \"strict profile requires Linux ptrace protection controls\".to_string(),\n-    ))\n+    Ok(true) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(target_os = \"linux\")]\n fn lock_bytes(value: &[u8]) -> Result<()> {\n     if value.is_empty() {\n         return Ok(());\n     }\n     let rc = unsafe { libc::mlock(value.as_ptr() as *const libc::c_void, value.len()) };\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_ptrace_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 183
        },
        "start": {
          "column": 1,
          "line": 178
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:180:5: replace enforce_ptrace_protection -> Result<bool> with Ok(true)",
    "package": "butterfly-bot",
    "replacement": "Ok(true)",
    "span": {
      "end": {
        "column": 7,
        "line": 182
      },
      "start": {
        "column": 5,
        "line": 180
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace enforce_ptrace_protection -> Result<bool> with Ok(false)\n@@ -172,19 +172,17 @@\n         ));\n     }\n \n     Ok(true)\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn enforce_ptrace_protection() -> Result<bool> {\n-    Err(ButterflyBotError::SecurityPolicy(\n-        \"strict profile requires Linux ptrace protection controls\".to_string(),\n-    ))\n+    Ok(false) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(target_os = \"linux\")]\n fn lock_bytes(value: &[u8]) -> Result<()> {\n     if value.is_empty() {\n         return Ok(());\n     }\n     let rc = unsafe { libc::mlock(value.as_ptr() as *const libc::c_void, value.len()) };\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "enforce_ptrace_protection",
      "return_type": "-> Result<bool>",
      "span": {
        "end": {
          "column": 2,
          "line": 183
        },
        "start": {
          "column": 1,
          "line": 178
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:180:5: replace enforce_ptrace_protection -> Result<bool> with Ok(false)",
    "package": "butterfly-bot",
    "replacement": "Ok(false)",
    "span": {
      "end": {
        "column": 7,
        "line": 182
      },
      "start": {
        "column": 5,
        "line": 180
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace lock_bytes -> Result<()> with Ok(())\n@@ -179,26 +179,17 @@\n fn enforce_ptrace_protection() -> Result<bool> {\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires Linux ptrace protection controls\".to_string(),\n     ))\n }\n \n #[cfg(target_os = \"linux\")]\n fn lock_bytes(value: &[u8]) -> Result<()> {\n-    if value.is_empty() {\n-        return Ok(());\n-    }\n-    let rc = unsafe { libc::mlock(value.as_ptr() as *const libc::c_void, value.len()) };\n-    if rc != 0 {\n-        return Err(ButterflyBotError::SecurityPolicy(\n-            \"strict profile requires page locking for sensitive buffers\".to_string(),\n-        ));\n-    }\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn lock_bytes(_value: &[u8]) -> Result<()> {\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires page locking on this platform\".to_string(),\n     ))\n }\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "lock_bytes",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 197
        },
        "start": {
          "column": 1,
          "line": 185
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:187:5: replace lock_bytes -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 196
      },
      "start": {
        "column": 5,
        "line": 187
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace != with == in lock_bytes\n@@ -183,17 +183,17 @@\n }\n \n #[cfg(target_os = \"linux\")]\n fn lock_bytes(value: &[u8]) -> Result<()> {\n     if value.is_empty() {\n         return Ok(());\n     }\n     let rc = unsafe { libc::mlock(value.as_ptr() as *const libc::c_void, value.len()) };\n-    if rc != 0 {\n+    if rc == /* ~ changed by cargo-mutants ~ */ 0 {\n         return Err(ButterflyBotError::SecurityPolicy(\n             \"strict profile requires page locking for sensitive buffers\".to_string(),\n         ));\n     }\n     Ok(())\n }\n \n #[cfg(not(target_os = \"linux\"))]\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "lock_bytes",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 197
        },
        "start": {
          "column": 1,
          "line": 185
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:191:11: replace != with == in lock_bytes",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 13,
        "line": 191
      },
      "start": {
        "column": 11,
        "line": 191
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace lock_bytes -> Result<()> with Ok(())\n@@ -193,19 +193,17 @@\n             \"strict profile requires page locking for sensitive buffers\".to_string(),\n         ));\n     }\n     Ok(())\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn lock_bytes(_value: &[u8]) -> Result<()> {\n-    Err(ButterflyBotError::SecurityPolicy(\n-        \"strict profile requires page locking on this platform\".to_string(),\n-    ))\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(target_os = \"linux\")]\n fn unlock_bytes(value: &[u8]) -> Result<()> {\n     if value.is_empty() {\n         return Ok(());\n     }\n     let rc = unsafe { libc::munlock(value.as_ptr() as *const libc::c_void, value.len()) };\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "lock_bytes",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 204
        },
        "start": {
          "column": 1,
          "line": 199
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:201:5: replace lock_bytes -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 7,
        "line": 203
      },
      "start": {
        "column": 5,
        "line": 201
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace unlock_bytes -> Result<()> with Ok(())\n@@ -200,26 +200,17 @@\n fn lock_bytes(_value: &[u8]) -> Result<()> {\n     Err(ButterflyBotError::SecurityPolicy(\n         \"strict profile requires page locking on this platform\".to_string(),\n     ))\n }\n \n #[cfg(target_os = \"linux\")]\n fn unlock_bytes(value: &[u8]) -> Result<()> {\n-    if value.is_empty() {\n-        return Ok(());\n-    }\n-    let rc = unsafe { libc::munlock(value.as_ptr() as *const libc::c_void, value.len()) };\n-    if rc != 0 {\n-        return Err(ButterflyBotError::Runtime(\n-            \"failed to unlock sensitive buffer\".to_string(),\n-        ));\n-    }\n-    Ok(())\n+    Ok(()) /* ~ changed by cargo-mutants ~ */\n }\n \n #[cfg(not(target_os = \"linux\"))]\n fn unlock_bytes(_value: &[u8]) -> Result<()> {\n     Ok(())\n }\n \n #[cfg(test)]\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "unlock_bytes",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 218
        },
        "start": {
          "column": 1,
          "line": 206
        }
      }
    },
    "genre": "FnValue",
    "name": "src/security/hardening.rs:208:5: replace unlock_bytes -> Result<()> with Ok(())",
    "package": "butterfly-bot",
    "replacement": "Ok(())",
    "span": {
      "end": {
        "column": 11,
        "line": 217
      },
      "start": {
        "column": 5,
        "line": 208
      }
    }
  },
  {
    "diff": "--- src/security/hardening.rs\n+++ replace != with == in unlock_bytes\n@@ -204,17 +204,17 @@\n }\n \n #[cfg(target_os = \"linux\")]\n fn unlock_bytes(value: &[u8]) -> Result<()> {\n     if value.is_empty() {\n         return Ok(());\n     }\n     let rc = unsafe { libc::munlock(value.as_ptr() as *const libc::c_void, value.len()) };\n-    if rc != 0 {\n+    if rc == /* ~ changed by cargo-mutants ~ */ 0 {\n         return Err(ButterflyBotError::Runtime(\n             \"failed to unlock sensitive buffer\".to_string(),\n         ));\n     }\n     Ok(())\n }\n \n #[cfg(not(target_os = \"linux\"))]\n",
    "file": "src/security/hardening.rs",
    "function": {
      "function_name": "unlock_bytes",
      "return_type": "-> Result<()>",
      "span": {
        "end": {
          "column": 2,
          "line": 218
        },
        "start": {
          "column": 1,
          "line": 206
        }
      }
    },
    "genre": "BinaryOperator",
    "name": "src/security/hardening.rs:212:11: replace != with == in unlock_bytes",
    "package": "butterfly-bot",
    "replacement": "==",
    "span": {
      "end": {
        "column": 13,
        "line": 212
      },
      "start": {
        "column": 11,
        "line": 212
      }
    }
  }
]